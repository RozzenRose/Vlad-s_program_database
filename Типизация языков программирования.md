![[Pasted image 20240617020824.png|600]]

***Типизация языков программирования*** - это то, как различные языки распознают типы переменных

Языки‌ ‌программирования‌ ‌бывают‌:
- нетипизированными‌ ‌(бестиповыми)
- типизированными‌

### Нетипизированные языки программирования 

Бестиповая типизация в основном присуща старым и низкоуровневым языкам программирования. Все данные в таких языках считаются цепочками бит произвольной длины и, как следует из названия, не делятся на типы. Работа с ними труднее, и при чтении кода не всегда ясно, о каком типе переменной идет речь. При этом у нетипизированных языков есть и плюсы: в них можно совершать операции с любыми данными, и код получается более эффективным

Преимущества:
- позволяют писать на предельно низком уровне, причем компилятор (интерпритатор) не будет мешать какими-либо проверками типов; вы вольны производить любые операции над любыми видами данных
- получаемы код обычно более эффективен
- прозрачность инструкций, то есть при знании языка обычно нет сомнений, что из себя представляет тот или иной код

Недостатки:
- сложность: могут возникнуть неудобства с представлением таких типов как списки, строки и т.д.
- отсутствие проверок: любые бессмысленные действия, например вычитание ссылки на список из строки будут считаться совершенно нормальными, что чревато трудноуловимыми ошибками
- низкий уровень абстракции: работа с любым сложным типов данных ничем не отличается от работы с числами, что конечно будет создавать много трудностей

Примеры:
- **типизированные языки**: C, Python, Scala, PHP, Lua, C#, Java и т.д.
- **нетипизированные языки**: Assembler, Forth, Brainfuck и т.д.‌

Бестиповая типизация по своей сути очень проста и дальше она ни на какие другие виды не делится. А вот типизированные языки разделяются еще на несколько категорий:
- статическая и динамическая типизация
- сильная (строгая) и слабая (нестрогая) типизация
- явная и неявная типизация

### Статическая и динамическая типизация

В языках программирования со статической типизацией проверка типов начинается на стадии компиляции. Компиляторы ищут ошибки еще до запуска программы, то есть компилятор на 100% уверен, какой тип где находится. Благодаря этому статически типизированные языки программирования зачастую быстрее. Кроме того, тип для переменной можно назначить только один раз. Например, в C# такая запись вызовет ошибку на этапе компиляции:
```C#
iint data = 17;
data = "Hello";
```
В свою очередь, языки программирования с динамической типизацией ищут ошибки на стадии выполнения. В них можно задать разные типы для одной и той же переменной, и они более гибкие. Например, в Python возможна такая запись и ошибок не будет:
```python
data‌ ‌=‌ ‌17
data‌ ‌=‌ ‌'Hello'
```
Примеры:
- **статическая типизация**: C, Java, C#, Kotlin, Scala, GO и т.д.
- **динамическая типизация**: Python, JavaScript, Ruby, Julia и т.д.

Преимущества статической типизации:
- проверки типов происходят только один раз - на этапе компиляции
- скорость выполнения
- ускорение разработки при поддержке IDE(отсеивание вариантов, заведомо не подходящих по типу)

Преимущества динамической типизации:
- простота создания универсальных коллекций
- удобство описания обобщенных алгоритмов (например сортировка списка, которая будет работать не только со списком целых чисел, но и со списком вещественных и даже списком строк)
- легкость в освоении - языки с динамической типизацией обычно очень хороши для того, чтобы начать программировать

### Сильная и слабая типизация

В слабо типизированных языках программирования можно смешивать разные типы данных. Так код получается короче - язык "старается" сам выполнять операции преобразования с разными типами. Впрочем, в таком случае не всегда ясно, как поведет себя программа. Например, в JavaScript возможна такая запись:
```javascript
5‌‌ ‌‌+‌‌ ‌‌'6'‌;‌ ‌‌            //‌ ‌'56'‌ ‌
4‌‌ ‌‌*‌‌ ‌‌'3'‌;‌ ‌‌            //‌ ‌12‌ ‌
2‌‌ ‌‌+‌‌ ‌‌true‌;‌‌            //‌ ‌3‌ ‌
false‌‌ ‌-‌ ‌‌4‌;‌‌           //‌ ‌-4‌
```
При сильной (строгой) типизации, как в Python, язык не позволяет смешивать разные типы - то есть если вы обозначили переменную как число, то добавить к ней строку уже не получится
```python
data = 'python'
new_data = data + 2022
```
приводит к возникновению исключения `TypeError`:
```no-highlight
TypeError: can only concatenate str (not "int") to str
```
Языки с сильной типизацией надежнее. Да и программист, прописывая все преобразования вручную, лучше понимает, как работает его код.
  
Примеры:
- **сильная типизация**: Java, Python, Haskell, Lisp и т.д.
- **слабая типизация**: C, JavaScript, Visual Basic, PHP и т.д.

Преимущества слабой типизации:
- удобство использования смешанных выражений
- абстрагирование от типизации и сосредоточение на задаче
- краткость записи

### Явная и неявная типизация

В языках программирования с явной типизацией типы переменных и возвращаемых значений функции нужно задавать явно. Это дольше, но так проще определять, что значит все данные, а программисту не придется запоминать отдельно тип каждой переменной. В языке `C#` переменную целого типа `int` нужно объявить так
```C#
int‌ ‌data = 17
```
При неявной типизации тип переменной определяется интерпретатором или компилятором, поэтому записи в таких языках короче. В языке Python переменную, содержащую целое число можно объявить так (язык сам определит, что это целое число)
```python
data = 17
```
Примеры:
- **явная типизация:** C++, D, C#, Java и т.д.
- **неявная типизация:** Python, PHP, Lua, JavaScript и т.д.

Преимущество явной типизации:
- наличие у каждой функции сигнатуры (например `int add(int, int)`) позволяет без проблем определить, что функция делает
- программист сразу записывает, какого типа значения могут храниться в конкретной переменной, что снимает необходимость запоминать это

Преимущества неявной типизации:
- сокращение записи: запись `def add(x, y)` короче, чем `int add(int x, int y)`
- устойчивость к изменениям: если в функции временная переменная была того же типа, что и входной аргумент, то в явно типизированном языке при изменении типа входного аргумента нужно будет изменить еще и тип временной переменной

![[Pasted image 20240617024014.png]]