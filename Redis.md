#Redis 

![[Pasted image 20250425104432.png]]
### Что такое Redis
**Redis**(Remote Dictionary Service) - это система управления базами данных в памяти (in-memory database). Это значит, что все данные хранятся в оперативной памяти, а не на **ПЗУ**, что делает **Redis** сверхбыстрым. Он может использоваться как кэш, очередь сообщений или даже база данных для хранения данных, которым нужно обеспечивать быстрый доступ.

Но что отличает **Redis** от других баз данных? В первую очередь - его скорость и гибкость. **Redis** поддерживает множество типов данных, таких как строки, списки, множества и даже упорядоченные множества, что позволяет решать широкий круг задач.
### Основные характеристики Redis
Пройдемся по основным характеристикам **Redis**, которые делают это систему удобной:
1. Скорость. **Redis** хранит данные в памяти, а не на диске, что делает его невероятно быстрым. Он способен обрабатывать миллионы операций в секунду.
2. Поддержка разных типов данных. **Redis** поддерживает строки, списки, множества, хеши и упорядоченные множества. Это дает гибкость при выборе структуры данных для приложения.
3. Персистентность данных. Это значит, что твои данные не исчезнут при сбое или перезапуске сервера - они сохранятся на диске и будут доступны после восстановления работы.
4. Простота в установку и настройке. **Redis** легко установить и настроить на различных платформах, а также интегрировать с популярными языками программирования, например, **Python**, **Node.js**, **Java** и другими.
### Разбираемся, как работает Redis
**Redis** хранит все данные в **ОЗУ**. Это позволяет обрабатывать запросы намного быстрее, чем традиционные базы данных, которые записывают информацию на жесткий диск.

Представь, что тебе нужно хранить часто используемые данные, например, сессии пользователей или результаты запросов. Если бы при каждом запросе приходилось обращаться к данным на жестком диске, это занимало бы много времени. Вместо этого можно сохранять информацию в **Redis** и получать к ней быстрый доступ. Именно поэтому **Redis** так популярен для кэширования и ускорения работы приложений.

**Redis** поддерживает разные типы данных - строки, списки, множества. Это делает его более гибким по сравнению с классическими базами данных и удобным для работы с динамическими данными. Но если данных слишком много, оперативной памяти может не хватить, поэтому **Redis** чаще используют для временных данных, которые быстро обновляются
### Типы данных Redis
1. Строки(**Strings**) - это самый простой и часто используемые тип данных в **Redis**. Можно хранить текстовые или бинарные данные - например, **JSON**, изображения или сериализованные объекты. Пример: токены доступа к **API** или кэширование **HTML**-страниц
2. Списки(**Lists**) - упорядоченные наборы строк, которые можно дополнять как слева, так и справа. Например, список последних действий пользователя в приложении, например, история сообщений в чате.
3. Множества(**Sets**) - неупорядоченные уникальные значения. Быстрые операции объединения, пересечения и разности. Пример: уникальные теги, присвоенные статьями на сайте.
4. Отсортированные множества (**Sorted Sets**). Похожи на множества, но каждое значение связано с числовым приоритетом (**store**), по которому и сортируются. Пример: хранение рейтинга пользователей в игровом приложении.
5. Хэш-таблицы (**Hashes**) - это структуры, похожие на объекты или ассоциативные массивы, которые идеально подходят для хранения связанных данных. К примеру, хранение профиля пользователя с ключами `имя`, `email`, `дата регистрации`.
6. **Bitmaps** и **HyperLogLog**. Они нужны для работы с большими данными. Например, если тебе надо посчитать уникальных посетителей сайта за месяц без хранения огромных списков
### Как пользоваться **Redis**?
**Redis** отлично подходит для решения задач, связанных с быстрым доступом к данным. Он может использоваться как кэш, очередь сообщений или даже как полноценная база данных. Вот несколько распространенных сценариев:
1. Кэширование данных. **Redis** помогает создавать кэш - временное хранилище для часто запрашиваемых данных. Вместо того чтобы каждый раз обращаться к медленной **БД**, ты можешь хранить результаты запросов в **Redis** и получать их за доли секунды. Данные кэша хранятся в виде пар `ключ-значение`, и их можно быстро получить, не обращаясь к дисковой памяти. Представь, что у тебя есть онлайн-магазин, и пользователей постоянно смотрят одни и те же товары. Сохранив информацию о них в **Redis**, ты сможешь быстрее ее показывать и разгрузить сервер.
2. Сессии пользователей. Многие веб-приложения хранят информацию о сессиях пользователей в **Redis**, потому что это надежно и быстро. В качестве примера разберем авторизацию на сайте. Когда пользователь заходит в учетную запись, его данные сессии записываются в **Redis**. Это позволяет быстро проверять аутентификацию при каждом запросе, не обращаясь к основной базе данных.
3. Очереди сообщений. **Redis** позволяет организовывать очереди сообщений благодаря списками и механизму `подписка/публикация`(`pub/sub`). В системе уведомлений, когда нужно отправить пуши сразу тысячам пользователей, сообщения ставятся в очередь **Redis** и отправляются по мере обработки.
4. Аналитика и мониторинг. **Redis** используется для подсчета метрик в реальном времени благодаря спискам. Представь игровое приложение, которое показывает количество игроков онлайн. Каждый раз, когда кто-то подключается или выходит, **Redis** мгновенно обновляет счетчик.
5. Таблица лидеров (**Leaderboard**). С помощью сортированных множеств (`sorted sets`) в **Redis** можно создавать лидерборды. Представь, что у тебя есть игра, в которой нужно показывать таблицу лидеров - топ 10 игроков с самыми высокими очками. В игре каждому элементу присваивается свое значение. **Redis** с его сортировочным наборами (**sorted sets**) позволяет мгновенно обновлять и показывать такую таблице при каждом изменении очков у игроков.
6. Работа с временными данными. **Redis** отлично справляется с данными, которые часто меняются, например. с подсчетом лайков или просмотров. В таких случаях пары ключ-значение позволяют быстро обновлять информацию и показывать актуальные данные.
### Базовые операции
В консоли для общения с **Redis** используется клиентская программа `redis-cli`. Рассмотрим базовые операции.

**Задача 1**. Создание, выборка, модификация, удаление, и базовая информация об объектах.

Установить и прочитать значения с ключами вида `test:1:*`. Узнать тип значения, проверить существование элемента, извлечь все поля записи `test:1`, удалить поле записи `test:1`
```console
redis 127.0.0.1:6379> set test:1:string "my binary safe string"OK                                                             redis 127.0.0.1:6379> get test:1:string                        "my binary safe string"redis 127.0.0.1:6379> getset test:1:string "other value" "my binary safe string"                                                                          redis 127.0.0.1:6379> type test:1:string                       string                                                         redis 127.0.0.1:6379> set test:1:vlaue "487"                   OK                                                             redis 127.0.0.1:6379> rename test:1:vlaue test:1:value         OK                                                             redis 127.0.0.1:6379> exists  test:1:vlaue                     (integer) 0                                                    redis 127.0.0.1:6379> exists test:1:value                      (integer) 1                                                    redis 127.0.0.1:6379> keys test:1:*                            1) "test:1:string"                                             2) "test:1:value"                                              redis 127.0.0.1:6379> del test:1:value(integer) 1                        redis 127.0.0.1:6379> keys test:1:*1) "test:1:string"                 
```

**Задача 2**. Время жизни объекта.
```
redis 127.0.0.1:6379> ttl test:1:string
(integer) -1
redis 127.0.0.1:6379> expire test:1:string 6000
(integer) 1
redis 127.0.0.1:6379> ttl test:1:string
(integer) 5997
```
По умолчанию объект не ограничен временем жизни, поэтому `TTL` возвращает -1, после установки значения командой `EXPIRE` команда `TTL` уже возвращает оставшееся количество секунд.

**Задача 3**. pipelining, выполнение нескольких команд одним запросом.
```
PS D:\Programs\Redis\64bit> "set test:1:pvalue 'test'`r`nget test:1:pvalue" | .\redis-cli
OK                                                                                       "test"                                                                              
```
Pipelining удобно использовать для оптимизации массовых вставок.

**Задача 4,** транзакции.  
Для реализации транзакций в Redis используются следующие основные команды:  
- `MULTI` — начать запись команд для транзакции.
- `EXEC` — выполнить записанные команды.
- `DISCARD` — удалить все записанные команды.
- `WATCH` — команда, обеспечивающая поведение типа «check-and-set» (CAS) — транзакция выполняется только в случае, если другие клиенты не изменили значение переменной. Иначе `EXEC` не выполнит записанные команды.

```
redis 127.0.0.1:6379> multi                 
OK                                          
redis 127.0.0.1:6379> set test:1:trValue "1"
QUEUED                                      
redis 127.0.0.1:6379> incr test:1:trValue   
QUEUED                                      
redis 127.0.0.1:6379> decr test:1:trValue   
QUEUED                                      
redis 127.0.0.1:6379> exec                 
1) OK                                       
2) (integer) 2                              
3) (integer) 1            
```

**Задача 5,** продемонстрировать основные строковые операции.
```
redis 127.0.0.1:6379> set test:1:string "hello"            
OK                                                         
redis 127.0.0.1:6379> append test:1:string " world!"       
(integer) 12                                               
redis 127.0.0.1:6379> get test:1:string                    
"hello world!"                                             
redis 127.0.0.1:6379> strlen test:1:string                 
(integer) 12                                               
redis 127.0.0.1:6379> getrange test:1:string 6 10          
"world"                                                    
redis 127.0.0.1:6379> setrange test:1:string 6 "habrahabr!"
(integer) 16                                               
redis 127.0.0.1:6379> get test:1:string                    
"hello habrahabr!"          
```

**Задача 6,** продемонстрировать операции над числами.
```
redis 127.0.0.1:6379> set test:1:int 1    
OK                                        
redis 127.0.0.1:6379> incr test:1:int     
(integer) 2                               
redis 127.0.0.1:6379> decr test:1:int     
(integer) 1                               
redis 127.0.0.1:6379> incrby test:1:int 20
(integer) 21                              
redis 127.0.0.1:6379> decrby test:1:int 15
(integer) 6                   
```

**Задача 7,** создать список, продемонстрировать основные операции над списками.
```
redis 127.0.0.1:6379> rpush test:1:messages "Hello, world!"
(integer) 1                                                
redis 127.0.0.1:6379> rpush test:1:messages "Hello, user!" 
(integer) 2                                                
redis 127.0.0.1:6379> rpush test:1:messages "Wow!"         
(integer) 3                                                
redis 127.0.0.1:6379> lrange test:1:messages 0 2
1) "Hello, world!"                              
2) "Hello, user!"                               
3) "Wow!"               
redis 127.0.0.1:6379> llen test:1:messages     
(integer) 3                                    
redis 127.0.0.1:6379> lpop test:1:messages     
"Hello, world!"                                
redis 127.0.0.1:6379> lpop test:1:messages     
"Hello, user!"                                 
redis 127.0.0.1:6379> lpop test:1:messages     
"Wow!"                                         
redis 127.0.0.1:6379> llen test:1:messages     
(integer) 0                        
```