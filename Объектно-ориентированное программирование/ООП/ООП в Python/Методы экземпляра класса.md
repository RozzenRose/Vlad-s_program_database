#OOP #ООП #Python #класс


Если атрибуты отображают некоторые характеристики, которые свойственны объектам определенного класса, то методы определяют их поведение. В `Python` существует несколько типов методов, но в этой статье мы сосредоточимся только на методах ___экземпляра класса___. Метод экземпляра - это функция, которая определена внутри класса, принадлежит объекту этого класса и имеет доступ к атрибутам объекта

Как правило, названия методов экземпляра являются глаголами и соответствуют соглашению ___Snake case___

Рассмотрим пустой класс `Cat`, определим внутри него методы экземпляра `say()` и `eat()` и попробуем применить их к конкретному объекту
```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```
```
Мяу
Мням
```

Стоит обратить внимание, что за исключением того, что эти определения методов появляются в классе, они похожи на любое другое определение функции в `Python`. Они начинаются со строки заголовка, после которой идет выделенный отступом блок кода. Также следует заметить, что каждый метод имеет параметр `self`

Параметр `self` требуется в каждом методе экземпляра. Метод оперирует атрибутами конкретного объекта, и когда метод исполняется, он должен знать, атрибутами какого объекта он должен оперировать. Именно здесь на первый план выходит параметр `self`. Когда метод вызывается, `Python` делает так, что параметр `self` ссылается на конкретный объект, который его вызвал в данный момент и которым вызванный метод должен оперировать

Параметр `self` часто называют ___контекстным объектом___

Иными словами, привычные вызовы методов, через точечную нотацию:
```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```
Python преобразует в следующее:
```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

Cat.say(cat)
Cat.eat(cat)
```
поэтому оба приведенных выше кода являются эквивалентными и выводят:
```python
Мяу
Мням
```

Методы экземпляра доступны всем экземплярам соответствующего класса, поэтому мы можем создать несколько объектов класса `Cat`, и все они будут иметь общий функционал
```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat1 = Cat()
cat2 = Cat()

cat1.say()
cat2.eat()
```
```
​Мяу
Мням
```
Важно отметить, что параметр `self` - это обычная переменная, она может называться по-другому, но так категорически не рекомендуется делать. Соглашение об имени контекстного объекта - самое строгое их всех соглашений в мире `Python`. Если нарушить это соглашение, другие программисты просто не будут понимать ваш код. Кроме того, некоторые текстовые редакторы подсвечивают слово `self` определенным цветом, что довольно удобно

Таким образом, при создании собственных методов экземпляра  следует помнить о двух моментах:
- метод должен быть определен внутри класса (добавляется уровень отступов)
- метод всегда должен иметь хотя бы один параметр, и первый по счету параметр должен называться `self`

В примере выше методы `say()` и `eat()`, помимо экземпляра класса, не принимали никаких аргументов. Однако методы являются функциями, поэтому мы без проблем можем расширить их функционал, например, добавив дополнительный параметр
```python
class Cat:
    def say(self, sound):
        print(sound)

    def eat(self, meal):
        print(f'{meal} - это очень вкусно!')


cat1 = Cat()
cat2 = Cat()

cat1.say('Мяу')
cat1.eat('Молоко')

cat2.say('Мяяяу!')
cat2.eat('Рыба')
```
```
Мяу
Молоко - это очень вкусно!
Мяяяу!
Рыба - это очень вкусно!
```


### Метод `__init__()`
Рассмотрим следующее определение класса `Cat`:
```python
class Cat:
	pass
```
После создания экземпляра класса мы получаем объект, у которого нет никаких атрибутов. И если нам требуется, чтобы объект ими обладал, нам приходится определять их вручную для каждого объекта, либо определять атрибуты на уровне класса. Очевидно, оба способа имеют свои недостатки, так как в первом случае нам приходится определять каждый атрибут для каждого объекта, во втором случае - все экземпляры класса имеют атрибуты с одними и теми же значениями, что не всегда нужно. Решить данную проблему позволяет специальный метод `__init__()`

Метод `__init__()` называют **методом инициализации** или **инициализатором**.

Метод `__init__()` инициализирует атрибуты объекта. Сразу после создания объекта исполняется метод `__init__()`, и параметру `self` автоматически присваивается объект, который был только что создан, что позволяет тут же наделить его необходимым атрибутами
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed                       # порода кошки
        self.name = name                         # имя кошки


cat = Cat('Devon Rex', 'Nefret')
```
создает экземпляр класса `Cat`, который имеет атрибуты `breed` и `name` со значениями `Devon Rex` и `Nefret` соответственно
![[Pasted image 20240807184035.png]]
Важно уточнить, что метод `__init__()`  исполняется после создания каждого экземпляра класса `Cat`, поэтому каждый объект будет иметь те значения атрибутов, которые были указаны при его создании
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat1 = Cat('Devon Rex', 'Nefret')
cat2 = Cat('Sphinx', 'Ben')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```
```
Devon Rex Nefret
Sphinx Ben
```
Поскольку мы определили параметры `breed` и `name` для метода `__init__()`, они должны быть явно переданы при создании новых экземпляров класса `Cat`:
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat()
```
```
TypeError: Cat.__init__() missing 2 required positional arguments: 'breed' and 'name'
```
Однако если мы хотим, чтобы при создании объекта значения некоторых атрибутов можно было не указывать, мы можем установить их значения по умолчанию
```python
class Cat:
    def __init__(self, breed, name=None):
        self.breed = breed
        self.name = name


cat1 = Cat('Devon Rex', 'Nefret')
cat2 = Cat('Sphinx', 'Ben')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
```
```
Devon Rex Nefret
Sphinx Ben
```
Сигнатура метода `__init__()` полностью повторяет сигнатуру любой функции. С помощью `*args` и `**kwargs` метод `__init__()` может принимать произвольное количество позиционных и именованных аргументов соответственно

Помимо значений аргументов, передаваемых в инициализатор, атрибутам можно устанавливать некоторые фиксированные значения
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name
        self.night_vision = True                 # способность видеть в темноте


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat('Манчкин', 'Роджер')

print(cat1.night_vision)
print(cat2.night_vision)
```
```
True
True
```
 Можно подумать, что метод `__init__()` отвечает за создание экземпляров класса, но это не так, он принимает в качестве аргумента уже созданный классом объект и инициализирует его.
 
 Класс может иметь только один инициализатор. При попытке определить в классе два инициализатора, предыдущий будет заменен следующим.
 ```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name


cat = Cat('Devon Rex', 'Nefret')

print(cat.breed)
print(cat.name)
```
```
Devon Rex
Nefret
```

Применение метода к объекту преобразуется в вызов функции, путем обращения к ней через соответствующий класс и передачи ей в качестве аргумента объекта, который этот метод вызвал.
```python
nums = [1, 2, 3]
text = 'beegeek'

nums.append(4)
text = text.lower()
```
Эквивалентен коду:
```python
nums = [1, 2, 3]
text = 'beegeek'

list.append(nums, 4)
text = str.lower(text)
```
Это достаточно удобно использовать, если нам требуется воспользоваться методом как функцией.
```python
names = ['timur', 'arthur', 'dima']

print(*map(str.title, names))
```
```
Timur Arthur Dima
```