#OOP #ООП #Python 


По хорошему доступ к атрибутам объекта должны иметь только методы этого объекта. Такой подход защищает атрибуты от случайного повреждения.

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов `protected` (защищенный), `private` (приватный) и `public` (публичный):
- доступ к защищенным атрибутам возможен только внутри этого класса, а также внутри унаследованных от него классов
- приватные атрибуты недоступны извне — с ними можно работать только внутри этого класса
- публичные атрибуты доступны для работы снаружи

С точки зрения разграничения доступа атрибутам `Python` является особым языком - в нем отсутствуют механизм, который мог бы запретить внешнему коду взаимодействовать с атрибутами объекта или класса. Вместо этого создатели `Python` предложили следующий ряд соглашений:
- если имя атрибута начинается с одного нижнего подчеркивания (`_name`), то он считается **защищенным**
- если имя атрибута начинается с двух нижних подчеркиваний (`__name`), то он считается **приватным**

В `Python` все атрибуты являются публичными по умолчанию. Любой атрибут объекта может быть доступен за пределами класса, независимо от того, является он публичным, защищенным или приватным
```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)
```
```
Кемаль
Роджер
```
Как мы видим, никаких проблем не возникает ни при обращении к атрибутам, ни при их изменении. Аналогичное поведение наблюдается и с защищенными атрибутами, то есть атрибутами, имя которых начинается с одного символа нижнего подчеркивания.
```python
class Cat:
    def __init__(self, name):
        self._name = name


cat = Cat('Кемаль')
print(cat._name)

cat._name = 'Роджер'
print(cat._name)
```
```
Кемаль
Роджер
```
Иными словами, это больше вопрос ответственности программиста = он не должен работать за пределами класса с атрибутами, имена которых начинаются с нижнего подчеркивания

Несколько иначе себя ведут приватные атрибуты, если мы предварим имя атрибута двумя нижними подчеркиваниями, то есть сделаем его приватным, то код за пределами класса не сможет получить к нему доступ напрямую
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__name)
```
```
AttributeError: 'Cat' object has no attribute '__name'
```
На первый взгляд может показаться, что атрибута для внешнего кода действительно не существует, однако если мы посмотрим на содержимое словаря атрибутов, то увидим, что на самом деле приватный атрибут лишь получил другое имя
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__dict__)
```
```
{'_Cat__name': 'Кемаль'}
```

Любой атрибут вида `__name` текстуально заменяется на `_class__name`, где `class` — это имя текущего класса.

Таким образом, возможность обратиться к приватному атрибуту, а также изменить его значение все же остается.
```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat._Cat__name = 'Роджер'

print(cat.__dict__)
```
```
{'_Cat__name': 'Роджер'}
```