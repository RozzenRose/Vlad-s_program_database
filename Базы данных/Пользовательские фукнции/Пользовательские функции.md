#база_данных #реляционные #SQL #СУБД 

- [[Условная конструкция IF-ELSEIF-ELSE]]
- [[Цикл WHILE]]
##### База данных для примеров
Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Math`, которая содержит информацию об оценках студентов за итоговый экзамен по математике:
```
+----+--------+----------+-------+
| id | name   | surname  | grade |
+----+--------+----------+-------+
| 1  | Flash  | Thompson | 2     |
| 2  | Peter  | Parker   | 5     |
| 3  | Mary   | Jane     | 2     |
| 4  | Gwen   | Stacy    | 4     |
| 5  | Harry  | Osborn   | 5     |
| 6  | Ben    | Reilly   | 1     |
| 7  | Miles  | Morales  | 5     |
| 8  | John   | Jameson  | 1     |
| 9  | Curtis | Connors  | 4     |
| 10 | Edward | Brock    | 3     |
+----+--------+----------+-------+
```
Первое поле этой таблицы содержит идентификатор студента, второе — имя, третье — фамилию, четвертое — оценку по пятибалльной шкале.

### Пользовательские функции
В **SQL** реализовано множество полезных функций, с помощью которых можно выполнять практически любые манипуляции с данными: переводить числа из одной системы счисления в другую, объединять несколько строковых значений, получать отдельные компоненты даты и времени, и так далее. Однако на этом возможности **SQL** не заканчиваются, поскольку язык позволяет создавать свои функции и самостоятельно определять их логику.

Функции, которые не являются встроенными, а определены пользователем, называются **пользовательскими**

Пользовательские функции могут быть применимы для решения разных задач. Например, если внутри какого-либо запроса приходится выполнять объемные математические вычисления, то будет целесообразно определить собственную функцию и выполнять их внутри нее, поскольку подобное решение приведет к визуальному упрощению исходного запроса.

В зависимости от поведения, пользовательские функции делятся на два вида: **детерминированные** и **недетерминированные**. Если функция при одних и тех же входных данных возвращает один и тот же результат, ее называют детерминированной. Если же при одних и тех же входных данных функцию может вернуть разные результаты, ее называют недетерминированной.

Примером детерминированной пользовательской функции может являться функция, которая выполняет сложение двух чисел, недетерминированной - функция, которая возводит число в случайную степень.
### Создание пользовательских функций
Общий шаблон для создания пользовательской функции имеет следующий вид:
```sql
DELIMITER //
CREATE FUNCTION <имя функции>(<имя 1 параметра и его тип>, <имя 2 параметра и его тип>, ...)
RETURNS <тип возвращаемого значения>
<вид функции: детерминированная или недетерминированная>
BEGIN
    <тело функции>;
    RETURN <возвращаемое значение>;
END //
DELIMITER ;
```
Несложно заметить, что создание пользовательской функции похоже на создание триггера, поскольку начинается с того же ключевого слова `DELIMETER`, с помощью которого выполняется изменение разделителя на двойной слеш (`//`). Далее следует оператор `CREATE FUNCTION`,  после которого указывается имя функции. Затем в скобках через запятую выполняется определение каждого **параметра функции**, которое включает его имя и тип данных.

Практически каждая функция работает с определенными значениями, которые передаются ей при вызове. Для того чтобы внутри функции обращаться к этим значениями, используются обычные переменные, которые и называют параметрами.

Например, если часть, определяющая параметры функции, выглядит следующим образом:
```css
(x INT, y INT)
```
то это говорит о том, что функция принимает два целочисленных аргумента, первый их которых внутри функции доступен по имени `x`, второй - по имени `y`

Типы данных, указанные рядом с параметрами функции, необязательно должны совпадать с типами фактических значений, которые будут переданы в функцию, но должны быть совместимы.

После определения имени функции и всех ее параметров следует ключевое слово `RETURNS`, за которым указывается тип возвращаемого функцией значения. Затем определяется вид функции: детерминированная или недетерминированная. Если функция является детерминированной, указывается ключевое слово `DETERMINISTIC`, если недетерминированной - `NOT DETERMINISTIC`.

Если используется пара ключевых слов `NOT DETERMINISTIC`, обязательно нужно пояснить, почему функция является недетерминированной. Если функция работает с информацией, хранящейся в таблицах базы данных, после `NOT DETERMINISTIC` с новой строки необходимо добавить `READS SQL DATA`. Если функция не обращается к таблицам базы данных, но при этом выполняется вычисления со случайным результатом, после `NOT DETERMINISTIC` с новой строки необходимо добавить `NO SQL`.
```SQL
NOT DETERMINISTIC
READS SQL DATA
```
то это говорит о том, что функция является недетерминированной, потому что работает с информацией, хранящейся в таблицах базы данных, которая всегда может измениться.

Внутрь последующего блока `BEGIN END` помещается тело функции, которое и определяет ее поведение. Тело функции может включать вычисления на основе переданных аргументов, определения вспомогательных переменных, а также обращения к таблицам базы данных. Следом за телом функции внутри блока `BEGIN END` располагаются оператор `RETURN` и возвращаемое значение функции. Следует заметить, что возвращаемое функцией значение должно быть одиночным, а также иметь тип данных, совместимый с тем, что был указан после ключевого слова `RETURNS`. Завершается создание функции обновленным разделителем `//` и возвратом к стандартному разделителю в виде символа `;`.

### Примеры использования пользовательских функций
Для лучшего понимания синтаксиса создания пользовательских функций рассмотрим несколько примеров. Обратим внимание на функции, которые выполняют различные вычисления с числами, строками, датами, а также на те функции, что дополнительно обращаются к таблицам базы данных.
#### Числовые пользовательские функции
**Пример 1.** Создадим пользовательскую функцию `IS_EVEN()` для определения того, является ли число четным. Функция будет принимать в качестве аргумента целое число и возвращать число `1`, если оно является четным, или `0` в противном случае.
```sql
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN IF(number MOD 2 = 0, 1, 0);
END //
DELIMITER ;

SELECT IS_EVEN(10),
       IS_EVEN(15);
```
```
+-------------+-------------+
| IS_EVEN(10) | IS_EVEN(15) |
+-------------+-------------+
| 1           | 0           |
+-------------+-------------+
```
Итак, в данном примере создается пользовательская функция с именем `IS_EVEN`. Как видно из определения, она принимает в качестве аргумента одно целочисленное значение, для обращения к которому внутри функции используется имя `number`. Тип возвращаемого значения функции также является целочисленным. Внутри тела функции переданное значение делится с остатком на `2`, и если остаток от деления равен нулю, функция возвращает единицу, характеризуя значение как четное, в противном случае функция возвращает ноль.

Завершается пример вызовом функции `IS_EVEN()` с четным и нечетным аргументами. Для первого аргумента, как и положено, функция возвращает единицу, для второго — ноль.

**Пример 2.** Создадим пользовательскую функцию `VECTOR_ABS()` для вычисления [модуля вектора](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80_\(%D0%B3%D0%B5%D0%BE%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%8F\)#%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B0:~:text=%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D1%82%D1%8C%20%D0%BA%D0%BE%D0%B4%5D-,%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%20%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B0,-%5B%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D1%82%D1%8C%20%7C). Функция будет принимать в качестве аргументов целочисленные координаты вектора по осям xx и yy и возвращать его модуль.
```sql
DELIMITER //
CREATE FUNCTION VECTOR_ABS(x INT, y INT)
RETURNS FLOAT
DETERMINISTIC
BEGIN
    RETURN SQRT(POW(x, 2) + POW(y, 2));
END //
DELIMITER ;

SELECT VECTOR_ABS(3, 4),
       VECTOR_ABS(6, 8);
```
```
+------------------+------------------+
| VECTOR_ABS(3, 4) | VECTOR_ABS(6, 8) |
+------------------+------------------+
| 5.0              | 10.0             |
+------------------+------------------+
```

### Строковые пользовательские функции
**Пример.** Создадим пользовательскую функцию `CAPITALIZE()` для записи строки с заглавной буквы. Функция будет принимать в качестве аргумента строку, переводить ее первый символ в верхний регистр, а все остальные — в нижний, и возвращать полученный результат.
```sql
DELIMITER //
CREATE FUNCTION CAPITALIZE(string TEXT)
RETURNS TEXT
DETERMINISTIC
BEGIN
    RETURN CONCAT(UPPER(LEFT(string, 1)), LOWER(SUBSTRING(string, 2)));
END //
DELIMITER ;

SELECT CAPITALIZE('beegeek'),
       CAPITALIZE('BeeGeek'),
       CAPITALIZE('BEEGEEK');
```
```
+-----------------------+-----------------------+-----------------------+
| CAPITALIZE('beegeek') | CAPITALIZE('BeeGeek') | CAPITALIZE('BEEGEEK') |
+-----------------------+-----------------------+-----------------------+
| Beegeek               | Beegeek               | Beegeek               |
+-----------------------+-----------------------+-----------------------+
```

### Пользовательские функции для работы с датой
**Пример.** Создадим пользовательскую функцию `NEXT_DAY()` для получения следующего дня. Функция будет принимать в качестве аргумента дату, прибавлять к ней `1` день и возвращать полученный результат.
```sql
DELIMITER //
CREATE FUNCTION NEXT_DAY(day DATE)
RETURNS DATE
DETERMINISTIC
BEGIN
    RETURN day + INTERVAL 1 DAY;
END //
DELIMITER ;

SELECT NEXT_DAY('2023-10-10'),
       NEXT_DAY('2023-12-31');
```
```
+------------------------+------------------------+
| NEXT_DAY('2023-10-10') | NEXT_DAY('2023-12-31') |
+------------------------+------------------------+
| 2023-10-11             | 2024-01-01             |
+------------------------+------------------------+
```

### Пользовательские функции с использованием запросов
**Пример.** Создадим пользовательскую функцию `STUDENTS_WITH_GRADE()` для определения количества студентов в таблице `Math`, имеющих определенную оценку. Функция будет принимать в качестве аргумента оценку по пятибалльной шкале, вычислять количество студентов, оценка которых совпадает с переданной, и возвращать полученный результат.
```sql
DELIMITER //
CREATE FUNCTION STUDENTS_WITH_GRADE(score INT)
RETURNS INT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    RETURN (SELECT COUNT(*)
            FROM Math
            WHERE grade = score);
END //
DELIMITER ;

SELECT STUDENTS_WITH_GRADE(4),
       STUDENTS_WITH_GRADE(5);
```
```
+------------------------+------------------------+
| STUDENTS_WITH_GRADE(4) | STUDENTS_WITH_GRADE(5) |
+------------------------+------------------------+
| 2                      | 3                      |
+------------------------+------------------------+
```
Функция `STUDENTS_WITH_GRADE()` отличается от всех предыдущих тем, что ее возвращаемое значение определяется путем выполнения запроса, который обращается к таблице `Math` и определяет, сколько в ней записей удовлетворяют определенному условию. Обратите внимание, что если возвращаемое значение функции вычисляется с помощью запроса, то он должен быть заключен в круглые скобки, а его результатом должно быть одиночное значение (одна запись и одно поле).

Отдельного комментария требуют параметры функции, которые используются внутри запроса. Несмотря на то что параметры не предваряются символом `@`, конфликтов имен не происходит. Например, в нашем случае параметр `score` СУБД воспринимает исключительно как параметр, а не как имя поля.

Если параметр и поле имеют одно и то же имя, то при обращении по этому имени внутри запроса обращение будет выполнено к параметру, а не к полю. Для явного обращения к полю достаточно использовать его полное имя.

### Локальные переменные внутри пользовательских функций
Если тело пользовательской функции достаточно непростое и включает несколько этапов, то для хранения результатов промежуточных вычислений можно использовать дополнительно определенные **локальные переменные**. Поведение локальных переменных несколько похоже на поведение пользовательских переменных, поскольку значения им присваиваются с помощью той же связки операторов `SET` и `:=`. Однако локальные переменные имеют важную особенность: перед тем, как им присвоить значение, их необходимо определить.

Определение локальной переменной внутри функций выполняется с помощью оператора `DECLARE`, синтаксис использования которого имеет следующий вид:
```css
DECLARE <имя переменной> <тип данных значения, хранимого в переменной>;
```

Например, создание целочисленной локальной переменной с именем `variable` внутри функции выполняется следующим образом:
```css
DECLARE variable INT;
```

В качестве примера использования локальных переменных рассмотрим функцию `MIN_MAX_GRADE()`, которая определяет минимальную и максимальную оценку среди всех студентов в таблице `Math` и возвращает полученный результат в виде строки в следующем формате:
```
Lowest grade: <минимальная оценка>, Highest grade: <максимальная оценка>
```

```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);
    RETURN CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```
```
+-----------------------------------+
| MIN_MAX_GRADE()                   |
+-----------------------------------+
| Lowest grade: 1, Highest grade: 5 |
+-----------------------------------+
```
В теле функции `MIN_MAX_GRADE()` используются две локальные переменные `min_grade` и `max_grade`, первая из которых используется для хранения минимальной оценки среди всех студентов, вторая — максимальной.

Обратите внимание, в отличие от пользовательских переменных, которые доступны в рамках всей сессии, локальные переменные доступны только в рамках функции, в которой они объявлены.

Объявление локальных переменных должно осуществляться раньше любых других операций в блоке `BEGIN END`. Другими словами, сначала необходимо объявить все переменные, а только потом выполнять вычисления, в противном случае произойдет ошибка.
```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);

    DECLARE result TEXT;
    SET result := CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);

    RETURN result;
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```
```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DECLARE result TEXT; SET result := CONCAT('Lowest grade: ', min_grade, ', H' at line 13
```
Если мы перенесем определение переменной `result` в начало блока `BEGIN END`, то запрос отработает без ошибок.
```sql
DELIMITER //
CREATE FUNCTION MIN_MAX_GRADE()
RETURNS TEXT
NOT DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE min_grade INT;
    DECLARE max_grade INT;
    DECLARE result TEXT;

    SET min_grade := (SELECT MIN(grade)
                      FROM Math);
    SET max_grade := (SELECT MAX(grade)
                      FROM Math);

    SET result := CONCAT('Lowest grade: ', min_grade, ', Highest grade: ', max_grade);

    RETURN result;
END //
DELIMITER ;

SELECT MIN_MAX_GRADE();
```
```
+-----------------------------------+
| MIN_MAX_GRADE()                   |
+-----------------------------------+
| Lowest grade: 3, Highest grade: 5 |
+-----------------------------------+
```

## Примечания
**Примечание 1.** Функции, создаваемые с помощью оператора `CREATE FUNCTION`, являются **скалярными**, то есть всегда возвращают единственное значение.

**Примечание 2.** При определении локальной переменной для нее можно указать значение по умолчанию, которое переменная примет сразу же после определения. Для этого после типа данных переменной необходимо указать ключевое слово `DEFAULT` и предоставить желаемое значение.

Например, создание целочисленной локальной переменной с именем `variable` и значением `0` выполняется следующим образом:
```sql
DECLARE variable INT DEFAULT 0
```

**Примечание 3.** Пользовательскую функцию можно дополнить строкой документации, которая полезна тем, что позволяет программисту сразу понять, что именно делает функция, не вдаваясь в подробности ее реализации. Для этого перед блоком `BEGIN END` необходимо указать ключевое слово `COMMENT`, а затем предоставить строку, содержащую краткое описание поведения функции.

Например, рассмотренная ранее функция `VECTOR_ABS()` может быть расширена кратким описанием следующим образом:
```sql
DELIMITER //
CREATE FUNCTION VECTOR_ABS(x INT, y INT)
RETURNS FLOAT
DETERMINISTIC
COMMENT 'Функция возвращает модуль двумерного вектора'
BEGIN
    RETURN SQRT(POW(x, 2) + POW(y, 2));
END //
DELIMITER ;

SELECT VECTOR_ABS(3, 4),
       VECTOR_ABS(6, 8);
```

**Примечание 4.** Пользовательская функция может быть удалена после создания. Для этого нужно воспользоваться оператором `DROP FUNCTION`, а затем указать имя удаляемой функции.

Например, запрос, который удаляет пользовательскую функцию `IS_EVEN()`, выглядит следующим образом:
```sql
DROP FUNCTION IS_EVEN;
```

**Примечание 5.** Пользовательские функции нечувствительны к регистру, поэтому, например, функцию с именем `IS_EVEN` можно вызвать как с использованием имени `IS_EVEN`, так и `is_EVEN` или `is_even`.
```scss
DELIMITER //
CREATE FUNCTION IS_EVEN(number INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN IF(number MOD 2 = 0, 1, 0);
END //
DELIMITER ;

SELECT IS_EVEN(10),
       is_EVEN(15),
       is_even(26);
```
```
+-------------+-------------+-------------+
| IS_EVEN(10) | is_EVEN(15) | is_even(26) |
+-------------+-------------+-------------+
| 1           | 0           | 1           |
+-------------+-------------+-------------+
```