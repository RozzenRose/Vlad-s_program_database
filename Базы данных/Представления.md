#база_данных #реляционные #SQL #СУБД

##### База данных для примеров
**Первая таблица.** Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:
```
+----+---------+-----------+
| id | name    | surname   |
+----+---------+-----------+
| 1  | Stephen | King      |
| 2  | Chuck   | Palahniuk |
| 3  | Jerome  | Salinger  |
| 4  | Leo     | Tolstoy   |
+----+---------+-----------+
```
Первое поле этой таблицы содержит идентификатор автора, второе — имя, третье — фамилию.

**Вторая таблица.** Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:
```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
| 6  | The Outsider           | 2018         | 1         |
| 7  | Lullaby                | 2002         | 2         |
| 8  | Franny and Zooey       | 1961         | 3         |
| 9  | Invisible Monsters     | 1999         | 2         |
| 10 | Dolores Claiborne      | 1993         | 1         |
+----+------------------------+--------------+-----------+
```
Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — год выпуска, четвертое — идентификатор автора.
### Представления
**Представление** - это виртуальная таблица. В отличие от обычных таблиц, содержащих данные, представление содержит запрос, который динамически извлекает данные тогда, когда это необходимо. Представления можно использовать точно так же, как и обычный таблицы: извлекать данные из них, фильтровать и сортировать, объединять с другими таблицами или представлениями.

Представления не содержат фактических данных, они извлекают их из других таблиц. Поэтому, если данные этих таблиц изменяется, изменится и содержимое связанных с ними представлений.
### Создание представлений
Для создания представлений используется оператор `CREATE VIEW`, синтаксис которого имеет следующий вид:
```sql
CREATE VIEW <имя представления> AS
<извлекающий запрос>
```
Несложно заметить, что создание  представления выполняется достаточно просто. Фактически от нас требуется лишь написать запрос, который определенным образом извлекает из таблицы базы данных нужную информацию, а также дать этому запросу имя.

Представления, как и таблицы, должны иметь уникальные имена. Они не могут быть названы так же, как другие таблицы или представления

В качестве примера напишем запрос, создающий представление `FirstBooks`, которое включает информацию о первых трех книгах
```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

SELECT *
FROM FirstBooks;
```
```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
+----+------------------------+--------------+-----------+
```
Запрос выше начинается с создания представления, которому дается имя `FirstBooks`, затем указывается содержимое этого представления - три первые записи таблицы `Books`. Завершается запрос извлечением всей информации, находящейся в представлении `FirstBooks`

Несмотря на то, что представление в контексте запросе ведет себя как обычная таблица, оно на самом деле таковым не является.

Если в базе данных содержится некоторое представление, то при попытке создать представление с таким же именем произойдет ошибка.  Чтобы ее избежать, можно воспользоваться расширенным оператором `CREATE OR REPLACE VIEW`. Данный оператор создаст представление только в том случае, если оно еще не существует. Если же представление с создаваемым именем существует, оно будет заменено новым:
```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

CREATE OR REPLACE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```
```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```
В данном примере сначала создается представление `FirstBooks`, которое включает три первые записи таблицы `Books`. Затем создается представление с тем же именем, которое включает пять первых записей таблицы `Books`.  Второе создание представления `FirstBooks` выполняется с помощью оператора `CREATE OR REPLACE VIEW`, поэтому оно приводит не к ошибке, а к тому, что новое представление заменяет старое.
### Представления для упрощения запросов
Представления удобно использовать в том случае, когда из базы данных постоянно нужно извлекать одни и те же данные. Предположим, нам чаще всего приходится работать с информацией о книгах автора `Stephen King`. Это может быть получение названия самой поздней книги писателя или названий всех его книг в порядке их выпуска.

Очевидно, что все такие запросы будут иметь один общий фрагмент, в котором из таблицы `Books` извлекаются данные о книгах автора `Stephen King`:
```sql
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and Authors.surname = 'King';
```
С помощью оператора `CREATE VIEW` мы можем преобразовать его в представление, скажем, с именем `StephenKingBooks`, чтобы в дальнейшем, вместо этого не самого маленького запроса, использовать одно говорящее имя.

```sql
CREATE VIEW StephenKingBooks AS
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and surname = 'King';

SELECT *
FROM StephenKingBooks
ORDER BY release_year;
```
```
+-------------------+--------------+
| title             | release_year |
+-------------------+--------------+
| The Shining       | 1977         |
| Dolores Claiborne | 1993         |
| The Green Mile    | 1996         |
| The Outsider      | 2018         |
+-------------------+--------------+
```
В примере выше извлекается информация о всех книгах автора `Stephen King` с дополнительной сортировкой по дате выхода, однако не напрямую из таблицы `Books`, а из представления `StephenKingBooks`, которое как раз и содержит все необходимые данные.
### Представления для форматирования данных
Представления могут быть полезны при частой необходимости извлекать данные в определенном формате. Например. в таблице `Books` информация об авторах книг не хранится в явном виде - указываются лишь их идентификаторы. Однако нам нередко может требоваться таблица, которая содержит как названия книг, так и их авторов. Для этого мы можем создать соответствующее представление и пользоваться им при необходимости получить данные в требуемом формате.
```sql
CREATE VIEW BooksInfo AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname) AS author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```
```
+------------------------+-----------------+
| title                  | author          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```
Запрос выше создает представление `BooksInfo`, которое объединяет содержимое таблиц `Books` и `Authors`, беря из первой таблицы название книги, а из второй - информацию об авторе этой книги
### Изменение представлений
Запрос, который используется в представлении, может быть изменен. Для этого используется оператор `ALTER VIEW`, синтаксис которого имеет следующий вид:
```sql
ALTER VIEW <имя представления> AS
<новый извлекающий запрос>
```
В качестве примера использования данного оператора напишем запрос, создающий представление `FirstBooks`, которое включает три первые записи таблицы `Books`, а затем изменяющий созданное представление таким образом, чтобы оно включало пять первых записей.
```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

ALTER VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```
```
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```
### Удаление представлений
Представление может быть удалено. Для этого используется оператор `DROP VIEW`, синтаксис которого имеет следующий вид:
```sql
DROP VIEW <имя представления>
```
Предположим, в нашей базе данных содержится представление `FirstBooks` и мы хотим его удалить. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:
```sql
DROP VIEW FirstBooks;
```
При попытке удалить несуществующее представление произойдет ошибка. Если после оператор `DROP VIEW` указать ключевые слова `IF EXISTS`, удаление будет выполнено только в том случае, если представление существует.
### Примечания
**Примечание 1** Определить названия полей виртуальной таблицы можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имеет в скобках через запятую после названия представления:
```sql
CREATE VIEW BooksInfo (bookname, writer) AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname)
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```
```
+------------------------+-----------------+
| bookname               | writer          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```

**Примечание 2** Представления могут быть вложенным. Это означает, что представление может быть создано посредством запроса, который извлекает данные из другого представления

**Примечание 3** Представления предназначены для извлечения данных, а не изменения, поэтому в большинстве случаев они являются неизменяемыми. и при попытке применить к представлениям операторы `INSERT`, `UPDATE` или `DELTE` произойдет ошибка. Однако  если представление извлекает данные из единственной таблицы, причем извлекает их полностью, то такое представление изменить можно. Но важно понимать, что само представление не содержит никаких данных, поэтому все изменения будут применены к той таблице, с которой связано представление.

**Примечание 4** С помощью представлений можно ограничивать доступ к данным, предоставляя пользователю  или приложения права не на таблицу, а на представление. Также представления могут использоваться для обеспечения интерфейса обратной совместимости: если структура таблицы, с которой работало приложение, изменилась, с помощью представления можно смоделировать ее прежний вид

**Примечание 5** Несмотря на то, что операторы `ALTER VIEW` и `CREATE OR REPLACE VIEW` похожи, между ними есть важное отличие. Оператор `ALTER VIEW` изменяет существующее представление и завершается ошибкой, если оно не существует. Оператор `CREATE OR REPLACE VIEW` создает новое представление, удаляя старое, если оно существует.