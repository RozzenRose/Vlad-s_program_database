#база_данных #реляционные #SQL #СУБД #подзапросы 
#### Таблицы для примеров
##### Первая таблица
Информация о размещенных в библиотеке книгах хранится в таблице `Books`:
```
+----+------------------------------------------+-----------------+
| id | title                                    | author          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```
##### Вторая таблица
Информация о пользователях библиотеки располагается в таблице `Users`:
```
+----+---------+-------------+
| id | name    | surname     |
+----+---------+-------------+
| 1  | Keanu   | Reeves      |
| 2  | Matthew | McConaughey |
| 3  | Thomas  | Hanks       |
+----+---------+-------------+
```
##### Третья таблица
Информация об аренде книг, то есть о том, какой пользователь какую книгу взял почитать, располагается в таблице `BooksRental`
```
+----+---------+---------+
| id | book_id | user_id |
+----+---------+---------+
| 1  | 5       | 1       |
| 2  | 1       | 3       |
| 3  | 2       | 3       |
| 4  | 4       | 2       |
| 5  | 4       | 1       |
+----+---------+---------+
```
Первое поле этой таблицы содержит идентификатор аренды, второе - идентификатор арендованной книги, третье - идентификатор пользователя, арендовавшего книгу.
##### Скрипты для создания
```sql
DROP TABLE IF EXISTS BooksRental;
DROP TABLE IF EXISTS Users;
DROP TABLE IF EXISTS Books;

-- Создание таблицы Books
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('Fight Club', 'Chuck Palahniuk'),
       ('The Green Mile', 'Stephen King'),
       ('The Lord of the Rings', 'J.R.R. Tolkien'),
       ('It', 'Stephen King'),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling');

-- Создание таблицы Users
CREATE TABLE Users
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(30),
    surname VARCHAR(30)
);

INSERT INTO Users (name, surname)
VALUES ('Keanu', 'Reeves'),
       ('Matthew', 'McConaughey'),
       ('Thomas', 'Hanks');

-- Создание таблицы BooksRental
CREATE TABLE BooksRental
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    book_id INT,
    user_id INT
);

INSERT INTO BooksRental (book_id, user_id)
VALUES (5, 1),
       (1, 3),
       (2, 3),
       (4, 2),
       (4, 1);
```
### Подзапросы для работы с несколькими таблицами
Предположим, что нам необходимо извлечь данные о том, сколько пользователей взяли почитать книгу под названием `It`. Нужная нам информация содержится в таблице `BooksRental`, однако получить ее сразу мы не можем, поскольку нам неизвестен идентификатор искомой книги. Поэтому сперва нам необходимо обратиться к таблице `Books` и определить идентификатор книги под названием `It`, а затем, используя полученный идентификатор, извлечь из таблицы `BooksRental` все записи, связанные с нужной книгой, и посчитать их количество
```sql
SELECT COUNT(*) AS num_of_users
FROM BooksRental
WHERE book_id = (SELECT id
                 FROM Books
                 WHERE title = 'It');
```
```
+--------------+
| num_of_users |
+--------------+
| 2            |
+--------------+
```
Здесь подзапрос сначала извлекает из таблицы `Books` идентификатор книги под названием `It`:
```
+----+
| id |
+----+
| 4  |
+----+
```
Затем основной запрос извлекает из таблицы `BooksRental` те записи, значение поля `book_id` которых равняется идентификатору, полученному подзапросом (`4`), и выполняет их подсчет.

Фактически запрос выше эквивалентен следующему запросу:
```sql
SELECT COUNT(*) AS num_of_users
FROM BooksRental
WHERE book_id = 4;
```
Работа с несколькими таблицами практически не отличается от работы с одной таблицей. Разница заключается лишь в том, что для извлечения нужной информации из таблицы необходимо пользоваться данными не из этой же таблицы, а из других.

---
Рассмотрим более сложную задачу. Представим, что нам необходимо извлечь данные о пользователях, которые взяли почитать книгу под названием `It`. Как и в прошлом случае, начать следует с определения идентификатора искомой книги. Затем, используя полученный идентификатор книги, необходимо узнать идентификаторы пользователей, которые арендовали данную книгу. После определения идентификаторов необходимых нам пользователей остается лишь получить всю требуемую информацию о них
```sql
SELECT name, surname
FROM Users
WHERE id IN (SELECT user_id                           -- второй подзапрос
             FROM BooksRental
             WHERE book_id = (SELECT id               -- первый подзапрос
                              FROM Books
                              WHERE title = 'It'));
```
```
+---------+-------------+
| name    | surname     |
+---------+-------------+
| Keanu   | Reeves      |
| Matthew | McConaughey |
+---------+-------------+
```
В данном примере сначала первый подзапрос извлекает из таблицы `Books` идентификатор книги под названием `It`:
```
+----+
| id |
+----+
| 4  |
+----+
```
После этого второй подзапрос извлекает из таблицы `BooksRental` поле `user_id`, при этом оставляя только те записи, значение поля `book_id` которых равняется полученному предыдущим подзапросом идентификатору (`4`):
```
+---------+
| user_id |
+---------+
| 2       |
| 1       |
+---------+
```
Наконец основной запрос извлекает из таблицы `Users` те записи, значение поля `id` которых содержится в полученной вторым подзапросом таблице, то есть равняется `2` или `1`.

Фактически запрос выше эквивалентен следующему запросу:
```sql
SELECT name, surname
FROM Users
WHERE id IN (2, 1);
```
Некоррелированные подзапросы, если их несколько, всегда обрабатываются начиная с самого вложенного, то есть в направлении изнутри наружу.

---
В качестве заключительного примера извлечем данные о пользователях и о количестве книг, арендованных каждым из них. Данные о пользователях мы можем получить из таблицы `Users`, данные об арендованных книгах — из таблицы `BooksRental`. Поэтому, по сути, нам требуется лишь извлекать все записи из таблицы `Users` и при извлечении каждой записи дополнительно обращаться к таблице `BooksRental`.
```sql
SELECT name, surname,
      (SELECT COUNT(*)
       FROM BooksRental
       WHERE user_id = Users.id) AS num_of_books
FROM Users;
```
```
+---------+-------------+--------------+
| name    | surname     | num_of_books |
+---------+-------------+--------------+
| Keanu   | Reeves      | 2            |
| Matthew | McConaughey | 1            |
| Thomas  | Hanks       | 2            |
+---------+-------------+--------------+
```
Подзапрос в данном примере отличается от предыдущих тем, что он является коррелированным, а также тем, что он используется в качестве вычисляемого поля. Поскольку запрос коррелированный, он выполняется для каждой извлекаемой основным запросом записи отдельно.

Например, если основной запрос извлекает следующую запись:
```
+---------+---------+-------------+
| 2       | Matthew | McConaughey |
+---------+---------+-------------+
```
то в подзапросе значение `Users.id` на данный момент равняется `2`, и выполнение подзапроса происходит с учетом именно этого значения, вследствие чего подзапросом возвращается количество записей в таблице `BooksRental`, значение поля `user_id` которых равняется `2`:
```
+----------+
| COUNT(*) |
+----------+
| 1        |
+----------+
```
Далее это значение присваивается извлекаемой основным запросом записи в качестве его значения поля `num_of_books`. Аналогичный алгоритм выполняется для всех остальных записей, извлекаемых основным запросом, для определения их значений поля `num_of_books`.