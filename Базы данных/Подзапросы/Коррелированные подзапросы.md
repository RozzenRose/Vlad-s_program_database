#база_данных #реляционные #SQL #СУБД #подзапросы 


#### Таблица для примеров 
```
+----+------------------------------------------+---------------------+--------------+------------+
| id | title                                    | author              | critic_score | user_score |
+----+------------------------------------------+---------------------+--------------+------------+
| 1  | The Shining                              | Stephen King        | 39           | 51         |
| 2  | Fight Club                               | Chuck Palahniuk     | 99           | 99         |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 99           | 89         |
| 4  | The Green Mile                           | Stephen King        | 73           | 84         |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 87           | 87         |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 39           | 51         |
| 7  | It                                       | Stephen King        | 39           | 75         |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 90           | 64         |
| 9  | Haunted                                  | Chuck Palahniuk     | 52           | 59         |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 66           | 89         |
+----+------------------------------------------+---------------------+--------------+------------+
```
### Коррелированные подзапросы
Предположим, нам требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше.

Схематически необходимый запрос мы можем показать следующим образом:
```sql
SELECT title, user_score
FROM Books
WHERE <user_score> <оценка предыдущей книги>;
```
Проблема данной задачи заключается в том, что для ее решения нам необходимо, чтобы для каждой записи справа от знака `>` располагалось соответствующее именно ей значение (оценка книги с идентификатором на один меньше), а не какое-либо фиксированное значение.

Реализовать это можно с помощью **коррелированного** подзапроса. Он используется в том случае, когда для каждой записи, анализируемой основным запросом, подзапрос должен вернуть результат, зависящий от значений в этой записи. Иными словами, коррелированный подзапрос отвечает на вопрос, ответ на который зависит от обрабатываемой основным запросом записи.

С применением коррелированного подзапроса мы можем показать необходимый нам запрос более точно, однако по-прежнему схематически:
```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books
                    WHERE <поле id внутренней таблицы> = <поле id внешней таблицы> - 1);
```
Проблема, возникающая на данном этапе проектирования запроса, связана с именованием полей. Поскольку коррелированный подзапрос, помимо значений полей собственной таблицы, использует значения полей таблицы, принадлежащей основному запросу, должна быть возможность различать эти поля, если они имеют одинаковые названия.

Для этого при обращении к полю явно указывают название таблицы, например, `Books.id` (поле `id` таблицы `Books`). Если и основной запрос, и подзапрос обращаются к одной и той же таблице, то одной из таблиц дают псевдоним.
```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```
```no-highlight
+------------------------------------------+------------+
| title                                    | user_score |
+------------------------------------------+------------+
| Fight Club                               | 99         |
| The Great Gatsby                         | 87         |
| It                                       | 75         |
| Harry Potter and the Prisoner of Azkaban | 89         |
+------------------------------------------+------------+
```
Итак, основной запрос здесь извлекает записи из таблицы `Books`, а также фильтрует их с помощью подзапроса. Значение подзапроса не вычисляется единожды, а определяется для каждой рассматриваемой основным запросом записи отдельно, поскольку оно напрямую зависит от этой записи.

Например, если основной запрос рассматривает следующую запись:
```no-highlight
+----+------+---------------------+--------------+------------+
| 7  | It   | Stephen King        | 39           | 75         |
+----+------+---------------------+--------------+------------+
```
то в подзапросе значение `Books.id` на данный момент равняется `7` и выполнение подзапроса происходит с учетом именно этого значения, вследствие чего подзапросом возвращается таблица, содержащая значение поля `user_score` той записи, значение поля `id` которой равняется `7 - 1 = 6`:
```no-highlight
+------------+
| user_score |
+------------+
| 51         |
+------------+
```
Далее в основном запросе выполняется сравнение значения поля `user_score` рассматриваемой записи со значением, которое вернул подзапрос для этой записи: `75 > 51`. Так как результатом этого сравнения является истина, рассматриваемая запись попадает в результирующую таблицу.

Таким образом, коррелированный подзапрос выполняется для каждой записи отдельно (сперва для первой, затем для второй и так далее) и для каждой записи возвращает результат, полученный на основе ее значений.