#база_данных #реляционные #SQL #СУБД #подзапросы
#### Таблица для примеров
```
+----+------------------------------------------+---------------------+-------+
| id | title                                    | author              | price |
+----+------------------------------------------+---------------------+-------+
| 1  | The Shining                              | Stephen King        | 7.99  |
| 2  | Fight Club                               | Chuck Palahniuk     | 9.99  |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| 4  | The Green Mile                           | Stephen King        | 15.99 |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| 7  | It                                       | Stephen King        | 12.99 |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| 9  | Haunted                                  | Chuck Palahniuk     | 13.99 |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+----+------------------------------------------+---------------------+-------+
```
```MySQL
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author    VARCHAR(30),
    price     DECIMAL(10, 2)
);

INSERT INTO Books (title, author, price)
VALUES ('The Shining', 'Stephen King', 7.99),
       ('Fight Club', 'Chuck Palahniuk', 9.99),
       ('The Catcher in the Rye', 'J.D. Salinger', 3.49),
       ('The Green Mile', 'Stephen King', 15.99),
       ('The Great Gatsby', 'F. Scott Fitzgerald', 7.99),
       ('The Lord of the Rings', 'J.R.R. Tolkien', 19.99),
       ('It', 'Stephen King', 12.99),
       ('The Silmarillion', 'J.R.R. Tolkien', 11.99),
       ('Haunted', 'Chuck Palahniuk', 13.99),
       ('Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling', 9.99);
```

### Подзапросы
**Подзапрос** - это запрос, вложенный в другой запрос. Подзапрос всегда заключен в круглые скобки и обычно выполняется перед основным запросом. Подзапросы являются обычными запросами, и для них не предусмотрен какой-либо отдельный синтаксис, поэтому для составления подзапросов достаточно уметь составлять обычные запросы
### Подзапросы с одним полем и одной записью
Извлечем данные о книгах, чья стоимость превышает среднюю стоимость всех книг:
```MySQL
SELECT *
FROM Books
WHERE price > (SELECT AVG(price)
               FROM Books);
```
```
+----+-----------------------+-----------------+-------+
| id | title                 | author          | price |
+----+-----------------------+-----------------+-------+
| 4  | The Green Mile        | Stephen King    | 15.99 |
| 6  | The Lord of the Rings | J.R.R. Tolkien  | 19.99 |
| 7  | It                    | Stephen King    | 12.99 |
| 8  | The Silmarillion      | J.R.R. Tolkien  | 11.99 |
| 9  | Haunted               | Chuck Palahniuk | 13.99 |
+----+-----------------------+-----------------+-------+
```
Здесь в условии фильтрации значение поля `price` сравнивается с результатом подзапроса. Подзапрос обращается к таблице `Books` и вычисляет среднее арифметическое всех значений ее поля `price`. Таблица, получаемая в результате подзапроса, состоит из одной записи и одного поля, то есть содержит единственное значение, с которым и происходит последующее сравнение значения поля `price`

Сравнение значения поля `price` с таблицей возможно именно по той причине, что эта таблица содержит лишь одно значение, и **СУБД** использует это значение для выполнения операции сравнения. Если бы таблица содержала более одного значения, такая операция была бы невозможна
```MySQL
SELECT *
FROM Books
WHERE price > (SELECT price
               FROM Books);
```
```
ERROR 1242: Subquery returns more than 1 row
```

Подзапросы могут использоваться не только для фильтрации записей, но и для фильтрации групп. Таким примером может быть запрос, извлекающий данные об авторах, средняя стоимость книг которых превышает среднюю стоимость всех книг
```MySQL
SELECT author, AVG(price) AS avg_price
FROM Books
GROUP BY author
HAVING AVG(price) > (SELECT AVG(price)
                     FROM Books);
```
```
+-----------------+--------------------+
| author          | avg_price          |
+-----------------+--------------------+
| Stephen King    | 12.323333104451498 |
| Chuck Palahniuk | 11.989999771118164 |
| J.R.R. Tolkien  | 15.989999771118164 |
+-----------------+--------------------+
```
Здесь записи сперва группируются по полю `author`, а затем фильтруются. Для фильтрации используется подзапрос, который, как и выше, обращается к таблице `Books` и вычисляет среднее арифметическое всех значений ее поля `price`. Группа попадает в результирующую таблицу, если среднее значение ее поля `price` больше среднего значения поля `price` всей таблицы, в противном случае группа отбрасывается

Подзапросы при фильтрации позволяют вычислять различные значения на основе данных из всей таблицы (минимум, максимум, среднее значение) и использовать их в условиях фильтрации.
### Подзапросы с одним полем и несколькими записями
Как было сказано выше, сравнение **одиночного значения** с **таблицей** возможно только в том случае, если эта таблица состоит из одного **поля** и одной **записи**, то есть содержит **единственное значение**. однако с помощью ключевых слов [[ALL]] и [[ANY]] можно выполнять сравнение с таблицей, содержащей одно поле и произвольное количество записей, то есть сравнивать одиночное значение с набором значений
### Запрос из запроса
Мы можем запрашивать из подзапроса
```sql
SELECT *
FROM (SELECT title, author, price
      FROM Books) AS BooksCopy;
```
```
+------------------------------------------+---------------------+-------+
| title                                    | author              | price |
+------------------------------------------+---------------------+-------+
| The Shining                              | Stephen King        | 7.99  |
| Fight Club                               | Chuck Palahniuk     | 9.99  |
| The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| The Green Mile                           | Stephen King        | 15.99 |
| The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| It                                       | Stephen King        | 12.99 |
| The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| Haunted                                  | Chuck Palahniuk     | 13.99 |
| Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+------------------------------------------+---------------------+-------+
```

 Если результатом подзапроса является таблица с единственным значением, то это значение может быть извлечено с помощью оператора `SELECT`, например, как обычное число.
```sql
SELECT (SELECT SUM(price)
        FROM Books) AS total;
```
```
+--------------------+
| total              |
+--------------------+
| 114.39999794960022 |
+--------------------+
```

### Корреляция запросов
Подзапросы, рассмотренные в этой статье независимы. То есть все они могут выполняться автономного от основного запроса, и перед тем как их результат будет использоваться в основном запросе, мы могли посмотреть, что они возвращают. Такие подзапросы называются **Некоррелированными**

Несмотря на то что некоррелированный подзапрос  является достаточно мощным инструментом, он может справляться  не с любой задачей. Предположим, нам требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше. Для решения таких задач используются [[Коррелированные подзапросы]]

### [[Подзапросы с несколькими полями]]