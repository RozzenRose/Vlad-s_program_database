#база_данных #реляционные #SQL #СУБД 

##### Используемая в примерах таблица
Таблица `Books`:
```
+----+------------------------------------------+-----------------+
| id | title                                    | author          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```
Скрипт для создания:
```
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk'),
       (2, 'The Green Mile', 'Stephen King'),
       (3, 'The Lord of the Rings', 'J.R.R. Tolkien'),
       (4, 'It', 'Stephen King'),
       (5, 'Harry Potter and the Prisoner of Azkaban', 'J.K. Rowling');
```
### Удаление таблиц
Посредством запроса можно удалить не только содержимое таблицы, но и саму таблице. Удаление таблицы - очень простой процесс, для выполнения которого всего лишь нужно воспользоваться оператором `DROP TABLE`, а затем указать имя удаляемой таблицы.

Например, запрос, который удаляет таблицу `Books`, выглядит следующим образом:
``` sql
DROP TABLE Books;
```

Если требуется удалить несколько таблиц одновременно, достаточно после оператора `DROP TABLE` перечислить через запятую их имена

Оператор `DROP TABLE` удаляет таблицу только в том случае, если она содержится в базе данных, в противном случае оператор завершает операцию удаления с ошибкой. Однако если воспользоваться дополнительным оператором `IF EXISTS`, таблица будет удалена только в том случае, если она существует, в противном случае операция удаления будет проигнорирована.

Например, запрос, который удаляет таблицу `Books` с дополнительной проверкой существования таблицы, выглядит следующим образом:
``` sql
DROP TABLE IF EXISTS Books;
```
Во время удаления таблицы необходимо помнить о том, что она может иметь связи с другими таблицами. Если от удаляемой таблицы зависят другие таблицы, то при попытке ее удалить произойдет ошибка
### Переименование таблицы
Переименование таблицы является таким же легким процессом, как и ее удаление. Для его выполнения необходимо воспользоваться оператором `RENAME TABLE`, синтаксис которого имеет следующий вид:
``` sql
REBAME TABLE <текушее имя таблицы> TO <новое имя таблицы>
```
Например, запрос, который изменяет имя таблицы `Books` на `OldBooks`, выглядит следующим образом:
``` sql
RENAME TABLE Books TO OldBooks;
```
### Обновление таблицы
После создания таблицы ее определение можно обновить. Несмотря на то что **SQL** позволяет достаточно гибко модифицировать структуру уже созданной таблицы, злоупотреблять данной возможностью не рекомендуется. При разработке таблиц следует анализировать будущие потребности, чтобы позже не пришлось существенно менять структуру таблиц. В идеале структура таблицы вообще не должна меняться после того, как в нее были добавлены данные

Любой запрос, модифицирующий таблицы, начинается с оператора `ALTER TABLE`, после которого указывается имя таблицы, подлежащей модификации. После имени таблицы указывается действие (с использованием соответствующего оператора), которое должно быть применено по отношению к этой таблице.
#### Удаление поля
Удаление поля таблицы выполняется с помощью оператора `DROP COLUMN`. В качестве примера его использования, напишем запрос, который удаляет из таблицы `Books` поле `author`

После выполнения приведенного ниже запроса:
```sql
ALTER TABLE Books
DROP COLUMN author;
```
таблица `Books` будет иметь вид:
```
+----+------------------------------------------+
| id | title                                    |
+----+------------------------------------------+
| 1  | Fight Club                               |
| 2  | The Green Mile                           |
| 3  | The Lord of the Rings                    |
| 4  | It                                       |
| 5  | Harry Potter and the Prisoner of Azkaban |
+----+------------------------------------------+
```
#### Переименование поля
Переименование поля таблицы синтаксически похоже на переименование самой таблицы и выполняется с помощью оператора `RENAME COLUMN`. В качестве примера его использования напишем запрос, который изменяет название поля `author` таблицы `Books` на `writer`
```sql
ALTER TABLE Books
RENAME COLUMN author TO writer;
```
```
+----+------------------------------------------+-----------------+
| id | title                                    | writer          |
+----+------------------------------------------+-----------------+
| 1  | Fight Club                               | Chuck Palahniuk |
| 2  | The Green Mile                           | Stephen King    |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| 4  | It                                       | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+----+------------------------------------------+-----------------+
```
#### Добавление поля
При желании таблицу можно расширить, добавив ей новое поле. Для этого необходимо воспользоваться оператором `ADD COLUMN`, а затем предоставить определение нового поля таблицы.

В качестве примера использования оператора `ADD COLUMN` напишем запрос, который добавляет в таблице `Books` целочисленное поле `release_year` - год выпуска книги
```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0);
```
```
+----+------------------------------------------+-----------------+--------------+
| id | title                                    | author          | release_year |
+----+------------------------------------------+-----------------+--------------+
| 1  | Fight Club                               | Chuck Palahniuk | NULL         |
| 2  | The Green Mile                           | Stephen King    | NULL         |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  | NULL         |
| 4  | It                                       | Stephen King    | NULL         |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    | NULL         |
+----+------------------------------------------+-----------------+--------------+
```

По умолчанию оператор `ADD COLUMN` добавляет новое поле в конце таблицы, однако это поведение можно изменить. Например, если после определения поля указать ключевое слова `FIRST`, новое поле будет добавлено в начало таблицы
```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0) FIRST;
```
```
+--------------+----+------------------------------------------+-----------------+
| release_year | id | title                                    | author          |
+--------------+----+------------------------------------------+-----------------+
| NULL         | 1  | Fight Club                               | Chuck Palahniuk |
| NULL         | 2  | The Green Mile                           | Stephen King    |
| NULL         | 3  | The Lord of the Rings                    | J.R.R. Tolkien  |
| NULL         | 4  | It                                       | Stephen King    |
| NULL         | 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    |
+--------------+----+------------------------------------------+-----------------+
```

Также новое поле можно поместить в конкретную часть таблицы - после заданного поля. Для этого нужно указать ключевое слово `AFTER`, а затем предоставить название поля, после которого должно быть расположено новое поле
```sql
ALTER TABLE Books
ADD COLUMN release_year INT CHECK (release_year > 0) AFTER title;
```
```
+----+------------------------------------------+--------------+-----------------+
| id | title                                    | release_year | author          |
+----+------------------------------------------+--------------+-----------------+
| 1  | Fight Club                               | NULL         | Chuck Palahniuk |
| 2  | The Green Mile                           | NULL         | Stephen King    |
| 3  | The Lord of the Rings                    | NULL         | J.R.R. Tolkien  |
| 4  | It                                       | NULL         | Stephen King    |
| 5  | Harry Potter and the Prisoner of Azkaban | NULL         | J.K. Rowling    |
+----+------------------------------------------+--------------+-----------------+
```
В примере выше по-прежнему добавляется  целочисленное поле `release_year`, однако его положение определяется явно - после поля `title`

Важно заметить, что если поле, которое использует ограничение `NOT NULL` и не имеет значения по умолчанию, добавляется в непустую таблице, то для такого поля автоматически выбрано значение по умолчанию. Например, для целочисленного типа таким значением является `0`, для строкового - пустая строка
```sql
ALTER TABLE Books
ADD COLUMN release_year INT NOT NULL;
```
```
+----+------------------------------------------+-----------------+--------------+
| id | title                                    | author          | release_year |
+----+------------------------------------------+-----------------+--------------+
| 1  | Fight Club                               | Chuck Palahniuk | 0            |
| 2  | The Green Mile                           | Stephen King    | 0            |
| 3  | The Lord of the Rings                    | J.R.R. Tolkien  | 0            |
| 4  | It                                       | Stephen King    | 0            |
| 5  | Harry Potter and the Prisoner of Azkaban | J.K. Rowling    | 0            |
+----+------------------------------------------+-----------------+--------------+
```

В данном примере вновь добавляется целочисленное поле `release_year`, однако уже с использованием ограничения `NOT NULL`. Таблица, в которую добавляется поле, имеет несколько записей, и все они должны что-то принять в качестве значения нового поля. Поскольку новое поле не поддерживает значение `NULL`, а значение по умолчанию не указано явно, все записи в качестве значения поля `release_year` принимают значение по умолчанию, выбранное автоматически, - число `0`

Если поле, которое используется ограничение `NOT NULL` и не имеет значения по умолчанию, добавляется в пустую таблице, то значение по умолчанию для такого поля автоматически выбрано не будет
#### Обновление поля
Поле существующей таблицы можно не только переименовать, но и полностью переопределить, то есть изменить его тип и набор ограничений. Для этого необходимо воспользоваться оператором `MODIFY COLUMN`, а затем предоставить новое определение желаемого поля.

Например, поле `title` нашей таблицы `Books` определено следующим образом:
``` sql
title VARCHAR(40)
```
Предположим, мы хотим изменить тип данного поля, оставив его равным `VARCHAR`, но увеличив количество допустимых символов с `40` до `60`, а также добавить ограничение `CHECK`. Тогда запрос, обновляющий поле `title` таблицы `Books` будет выглядеть следующим образом:
``` sql
ALTER TABLE Books
MODIFY COLUMN title VARCHAR(60) CHECK (title != '');
```

Следует уточнить, что оператор `MODIFY COLUMN` не расширяет текущее определение поля, а именно полностью его изменяет. Поэтому, если необходимо сохранить какие-либо имеющиеся свойства поля (например, значение по умолчанию), во время переопределения их нужно указать снова. Исключениями являются ограничения `PRIMARY KEY` и `UNIQUE` - они сохраняются даже в случае переопределения поля

Изменение типа поля может привести к изменению хранимых в нем данных. К примеру, изменение типа поля с `FLOAT` на `INT` приведет к тому, что числа в этом поле будут округлены до целых значений.

При необходимости задать полю значение по умолчанию переопределять его полностью нет необходимости, поскольку для данной операции предназначена специальная связка операторов `ALTER COLUMN` и `SET DEFAULT`, синтаксис которых имеет следующий вид:
```sql
ALTER COLUMN <название поля> SET DEFAULT <значение по умолчанию>
```

Например, запрос, задающий полю `title` таблицы `Books` в качестве значения по умолчанию строку `Unrirled`, выглядит следующим образом:
``` sql
ALTER TABLE Books
ALTER COLUMN title SET DEFAULT 'Untitled';
```

Воспользовавшись связкой операторов `ALTER COLUMN` и `DROP DEFAULT`, можно удалить значение по умолчанию, которым обладает поле. Если у поля нет значения по умолчанию, никаких ошибок не произойдет, операция будет просто проигнорирована

Например, запрос, удаляющей значение по умолчанию поля `title` таблицы `Books`, выглядит следующим образом:
```sql
ALTER TABLE Books
ALTER COLUMN title DROP DEFAULT;
```
#### Добавление и удаление первичного ключа
Первичный ключ таблицы может быть определен уже после того, как таблица была создана. Для этого необходимо воспользоваться оператором `ADD PRIMARY KEY`, а затем в скобках указать поле, которое должно стать первичным ключом. Если первичный ключа должен состоять из нескольких полей, их нужно перечислить через запятую

Например, наша таблица `Books` не имеет первичного ключа. Тогда запрос, определяющий поле `id` этой таблицы как первичный ключа, будет выглядеть следующим образом:
``` sql
ALTER TABLE Books
DROP PRIMARY KEY;
```
Если таблица имеет первичный ключ, то при попытке добавить ей другой первичный ключ произойдет ошибка. Поэтому, если требуется обновить первичный ключ таблицы, сначала следует избавиться от имеющегося.
#### Добавление удаление внешнего ключа
После создания таблицы можно определить не только первичный ключ, но и внешний. Для этого необходимо воспользоваться оператором `ADD FOREIGN KEY`, а затем привычным способом определить внешний ключ

Для рассмотрения примера определения внешнего ключа уже существующей таблицы, добавим в нашу базу данных дополнительную таблицу `Publishers`, которая хранит информацию о книжных издательствах. Она имеет следующий вид:
```
+-----------------------+----------------+-------------------------+
| name                  | country        | website                 |
+-----------------------+----------------+-------------------------+
| Allen & Unwin         | United Kingdom | allenandunwin.com       |
| Bloomsbury Publishing | United Kingdom | bloomsbury.com          |
| New American Library  | United States  | penguin.com             |
| Viking Press          | United States  | penguin.com             |
| W.W.Norton & Company  | United States  | wnorton.com             |
+-----------------------+----------------+-------------------------+
```
Первое поле таблицы `Publishers` содержит название издательства, второе - страну издательства, третье — официальный сайт издательства.

Предположим, мы хотим добавить в таблицу `Books` новое поле `publisher`, а затем сделать это поле внешним ключом, которое будет ссылаться на поле `name` таблицы `Publishers`. Тогда запрос, выполняющий это, будет выглядеть следующим образом:
```sql
ALTER TABLE Books
ADD COLUMN publisher VARCHAR(40);

ALTER TABLE Books
ADD FOREIGN KEY (publisher) REFERENCES Publishers (name);
```
Конечно, определение внешнего ключа можно было выполнить и во время добавления поля в таблицу, однако данный пример используется именно для демонстрации работы оператора `ADD FOREIGN KEY`.

Внешний ключ может быть как добавлен, так и удален. Удаление выполняется даже проще, чем добавление, для этого всего лишь необходимо воспользоваться оператором `DROP FOREIGN KEY`, а затем указать имя внешнего ключа, которое необходимо удалить.

Например, если после добавления в нашу таблицу `Books` поля `publisher` в качестве внешнего ключа мы хотим это поле преобразовать из внешнего ключа в обычное поле, то выполнить это можно следующим образом:
```sql
ALTER TABLE Books
DROP FOREIGN KEY publisher;
```
#### Добавление и удаление дополнительной проверки
Ограничение `CHECK`, как и значение по умолчанию, может быть добавлено отдельно и не требует полного переопределения поля. Для того чтобы добавить ограничение `CHECK`, нужно воспользоваться оператором `ADD CHECK`, а затем в скобках указать проверяющее выражение.

Например, наша таблица `Books` не имеет ни одного ограничения `CHECK`. Если мы хотим добавить ей одно ограничение `CHECK`, которое проверяет, что значение поля `title` не является пустой строкой, то выполнить это можно следующим образом:
```sql
ALTER TABLE Books
ADD CHECK (title != '');
```

При добавлении ограничения `CHECK` стоит учитывать, что, если в таблице уже содержатся данные, не соответствующие ограничению, операция добавления ограничения приведет к ошибке.

При необходимости добавить в таблицу именованное ограничение `CHECK` можно воспользоваться оператором `ADD CONSTRAINT`, синтаксис которого имеет следующий вид:
```css
ADD CONSTRAINT <имя ограничения> CHECK (<проверяющее выражение>)
```

Например, мы можем добавить в таблицу `Books` предложенное выше ограничение `CHECK`, но при этом дополнительно назвав его `title_is_not_empty_string`. Запрос, выполняющий это, будет выглядеть следующим образом:
```sql
ALTER TABLE Books
ADD CONSTRAINT title_is_not_empty_string CHECK (title != '');
```

Ограничение `CHECK` может быть как добавлено, так и удалено. Удаление выполняется даже проще, чем добавление, для этого всего лишь необходимо воспользоваться оператором `DROP CONSTRAINT`, а затем указать имя ограничения `CHECK`, которое требуется удалить.

Предположим, наша таблица `Books` имеет ограничение `CHECK` с именем `title_is_not_empty_string` и мы хотим удалить данное ограничение. Тогда запрос, выполняющий это, будет выглядеть следующим образом:
```sql
ALTER TABLE Books
DROP CONSTRAINT title_is_not_empty_string;
```