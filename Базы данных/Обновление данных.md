#база_данных #реляционные #SQL #СУБД #обновление_данных

##### Таблица для примеров
**Первая таблица.** Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:
```no-highlight
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```
**Вторая таблица.** Информация о размещенных в магазине книгах располагается в таблице `Books`, которая имеет следующий вид:
```no-highlight
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
![[Pasted image 20250120172214.png]]
```sql
-- Создание таблицы Authors
DROP TABLE IF EXISTS Authors;
CREATE TABLE Authors
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    author    VARCHAR(40)
);

INSERT INTO Authors (author)
VALUES ('Stephen King'),
       ('Chuck Palahniuk'),
       ('Jerome Salinger');

-- Создание таблицы Books
DROP TABLE IF EXISTS Books;
CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    price     DECIMAL(10, 2),
    amount    INT DEFAULT 0
);

INSERT INTO Books (title, author_id, price, amount)
VALUES ('The Shining', 1, 7.99, 1),
       ('Fight Club', 2, 9.99, 19),
       ('The Catcher in the Rye', 3, 3.49, 11),
       ('The Green Mile', 1, 15.99, 6),
       ('Haunted', 2, 13.99, 1);
```

### Обновление данных
Наиболее часто используемым оператором при формировании запросов является `select`. Однако помимо оператора `SELECT`, существуют еще три немаловажных оператора, которые предназначены для манипуляции содержащимися в таблицах данными: обновление, удаление и добавление. В этом уроке мы предназначены для манипуляции содержащимися содержащимися `UPDATE`, целью которого является обновление табличных данных
#### Обновление всех записей
Наиболее простой операцией обновления является изменение значения одного поля всех записей таблицы. В качестве примера такой операцией напишем запрос, который устанавливает всем книгам одинаковую цену в `9.99` долларов.
```sql
UPDATE Books
SET price = 9.99;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 11     |
| 4  | The Green Mile         | 1         | 9.99  | 6      |
| 5  | Haunted                | 2         | 9.99  | 1      |
+----+------------------------+-----------+-------+--------+
```
Теперь рассмотрим запрос выше несколько подробнее. Он начинается с оператора `UPDATE`, после которого указывается название таблицы, подлежащей обновлению. В нашем случае это таблица `Bools`. Затем используется ключевое слово `SET`, с помощью которого для поля определяется новое значение. В данном случае выполняется изменение значение поля `price` на значение `9.99`

В рамках одной операции обновления можно изменять значение не только одного поля, но и нескольких. Для этого после ключевого слова `SET` нужно перечислить через запятую все изменяемые поля и их новые значения. Например, дополнив запрос выше, мы можем изменить не только цену всех книг, но и их количество, скажем на значение `50`
```sql
UPDATE Books
SET price = 9.99,
    amount = 50;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 50     |
| 2  | Fight Club             | 2         | 9.99  | 50     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 50     |
| 4  | The Green Mile         | 1         | 9.99  | 50     |
| 5  | Haunted                | 2         | 9.99  | 50     |
+----+------------------------+-----------+-------+--------+
```
Если значение поля в какой-либо записи совпадает с обновляемым значением, оно не будет обновлено, Например, значение поля `price` в записи с идентификатором `2` уже имеет значение `9.99`, поэтому при выполнении запроса будет обновлено не пять, а четыре записи
#### Обновление отдельных записей
Изменение всех записей таблицы требуется довольно редко, гораздо чаще необходимо обновить значения нескольких определенных записей или одной конкретной записи. Выполняется это с помощью того же оператора `WHERE`, который указывается после ключевого слова `SET` и определяет условия отбора записей, подлежащих обновлению

В качестве примера использования оператора `WHERE` напишем запрос, который устанавливает всем книгам, доступным в единственном экземпляре, цену в `1.99` долларов
```sql
UPDATE Books
SET price = 1.99
WHERE amount = 1;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 1.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 1.99  | 1      |
+----+------------------------+-----------+-------+--------+
```
Как видно из обновленной таблицы `Books`, значение поля `price` изменили лишь те записи, значение поля `amount` которых равняется `1`, поскольку именно это условие было использовано при обновлении
#### Обновление с вычисляемым значением
В качестве нового значения поля допускается использовать не только константные значения, но и разного рода выражения. Примером использования подобных выражений может служить запрос, который устанавливает всем книгам скидку в `10%`
```sql
UPDATE Books
SET price = price * 0.9;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.19  | 1      |
| 2  | Fight Club             | 2         | 8.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.14  | 11     |
| 4  | The Green Mile         | 1         | 14.39 | 6      |
| 5  | Haunted                | 2         | 12.59 | 1      |
+----+------------------------+-----------+-------+--------+
```
В данном запросе всем записям таблицы в качестве значения поля `price` устанавливается текущее значение поля `price`, умноженное на `0.9` значений поля `price` дробную часть
```sql
UPDATE Books
SET price = ROUND(price * 0.9);
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.00  | 1      |
| 2  | Fight Club             | 2         | 9.00  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.00  | 11     |
| 4  | The Green Mile         | 1         | 14.00 | 6      |
| 5  | Haunted                | 2         | 13.00 | 1      |
+----+------------------------+-----------+-------+--------+
```
#### Обновление с условной конструкцией
При обновлении таблицы можно пользоваться условными конструкциями. Они могут быть полезны в том случае, когда определенному значению нужно поставить в соответствие другое определенное значение

В качестве примера использования условной конструкции напишем запрос, который устанавливает каждой книге цену, зависящую от ее доступного для покупки количества
```sql
UPDATE Books
SET price = CASE
                WHEN amount < 5 THEN price * 0.9
                WHEN amount BETWEEN 5 AND 10 THEN price * 0.7
                ELSE price * 0.5
            END;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.19  | 1      |
| 2  | Fight Club             | 2         | 5.00  | 19     |
| 3  | The Catcher in the Rye | 3         | 1.75  | 11     |
| 4  | The Green Mile         | 1         | 11.19 | 6      |
| 5  | Haunted                | 2         | 12.59 | 1      |
+----+------------------------+-----------+-------+--------+
```
Данный запрос изменяет значение поля `price` каждой записи в зависимости от значения поля `amount`. К примеру, если запись в качестве значения поля `amount` содержит число меньше `5`, то значением поля `price` такой записи будет текущее значение поля `price`, умноженное на `0.9`
#### Обновление на основе данных из других таблиц
При обновлении данных одной таблицы допустимо пользоваться данными из других таблиц. Предположим, мы хотим установить всем книгам, принадлежащим автору `Stephen King`, скидку в `50%`. Для решения такой задачи можно в блоке `WHERE` обратиться к таблице `Authors` посредством подзапроса с целью определения идентификатора необходимого нас автора
```sql
UPDATE Books
SET price = price * 0.5
WHERE author_id = (SELECT id
                   FROM Authors
                   WHERE author = 'Stephen King');
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 4.00  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 8.00  | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
Также предложенная задача может быть решена с помощью соединения таблиц `Books` и `Autors`. Суть использования соединения при обновлении записей таблицы заключается в наделении каждой обновляемой записи дополнительной информацией при отборе обновляемых записей
```sql
UPDATE Books INNER JOIN Authors ON Books.author_id = Authors.id
SET Books.price = Books.price * 0.5
WHERE Authors.author = 'Stephen King';
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 4.00  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 8.00  | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
В примере выше выполняется соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id`, результатом которого является следующая таблица:
```
+----+------------------------+-----------+-------+--------+----+-----------------+
| id | title                  | author_id | price | amount | id | author          |
+----+------------------------+-----------+-------+--------+----+-----------------+
| 1  | The Shining            | 1         | 7.99  | 1      | 1  | Stephen King    |
| 2  | Fight Club             | 2         | 9.99  | 19     | 2  | Chuck Palahniuk |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     | 3  | Jerome Salinger |
| 4  | The Green Mile         | 1         | 15.99 | 6      | 1  | Stephen King    |
| 5  | Haunted                | 2         | 13.99 | 1      | 2  | Chuck Palahniuk |
+----+------------------------+-----------+-------+--------+----+-----------------+
```
Затем выполняется изменение значения поля `price` записей таблицы `Books`, однако для определения того, должна быть изменена запись или нет, используется значение поля `author` из результата соединения таблиц `Books` и `Authors`: если значением поля `author` является строка `Stephen King`, запись изменяется, в противном случае запись игнорируется.
#### Ограничение обновляемых записей
Ключевое слово `LIMIT`, используемое для ограничения количества извлекаемых записей, также может использоваться для ограничения количества обновляемых записей. В качестве примера использования данного ключевого слова напишем запрос, который увеличивает цену первой книги в таблице `Books` на `2` доллара
```sql
UPDATE Books
SET price = price + 2
LIMIT 1;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 5  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
При обновлении данных ключевое слово `OFFSET` совместно с ключевым словом `LIMIT` использовать нельзя
#### Обновление с сортировкой
Оператор `ORDER BY` может использоваться совместно с оператором `UPDATE` для определения порядка, в котором будут обновляться записи. На первый взгляд может показаться, что нам неважно, какие записи будет обновлены первыми, а какие последними, однако в некоторых ситуациях важно определить очередность их изменения

Например, необходимость определения порядка обновления записей может возникнуть в случае изменения значений поля, являющегося первичным ключом. Известно, что значения первичного ключа должны быть универсальными, однако при их обновлении некоторые значения могут совпасть, что приведет к ошибке
```sql
UPDATE Books
SET id = id + 1;
```
```
ERROR 1062: Duplicate entry '2' for key 'Books.PRIMARY'
```
В запросе выше мы пытаемся сдвинуть идентификаторы всех книг на одно значение вперед, однако в результате получаем ошибку. Так происходит по той причине, что обновление записей выполняется последовательно, начиная с первой. Поэтому после увеличения идентификатора первой книги на единице, он становится равным `2`, результатом чего является то, что в таблице `Books` находятся две записи (первая и вторая), имеющие в качестве значения первичного ключа число `2`

Чтобы избежать подобного поведения, можно воспользоваться оператором `ORDER BY` и выполнять обновление записей, начиная с последней
```sql
UPDATE Books
SET id = id + 1
ORDER BY id DESC;
```
```
+----+------------------------+-----------+-------+--------+
| id | tite                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 2  | The Shining            | 1         | 7.99  | 1      |
| 3  | Fight Club             | 2         | 9.99  | 19     |
| 4  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 5  | The Green Mile         | 1         | 15.99 | 6      |
| 6  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
В данном запросе значения поля `id` обновляются в обратном порядке: сперва последняя запись изменяет значение с `5` на `6`, затем предпоследняя - с `4` на `5`, и так далее. В результате никакие два значения первичного ключа при обновлении не совпадают и запрос выполняется успешно
### Примечания
**Примечание 1**. Оператор `UPDATE` поддерживает дополнительное ключевое слово `IGNORE`, которое позволяет не прерывать процесс обновления данных даже при возникновении ошибок. Например, если при обновлении выполняется изменение первичного ключа, которое приводит к появлению дубликатов, такая операция просто игнорируется
```sql
UPDATE IGNORE Books
SET id = id + 1;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 1      |
| 2  | Fight Club             | 2         | 9.99  | 19     |
| 3  | The Catcher in the Rye | 3         | 3.49  | 11     |
| 4  | The Green Mile         | 1         | 15.99 | 6      |
| 6  | Haunted                | 2         | 13.99 | 1      |
+----+------------------------+-----------+-------+--------+
```
В примере выше первые четыре попытки изменения значение поля `id` были проигнорированы

**Примечание 2**. Результатом запроса, обновляющего данные таблицы, не является таблица. Поэтому, если после обновления данных необходимо тут же их получить, можно использовать дополнительный извлекающий запрос
```sql
UPDATE Books
SET price = 9.99,
    amount = 50;

SELECT *
FROM Books;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 9.99  | 50     |
| 2  | Fight Club             | 2         | 9.99  | 50     |
| 3  | The Catcher in the Rye | 3         | 9.99  | 50     |
| 4  | The Green Mile         | 1         | 9.99  | 50     |
| 5  | Haunted                | 2         | 9.99  | 50     |
+----+------------------------+-----------+-------+--------+
```
Стоит обратить внимание на то что, обновляющий запрос отделяется от извлекающего запроса точкой с запятой(`;`)

**Примечание 3**. Каждое поле таблицы может обладать рядом свойств, которые определяются при создании таблицы. Одним из таких свойств является запрет на хранение значения `NULL`. Если поле обладает данным свойством и не может содержать значение `NULL`, то при попытке добавить в него `NULL` путем изменения любого из имеющихся в поле значений произойдет ошибка

Например, поле `id` таблицы `Autors` является первичным ключом, которое может содержать исключительно уникальные целочисленные значения, поэтому если мы попытаемся изменить хотя бы одно значение в этом поле на `NULL`, то получим ошибку
```sql
UPDATE Authors
SET id = NULL
LIMIT 1;
```
```
ERROR 1048: Column 'id' cannot be null
```
Однако если после оператора `UPDATE` указать ключевое слово `IGNORE`, то при попытке изменения значения поля, не поддерживающего `NULL`, на `NULL`, значение поля будет изменено на значение по умолчанию в зависимости от типа поля. например, для числового поля таким значением по умолчанию является `0`, для строкового `''`, для даты - `0000-00-00`
```sql
UPDATE IGNORE Authors
SET id = NULL
LIMIT 1;

SELECT *
FROM Authors;
```
```
+----+-----------------+
| id | author          |
+----+-----------------+
| 0  | Stephen King    |
| 2  | Chuck Palahniuk |
| 3  | Jerome Salinger |
+----+-----------------+
```

**Примечание 4**. Каждое поле таблицы может иметь значение по умолчанию, которое определяется при создании таблицы. Если поле имеет значение по умолчанию, то при изменении значений этого поля им можно воспользоваться с помощью ключевого слова `DEFAULT`

Например, поле `amount` таблицы `Books` имеет значение по умолчанию, равное `0`. Если во время изменения значений этого поля мы укажем не что-то конкретное, а ключевое слово `DEFAULT`, то будет использовано значение `0`
```sql
UPDATE Books
SET amount = DEFAULT;

SELECT *
FROM Books;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 0      |
| 2  | Fight Club             | 2         | 9.99  | 0      |
| 3  | The Catcher in the Rye | 3         | 3.49  | 0      |
| 4  | The Green Mile         | 1         | 15.99 | 0      |
| 5  | Haunted                | 2         | 13.99 | 0      |
+----+------------------------+-----------+-------+--------+
```

**Примечание 5**. При обновлении данных таблицы на основе данных из других таблиц с помощью соединения нельзя использовать сортировку и оператор `LIMIT`
```sql
UPDATE Books
SET amount = DEFAULT;

SELECT *
FROM Books;
```
```
+----+------------------------+-----------+-------+--------+
| id | title                  | author_id | price | amount |
+----+------------------------+-----------+-------+--------+
| 1  | The Shining            | 1         | 7.99  | 0      |
| 2  | Fight Club             | 2         | 9.99  | 0      |
| 3  | The Catcher in the Rye | 3         | 3.49  | 0      |
| 4  | The Green Mile         | 1         | 15.99 | 0      |
| 5  | Haunted                | 2         | 13.99 | 0      |
+----+------------------------+-----------+-------+--------+
```

```sql
UPDATE Books INNER JOIN Authors ON Books.author_id = Authors.id
SET Books.price = Books.price * 0.5
WHERE Authors.author = 'Stephen King'
LIMIT 1;
```
```
ERROR 1221: Incorrect usage of UPDATE and LIMIT
```

**Примечание 6**. При обновлении данных таблицы на основе данных из других таблицы с помощью подзапроса в подзапросе нельзя обращаться к обновляемой таблице
```sql
UPDATE Books
SET price = price * 0.5
WHERE price = (SELECT MIN(price)
               FROM Books);
```
```
ERROR 1093: You can't specify target table 'Books' for update in FROM clause
```