#база_данных #реляционные #SQL #СУБД 

##### Таблички для примеров
```
+----+--------+----------+-------+
| id | name   | surname  | grade |
+----+--------+----------+-------+
| 1  | Flash  | Thompson | 2     |
| 2  | Peter  | Parker   | 5     |
| 3  | Mary   | Jane     | 2     |
| 4  | Gwen   | Stacy    | 4     |
| 5  | Harry  | Osborn   | 5     |
| 6  | Ben    | Reilly   | 1     |
| 7  | Miles  | Morales  | 5     |
| 8  | John   | Jameson  | 1     |
| 9  | Curtis | Connors  | 4     |
| 10 | Edward | Brock    | 3     |
+----+--------+----------+-------+
```
Первое поле этой таблицы содержит идентификатор студента, второе — имя, третье — фамилию, четвертое — оценку по пятибалльной шкале.
### Хранимые процедуры
Как и функции, процедуры заключают в себе определенный набор операций, который выполняется при их вызове. Также процедуры могут принимать различные аргументы, которые могут быть использованы в их теле. однако, несмотря на схожесть процедур и функций, между ними существует важное различие - **процедуры не имеют возвращаемого значения**, поэтому, к примеру, процедуры не могут быть использованы внутри выражений. По большому счету, все, что можно сделать с процедурой, это вызвать ее и выполнить определенные в ее теле операции.

В контексте **СУБД** процедуры обычно называют **хранимыми процедурами**.
### Создание хранимых процедур
Общий шаблон для создания хранимой процедуры имеет следующий вид:
```sql
DELIMITER //
CREATE PROCEDURE <имя процедуры>(<1 параметр>, <2 параметр>, ...)
BEGIN
    <тело процедуры>;
END //
DELIMITER ;
```
Итак, создание процедуры начинается с ключевого слова `DELIMITER`, с помощью которого выполняется изменение разделителя на двойной слеш (`//`).  Далее следует оператор `CREATE PROCEDURE`, после которого указывается имя процедуры. Затем в скобках через запятую выполняется определение каждого параметра процедуры.

Внутрь последующего блока `BEGIN END` помещается тело процедуры, которое и определяет ее поведение. Тело процедуры может включать вычисления на основе переданных аргументов, определения вспомогательных переменных, обращения к таблицам базы данных, условные конструкции  `IF-ELSEIF-ELSE`, а также любые виды циклов. Завершается создание процедуры обновленными разделителем `//` и возвратом к стандартному разделителю в виде символа `;`.
### Хранимые процедуры без параметров
Для лучшего понимания принципа создания хранимых процедур и работы с ними начнем с наиболее простых примеров - процедур, которые не принимают никаких аргументов. В качестве первого примера рассмотрим процедуры `HIGH_GRADE_STUDENTS()`, которая извлекает информацию о студентах, получивших оценку `4` или выше.
```sql
DELIMITER //
CREATE PROCEDURE HIGH_GRADE_STUDENTS()
BEGIN
    SELECT *
    FROM Math
    WHERE grade >= 4;
END //
DELIMITER ;
```
Как видно, определение процедуры `HIGH_CRADE_STUDENTS()` вне блока `BEGIN END` полностью соответствует предложенному ранее шаблону, а внутри того же блока располагается единственная операция, извлекающая из таблицы `Math` те записи, значения поля `grade` которых больше или равно `4`

Для того чтобы вызвать хранимую процедуру и выполнить все содержащиеся в ней операции, необходимо воспользоваться ключевым словом `CALL`, а затем указать имя процедуры.

Результаты выполнения процедуры:
```sql
CALL HIGH_GRADE_STUDENTS;
```
```
+----+--------+---------+-------+
| id | name   | surname | grade |
+----+--------+---------+-------+
| 2  | Peter  | Parker  | 5     |
| 4  | Gwen   | Stacy   | 4     |
| 5  | Harry  | Osborn  | 5     |
| 7  | Miles  | Morales | 5     |
| 9  | Curtis | Connors | 4     |
+----+--------+---------+-------+
```
При вызове процедуры без параметров. в отличие от функции без параметров, пустые круглые скобки после имени процедуры указывать необязательно.

Хранимые процедуры могут использоваться для выполнения совершенно любых операций, а не только для извлечения данных. Поэтому в качестве следующего примера рассмотрим процедуру `DELETE_LOW_CRADE_STUDENTS()`, которая удаляет информацию о студентах, получивших оценку `2` или ниже.

определить подобную хранимую процедуру можно следующим образом:
```sql
DELIMITER //
CREATE PROCEDURE DELETE_LOW_GRADE_STUDENTS()
BEGIN
    DELETE FROM Math
    WHERE grade <= 2;
END //
DELIMITER ;
```
Стоит обратить внимание, что процедура `DELETE_LOW_GRADE_STUDENTS()` всего лишь выполняет удаление определенных записей из таблицы `Math`, поэтому при необходимости проверить результат ее вызова потребуется обратиться к той таблице, с которой взаимодействует процедура.
```sql
DELIMITER //
CREATE PROCEDURE DELETE_LOW_GRADE_STUDENTS()
BEGIN
    DELETE FROM Math
    WHERE grade <= 2;
END //
DELIMITER ;

CALL DELETE_LOW_GRADE_STUDENTS;

SELECT *
FROM Math;
```
```
+----+--------+---------+-------+
| id | name   | surname | grade |
+----+--------+---------+-------+
| 2  | Peter  | Parker  | 5     |
| 4  | Gwen   | Stacy   | 4     |
| 5  | Harry  | Osborn  | 5     |
| 7  | Miles  | Morales | 5     |
| 9  | Curtis | Connors | 4     |
| 10 | Edward | Brock   | 3     |
+----+--------+---------+-------+
```
В запросе выше выполняется вызов процедуры `DELETE_LOW_GRADE_STUDENTS()`, а затем происходит извлечение всех записей из таблицы `Math`. По результату запроса можно увидеть, что записи значение поля `grade` которых меньше или равно `2`, были удалены процедурой.

Поскольку тело хранимой процедуры может состоять из нескольких операций, предложенную процедуру `DELETE_LOW_GRADE_STUDENTS()` можно модифицировать таким образом, чтобы после удаления студентов с низкой оценкой она информировала о том, какое количество студентов было удалено.

Модифицировать данную хранимую процедуру можно следующим образом:
```sql
DELIMITER //
CREATE PROCEDURE DELETE_LOW_GRADE_STUDENTS()
BEGIN
    DECLARE low_grade_students INT;
    
    SET low_grade_students := (SELECT COUNT(*)
                               FROM Math
                               WHERE grade <= 2);
    
    DELETE FROM Math
    WHERE grade <= 2;
        
    SELECT low_grade_students AS deleted_students;
END //
DELIMITER ;
```

Теперь тело процедуры `DELETE_LOW_GRADE_STUDENTS()` начинается с определения переменной `low_grade_students`, которая используется для хранения количества записей таблицы `Math`, значение поля `grade` которых меньше или равно `2`(именно эти записи будут удалены). Завершается тело процедуры извлечением значения переменной, что и соответствует информированию о том, сколько записей было удалено процедурой.
```sql
DELIMITER //
CREATE PROCEDURE DELETE_LOW_GRADE_STUDENTS()
BEGIN
    DECLARE low_grade_students INT;
    
    SET low_grade_students := (SELECT COUNT(*)
                               FROM Math
                               WHERE grade <= 2);
    
    DELETE FROM Math
    WHERE grade <= 2;
        
    SELECT low_grade_students AS deleted_students;
END //
DELIMITER ;

CALL DELETE_LOW_GRADE_STUDENTS;
```
```
+------------------+
| deleted_students |
+------------------+
| 4                |
+------------------+
```
### Примечания
**Примечание 1**. При создании хранимой процедуры ее можно определить как детерминированную или недетерминированную, однако, в отличие от пользовательских функций, делать это необязательно.

**Примечание 2**. Хранимую процедуру можно дополнить строкой документации. Для этого перед блоком `begin end` необходимо указать ключевое слово `COMMENT`, а затем предоставить строку содержащую краткое описание поведения процедуры.
```sql
DELIMITER //
CREATE PROCEDURE HIGH_GRADE_STUDENTS()
COMMENT 'Процедура извлекает информацию о студентах, получивших оценку 4 или выше'
BEGIN
    SELECT *
    FROM Math
    WHERE grade >= 4;
END //
DELIMITER ;
```

**Примечание 3**. Хранимая процедура может быть удалена после создания. Для этого нужно воспользоваться именем оператором `DELETE PROCEDURE`, а затем указать имя процедуры.

Например, запрос, который удаляет хранимую процедуру `HIGH_GRADE_STUDETNS()`, выглядит следующим образом:
```sql
DROP PROCEDURE HIGH_GRADE_STUDENTS;
```

**Примечание 4**. Хранимые процедуры нечувствительны к регистру, поэтому, например, процедуру с именем `HIGH_GRADE_STUDENTS` можно вызвать как с использованием имени `HIGH_GRADE_STUDENTS`, так и `high_grade_students` или `High_Grade_Students`.

## Хранимые процедуры с параметрами
Как и в случае с пользовательскими функциями, поведение хранимых процедур можно делать более гибкими с помощью параметров. Однако в отличие от функций, процедуры поддерживают несколько типов параметров **входные** и **выходные**. Вид параметра определяется путем указания некоторого ключевого слова перед его именем. Например, для определения параметра как входного используется ключевое слово `IN`, выходного - `OUT`.
### Хранимые процедуры с входными параметрами
Поведение входных параметров процедуры полностью совпадает с поведением обычных параметров функции. В качестве примера их использования создадим процедуру `STUDENTS_WITH_GRADE()`, которая принимает в качестве аргумента оценку и извлекает из таблицы `Math` информацию о студентах, получивших переданную оценку.
```sql
DELIMITER //
CREATE PROCEDURE STUDENTS_WITH_GRADE(IN score INT)
BEGIN
    SELECT id, name, surname
    FROM Math
    WHERE grade = score;
END //
DELIMITER ;

CALL STUDENTS_WITH_GRADE(5);
```
 ```
+----+-------+---------+
| id | name  | surname |
+----+-------+---------+
| 2  | Peter | Parker  |
| 5  | Harry | Osborn  |
| 7  | Miles | Morales |
+----+-------+---------+
```
В примере выше видно, что процедура `STUDENTS_WITH_GRADE()` имеет один целочисленный параметр `score`, который при этом является выходным, поскольку его именем указано ключевое слово `IN`.

Количество входных параметров не ограничивается одним параметром, их может быть и больше. В качестве следующего примера создадим процедуру `STUDENTS_WITH_GRADE_BETWEEN()`, которая принимает в качестве аргументов левую и правую границы оценок и извлекает из таблицы `Math` информацию о студентах, оценка которых попадает в указанные границы.
```sql
DELIMITER //
CREATE PROCEDURE STUDENTS_WITH_GRADE_BETWEEN(IN min_score INT, IN max_score INT)
BEGIN
    SELECT id, name, surname, grade
    FROM Math
    WHERE grade BETWEEN min_score AND max_score;
END //
DELIMITER ;

CALL STUDENTS_WITH_GRADE_BETWEEN(2, 4);
```
```
+----+--------+----------+-------+
| id | name   | surname  | grade |
+----+--------+----------+-------+
| 1  | Flash  | Thompson | 2     |
| 3  | Mary   | Jane     | 2     |
| 4  | Gwen   | Stacy    | 4     |
| 9  | Curtis | Connors  | 4     |
| 10 | Edward | Brock    | 3     |
+----+--------+----------+-------+
```
### Хранимые процедуры с выходными параметрами
Несмотря на то, что у процедуры отсутствуют возвращаемое значение, получить результаты выполненных в ее теле операций или вычислений можно. Реализуется это с помощью выходных параметров. При вызове процедуры в качестве значения выходного параметра передается не конкретное значение, а пользовательская переменная, и если процедура в своем теле присвоит выходному параметру какое-либо значение, такое же значение примет и переменная, указанная при вызове процедуры.

В качестве примера использования выходных параметров создадим процедуру `MAX_GRADE()`, которая принимает в качестве аргумента пользовательскую переменную и присваивает ей в качестве значения максимальную оценку из таблицы `Math`
```sql
DELIMITER //
CREATE PROCEDURE MAX_GRADE(OUT score INT)
BEGIN
    SET score := (SELECT MAX(grade)
                  FROM Math);
END //
DELIMITER ;

SET @max_grade = NULL;

CALL MAX_GRADE(@max_grade);

SELECT @max_grade;
```
```
+------------+
| @max_grade |
+------------+
| 5          |
+------------+
```
Итак, процедура `MAX_GRADE()` имеет один целочисленный параметр `score`, который является выходным. В теле процедуры этому параметру присваивается максимальное значение поля `grade` таблицы `Math`. Поскольку параметр `scpre` является выходным, присвоенное ему значение можно получить путем передачи пользовательской переменной при вызове процедуры. В данному примере присвоенное параметру `score` значение записывается в переменную `max_grade`, поскольку именно она была указана при вызове процедуры `MAX_GRADE()`

Выходной параметр хранимой процедуры всегда имеет начальное значение, равное `NULL`

Количество выходных параметров также не ограничивается одним параметром, их может быть и больше. В качестве следующего примера создадим процедуру `MIN_MAX_GRADES()`, которая принимает в качестве аргументов две пользовательские переменные и присваивает первой переменной в качестве значения минимальную оценку из таблицы `Math`, второй - максимальную.
```sql
DELIMITER //
CREATE PROCEDURE MIN_MAX_GRADES(OUT min_score INT, OUT max_score INT)
BEGIN
    SET min_score := (SELECT MIN(grade)
                      FROM Math),
        max_score := (SELECT MAX(grade)
                      FROM Math);
END //
DELIMITER ;

SET @min_grade := NULL,
    @max_grade := NULL;

CALL MIN_MAX_GRADES(@min_grade, @max_grade);

SELECT @min_grade, @max_grade;
```
```
+------------+------------+
| @min_grade | @max_grade |
+------------+------------+
| 1          | 5          |
+------------+------------+
```

Хранимые процедуры поддерживают дополнительный вид параметров, определяемый с помощью ключевого слова `INOUT`. Параметры, перед именем которого указано такое ключевое слово, ведет себя как **входной и выходной одновременно**.

Входной-выходной параметр по функционалу похож на выходной параметр, поскольку в качестве его аргумента также указывается пользовательская переменная. Однако если начальное значение выходного параметра всегда равно `NULL`, то начальное значение входного-выходного параметра определяется значением пользовательской переменной, которое передается ему в качестве аргумента.
```sql
DELIMITER //
CREATE PROCEDURE PROC(OUT parameter INT)
BEGIN
    SELECT parameter;
END //
DELIMITER ;

SET @variable := 1;

CALL PROC(@variable);
```
```
+-----------+
| parameter |
+-----------+
| NULL      |
+-----------+
```
В то время как результатом приведенного ниже  запроса:
```sql
DELIMITER //
CREATE PROCEDURE PROC(INOUT parameter INT)
BEGIN
    SELECT parameter;
END //
DELIMITER ;

SET @variable := 1;

CALL PROC(@variable);
```
```
+-----------+
| parameter |
+-----------+
| 1         |
+-----------+
```