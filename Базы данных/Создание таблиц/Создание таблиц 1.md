#база_данных #реляционные #SQL #СУБД 

**SQL** применяется не только для работы с табличными данными, но и для выполнения всех операций с базой данных, включая создание и модификацию таблиц. Большинство **СУБД** содержит инструменты администрирования, которые можно применять для интерактивного создания таблиц и управления ими. Однако с таблицами также можно работать посредством запросов. Например, для создания таблиц предназначен оператор `CREATE TABLE`, который мы и рассмотрим в этом уроке

Интерактивный инструментарий, предоставляемый **СУБД** для работы с таблицами. в действительности реализуется с помощью обычных запросов, которые **СУБД** сама создает и выполняет незаметно для программиста

Перед созданием таблицы всегда необходимо заранее определиться с ее именем, именами полей, а также типом данных каждого поля. В качестве примера создадим таблице `Books`, предназначенную для хранения информации о различных книгах. Она будет включать три следующих поля:
- `id` — целочисленное поле, содержащее идентификатор книги
- `title` — строковое поле, содержащее название книги
- `author` — строковое поле, содержащее данные об авторе книги

Теперь рассмотрим запрос, который создает предложенную таблицу. Он выглядит следующим образом:
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```
Как видно из запроса выше, имя таблицы указывается сразу же после оператора `CREATE TABLE`. Далее следует определение таблицы, которое заключается в круглые скобки и содержит определение каждого поля. Определения полей разделяются запятыми. Определение каждого поля начинается с имени поля, а за ним указывается тип данных.

Таблицы и поля всегда следует называть осмысленно и прозрачно. Подробнее с правилами именования можно ознакомиться в руководстве по [ссылке](https://www.sqlstyle.guide/ru/#%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE-%D0%BD%D0%B0%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8).

Во время создания очередной таблицы может оказаться так, что в базе данных содержится таблица, имя которой совпадает с именем создаваемой таблицы. Результатом такой операции будет ошибка.
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```
```
ERROR 1050: Table 'Books' already exists
```

В данном запросе сначала успешно создается таблица `Books`, однако затем выполняется попытка создания таблицы вновь с именем `Books`, что приводит к ошибке, поскольку в базе данных уже имеется таблица с таким именем.

Чтобы перед созданием таблицы выполнить проверку того, что в базе данных нет таблицы с таким же именем, нужно после оператора `CREATE TABLE` указать сочетание ключевых слов `IF NOT EXISTS`. При их использовании создание таблицы произойдет только в том случае, если ее имя в рамках базы данных уникально.
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

CREATE TABLE IF NOT EXISTS Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    price  INT
);
```
будет успешно выполнена первая операция создания таблицы `Books`, в то время как вторая операция создания таблицы с тем же именем будет проигнорирована.
### Табличные ограничения
Для обеспечения целостности хранимых в таблице данных используются **ограничения**. Ограничение представляет собой ключевое слово (или связку ключевых слов), которое указывается в определении поля и добавляет этому полю дополнительные свойства.
#### Непустые значения
Ограничение `NOT NULL` используются для того, чтобы запретить полю хранить значение `NULL`. Если поле имеет ограничение `NOT NULL`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля не должно быть равным `NULL`

В качестве примера расширим определение предложенной в начале статьи таблицы `Books` и применим ограничение `NOT NULL` к ее полю `id`. Тогда запрос, создающий таблице, будет выглядеть следующим образом:
```sql
​CREATE TABLE Books
(
    id     INT NOT NULL,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблице `Books` запись, значение поля `id` которой равняется `NULL`, произойдет ошибка.
```sql
CREATE TABLE Books
(
    id     INT NOT NULL,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (NULL, 'Fight Club', 'Chuck Palahniuk');
```
```
ERROR 1048: Column 'id' cannot be null
```
Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` уже имеющейся записи на `NULL`

Если ограничение `NOT NULL` не применяется к полю, то оно может хранить значение `NULL`, то есть хранение `NULL` — поведение по умолчанию.
#### Уникальные значения
Ограничение `UNIQUE` используется для того, чтобы запретить полю хранить повторяющиеся значения. Если поле имеет ограничение `UNIQUE`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля должно быть уникальным

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `UNIQUE` к ее полю `id`. Тогда запрос, создающий таблице, будет выглядеть следующим образом:
```sql
CREATE TABLE Books
(
    id     INT UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблицу `Books` запись, значение поля `id` которой не является уникальным в рамках этого поля, произойдет ошибка
```sql
CREATE TABLE Books
(
    id     INT UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk'),
       (1, 'The Green Mile', 'Stephen King');
```
```
ERROR 1062: Duplicate entry '1' for key 'Books.id'
```

В данном примере в таблицу успешно добавляется первая запись, однако при попытке добавить вторую запись происходит ошибка, поскольку значение ее поля `id` совпадает со значением поля `id` уже имеющейся в таблице записи

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` на значение, которое не является уникальным в рамках этого поля
#### Значение по умолчанию
Ограничение `DEFAULT` используется для того, чтобы определить значение по умолчанию, которое примет поле в том случае, если при добавлении записи его значение не будет указано явно

Если поле имеет значение по умолчанию, топ этого значения должен соответствовать типу самого поля

В качестве примера расширим определение предложенной в начале статьи таблицы `Books` и применим ограничение `DEFAULT` к ее полям `title` и `author`. Тогда запрос, создающий таблице, будет выглядеть следующим образом:
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40) DEFAULT 'Untitled',
    author VARCHAR(40) DEFAULT 'Unknown'
);
```

Теперь, если при добавлении записи в таблице `Books` поля `title` и `author` будут опущены, они автоматически примут строковые значения `Untitled` и `Unknown` соответствно.
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40) DEFAULT 'Untitled',
    author VARCHAR(40) DEFAULT 'Unknown'
);

INSERT INTO Books (id)
VALUES (1);

SELECT *
FROM Books;
```
```
+----+----------+---------+
| id | title    | author  |
+----+----------+---------+
| 1  | Untitled | Unknown |
+----+----------+---------+
```

Значение по умолчанию, указанное после ключевого слова `DEFAULT`, может быть как константой, так и произвольной сложности выражением с использованием функций и арифметических операторов. Если в качестве значения по умолчанию используется выражение, оно должно быть заключено в круглые скобки. Также выражение, используемое в качестве значения по умолчанию, может ссылаться на значения других полей записи, однако только в том случае, если эти значения уже определены:
В качестве примера вновь расширим определение предложенной в начале урока таблицы `Books` и добавим ей дополнительное поле `fulltitle`, которое будет хранить полное название книги с указанием автора. Значение по умолчанию этого поля определим как конкатенацию значений полей `title` и `author`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

Теперь, если при добавлении записи в таблицу `Books` поле `fulltitle` будет опущено, его значение все равно будет корректно определено на основе значений полей `title` и `author`.
```sql
CREATE TABLE Books
(
    id        INT,
    title     VARCHAR(40),
    author    VARCHAR(40),
    fulltitle VARCHAR(40) DEFAULT (CONCAT(title, ' by ', author))
);

INSERT INTO Books (id, title, author)
VALUES (1, 'Fight Club', 'Chuck Palahniuk');

SELECT *
FROM Books;
```
```
+----+------------+-----------------+-------------------------------+
| id | title      | author          | fulltitle                     |
+----+------------+-----------------+-------------------------------+
| 1  | Fight Club | Chuck Palahniuk | Fight Club by Chuck Palahniuk |
+----+------------+-----------------+-------------------------------+
```
#### Дополнительные проверки
Ограничение `CHECK` используется для того, чтобы запретить полю хранить значения, не удовлетворяющие заданному условию. Если поле имеет ограничение `CHECK`, это значит, что при добавлении новой записи или обновлении существующей записи значение этого поля перед установкой будет проверено на корректность.

Условие, используемое для проверки, представляет собой выражение, заключенное в круглые скобки, которое указывается после ключевого слова `CHECK`. Оно может быть составлено с использованием функций и различных операторов сравнения (`=, >, LIKE` и так далее), то есть иметь произвольную сложность.

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `CHECK` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:
```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при попытке добавить в таблицу `Books` запись, значение поля `id` которой не является положительным числом, произойдет ошибка.

```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (-3, 'Fight Club', 'Chuck Palahniuk');
```
```
ERROR 3819: Check constraint 'Books_chk_1' is violated.
```
#### Комбинирование ограничений
При использовании ограничений их можно комбинировать. Например, к полю `id` таблицы `Books` мы можем одновременно применить два ограничения `UNIQUE` и `NOT NULL`, чтобы разрешить данному полю хранить лишь непустые уникальные значения.

Запрос, создающий таблицу с подобными ограничениями, выглядит следующим образом:
```sql
​​CREATE TABLE Books
(
    id     INT NOT NULL UNIQUE,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```
Обратите внимание, что перечисление ограничений происходит через пробел, а не через запятую.
### Примечания
**Примечание 1**. У каждого ограничения `CHECK` имеется свое имя, которое **СУБД** автоматически определяет следующим образом:
```
<название таблицы>_chk_<порядковый номер ограничения>
```
Например, первое определенное в таблице `Books` ограничение будет иметь имя `Books_chk_1`, второе - `Books_chk_2`, и так далее.

Если во время выполнения запросе какое-либо ограничение `CHECK` приводит к ошибке, то имя отображается в поясняющем сообщение
```sql
CREATE TABLE Books
(
    id     INT CHECK (id > 0),
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (-1, 'Fight Club', 'Chuck Palahniuk');
```
```
ERROR 3819: Check constraint 'Books_chk_1' is violated.
```
Для удобства ограничения `CHECK` можно именовать вручную. Для этого необходимо вынести определение ограничения из определения поля и воспользоваться ключевым словом `CONSTRAINT`.
```sql
CREATE TABLE Books
(
    id     INT,
    title  VARCHAR(40),
    author VARCHAR(40),
    CONSTRAINT positive_id CHECK (id > 0)
);

INSERT INTO Books (id, title, author)
VALUES (-1, 'Fight Club', 'Chuck Palahniuk');
```
```
ERROR 3819: Check constraint 'positive_id' is violated.
```

**Примечание 2.** При создании таблицы необходимо определить хотя бы одно поле. Таблица может не иметь ни одной записи, но обязательно должна иметь хотя бы одно поле.

**Примечание 3.** Если поле не имеет явно определенного значения по умолчанию, но поддерживает значение `NULL`, значением по умолчанию такого поля будет `NULL`.
### [[Создание таблиц 2]]