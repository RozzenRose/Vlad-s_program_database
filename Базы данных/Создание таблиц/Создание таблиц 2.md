#база_данных #реляционные #SQL #СУБД 
#### Первичный ключ
В реляционной модели баз данных первичный ключ играет очень важную роль и является неотъемлемой частью практически любой таблицы. Чтобы поле могло быть первичным ключом, оно должно обладать двумя свойствами:
- поле не должно содержать значение `NULL`
- поле не должно содержать повторяющиеся значения

Таким образом, чтобы при создании таблицы определить какое-либо ее поле как первичный ключ, мы можем воспользоваться сочетанием ограничений `NOT NULL` и `UNIQUE`, которые как раз и будут гарантировать, что поле содержит лишь уникальные непустые значения. Однако данный способ не достаточно нагляден, а также не позволяет определить первичный ключ, включающий несколько полей. Поэтому в `SQL` для определения первичного ключа таблицы существует отдельное ограничение - `PRIMARY KEY`

В качестве примера использования данного ограничения создадим таблице `Books`, предназначенную для хранения информации о различных книгах. Она будет включать три следующих поля:
- `id` - целочисленное поле, содержащее уникальный непустой идентификатор книг
- `title` - стрелковое поле, содержащее название книги
- `author` - строковое поле, содержащее автора книги

Теперь рассмотрим запрос, создающий предложенную таблице. Он выглядит следующим образом:
```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
)
```
В таблице `Books` ограничение `PRIMARY KEY` примерно к полю `id`, то есть это поле является первичным ключом. Теперь при попытке добавить в данную таблице запись, значение поля `id` которой равняется `NULL` или не является уникальным в рамках этого поля, произойдет ошибка.

Также ошибка случиться при попытке изменить значение поля `id` уже имеющейся на `NULL` или значение, которое не является уникальным в рамках этого  поля
#### Составной первичный ключ
Ограничение `PRIMARY KEY` может быть указано в определении лишь одного поля, поэтому при необходимости задать первичный ключ, включающий два и более полей, нужно использовать несколько иной синтаксис

Предположим, что мы решили сменить структуру таблицы из статьи [[Создание таблиц 1]] и отказаться от поля `id`, а в качестве первичного ключа принять сочетание полей `title` и `author`. Тогда запрос, создающий таблице, будет выглядеть следующим образом:
```sql
CREATE TABLE Books
(
    title  VARCHAR(40),
    author VARCHAR(40),
    PRIMARY KEY (title, author)
);
```
В примере выше видно, что если первичный ключ является составным, то его определение нужно вынести в отдельное определение поля, в котором следует сначала указать ограничение `PRIMART KEY`, а затем в скобках перечислить все поля, составляющие первичный ключ

`PostgreSQL` тоже хавает такой синтаксис
#### Автоматическое заполнение
нередко первичный ключ таблицы представляет собой целочисленное поле, содержащее последовательные значения, начиная с `1`. С первичным ключом подобного формата обычно сочетают ограничение `AUTO_INCREMENT`, которое используется для автоматического заполнения поля рядом натуральных чисел. Другими словами, при добавлении записи в таблице значение такого поля указывать не обязательно, для первой записи автоматически будет принято число `1`, для второй - `2`, и так далее

Ограничение `AUTO_INCREMENT` может быть указано в определении лишь одного поля, причем это поле должно быть первичным ключом. Также ограничение `AUTO_IMCREMENT` не сочетается с ограничением `DEFAULT`

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `AUTO_INCREMENT` к ее полю `id`. Тогда запрос, создающий таблице, будет выглядеть следующим образом:
```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при добавлении записи в таблице `Books` значение поля `id` можно не указывать, оно само примет нужное последовательное значение
```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad'),
       ('War and Peace', 'Leo Tolstoy');
```
```
+----+-------------------+---------------+
| id | title             | author        |
+----+-------------------+---------------+
| 1  | It                | Stephen King  |
| 2  | Heart of Darkness | Joseph Conrad |
| 3  | War and Peace     | Leo Tolstoy   |
+----+-------------------+---------------+
```

В `PostgreSQL` используется оператор `SERIAL` вместо обычного указания класса `INT`:
```sql
CREATE TABLE "Books"
(
    id     SERIAL PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
)
```

Важно  заметить, что ограничение `AUTO_INCREMENT` определяет значение поля `id`, основываясь лишь на очередности добавления записи. Например, третья по счету добавляемая запись в качестве значения поля `id` примет число `3` даже в том случае, если какие-либо добавленные ранее записи были удалены
```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

DELETE FROM Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```
```
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 3  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```
В данном примере в таблицу добавляются две записи, которые в качестве значения поля `id` принимают числа `1` и `2` соответственно. Затем обе добавленные записи удаляются и добавляется третья запись, которая в качестве значения поля `id` принимает число `3`, а не `1`, несмотря на то что таблица не содержит ни одной записи

Исключением является очистка таблицы с помощью оператора `TRUNCATE`. При его использовании счетчик ограничения `AUTO_IMCREMENT` сбрасывается до `1`
```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

TRUNCATE Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```

таблица `Books` будет иметь вид:

```
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 1  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```
#### Внешний ключ
Одним из самых важных ограничений является `FOREIGN KEY`, которое предназначено для определения поля как внешнего ключа. Помимо построения связей между таблицами, оно выполняет постоянную поддержку согласованности этих связей. Если пренебрегать ограничением `FOREIGN KEY`, то в процессе работы с таблицами базы данных можно прийти к ситуации, в которой согласованность связанных данных будет нарушена, что, например, может означать то, что какая-либо таблица будет ссылаться на несуществующие данные

В качестве примера использования ограничения `FOREIGN KEY` создадим две связанные таблицы. Первой из них будет таблица `Authors`, предназначенная для хранения информации о различных авторах книг. Она будет включать три следующих поля:
- `id` - целочисленное поле, содержащее уникальный непустой идентификатор автора
- `name` - строковое поле, содержащее имя автора
- `surname` - строковое поле, содержащее фамилию автора

Второй таблицей будет таблица из [[Создание таблиц 1]], но с некоторыми изменениями. Она будет включать три следующих поля:
- `id` - целочисленное поле, содержащее уникальный непустой идентификатор книг
- `title` - строковое поле, содержащее название книги
- `authot_id` - целочисленное поле, содержащее идентификатор автора

Связь между таблицами строится посредством внешнего ключа `author_id` таблицы `Books`, которое ссылается на поле `id` таблицы `Authors`. Таким образом, таблица `Authors` является родительской, а таблица `Books` - дочерней

Теперь рассмотрим запрос, создающий предложенные таблицы. Он выглядит следующим образом:
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);
```

Часть запроса, создающая таблицу `Authors`, полностью знакома, поэтому сразу перейдем к той части, в которой происходит создание таблицы `Books`, а точнее определение ее внешнего ключа. Оно начинается с ограничения `FOREIGN KEY`, после которого в скобках указывается поле, являющееся внешним ключом. В нашем случае это поле `author_id`. Затем следует ключевое слово `REFERENCES`, а после него — имя родительской таблицы и вновь в скобках поле этой таблицы, на которое ссылается внешний ключ. В нашем случае внешний ключ ссылается на поле `id` таблицы `Authors`.

Внешний ключ и поле, на которое он ссылается, должны иметь одинаковые типы данных. Размер и знак типов с фиксированной точностью, таких как `INTEGER` и `DECIMAL`, должны быть одинаковыми

Поле, являющееся внешним ключом, обладает рядом соответствующих особенностей. Например, внешний ключ не может принимать значения, которых нет в поле, на которое он ссылается
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('War and Peace', 3);
```
```
ERROR 1452: Cannot add or update a child row: a foreign key constraint fails (`Books`, CONSTRAINT `Books_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `Authors` (`author_id`))
```
Запрос выше сначала добавляет в таблицу `Authors` две записи:
```
​+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```
Затем выполняется попытка добавить в таблицу `Books` запись, значение поля `author_id` которой равняется `3`. Но поле `id` таблицы `Authors`, на которое ссылается поле `author_id` таблицы `Books`, не содержит значения `3`, поэтому и само поле `author_id` не может содержать данное значение.
#### Поведение при обновлении и удалении
Когда выполняется попытка изменить запись в родительской таблице (а именно значение ее поля, связанного с внешним ключом), от которой зависят записи в дочерней таблице, происходит ошибка.
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books (
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```
```
ERROR 1451: Cannot delete or update a parent row: a foreign key constraint fails (`beegeek`.`books`, CONSTRAINT `books_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `authors` (`id`))
```
В данном запросе сначала в таблицу `Authors` добавляются две записи:
```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```
Затем в таблицу `Books` добавляется одна запись :
```
+----+-------+-----------+
| id | title | author_id |
+----+-------+-----------+
| 1  | It    | 1         |
+----+-------+-----------+
```
Первая запись таблицы `Books` становится зависимой от первой записи таблицы `Authors`, поэтому последующая попытка изменить значение поля `id` первой записи таблицы `Authors` с `1` на `3` приводит к ошибке. Аналогичная ошибка возникнет и в том случае, если произойдет попытка удалить первую запись таблицы `Authors`.

Поведение при обновлении или удалении связанных данных является настраиваемым. Чтобы определить действие, которое должно быть выполнено при обновлении, нужно после определения внешнего ключа указать дополнительный оператор `ON UPDATE`, а чтобы определить действие, которое должно быть выполнено при удалении, — оператор `ON DELETE`.

Само же действие определяется одним из трех ключевых слов: `CASCADE, SET NULL` или `RESTRICT`. Оно указывается сразу после оператора `ON UPDATE` (`ON DELETE`) и задает соответствующее поведение при обновлении (удалении) связанных данных.

При использовании ключевого слова `RESTRICT` изменение или удаление связанных данных приводит к ошибке. Другими словами, данное ключевое слово задает поведение по умолчанию.

Если используется ключевое слово `CASCADE`, то при изменении или удалении данных в родительской таблице аналогичные действия будут автоматически применены и к связанным записям в дочерней таблице.
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```
таблица `Books` будет иметь вид:
```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | 3         |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | 3         |
+----+-------------------+-----------+
```
таблица `Authors` будет иметь вид:
```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 2  | Joseph  | Conrad  |
| 3  | Stephen | King    |
+----+---------+---------+
```
Запрос выше сначала добавляет в таблицу `Authors` две записи:
```
+----+---------+---------+
| id | name    | surname |
+----+---------+---------+
| 1  | Stephen | King    |
| 2  | Joseph  | Conrad  |
+----+---------+---------+
```
После добавляются три записи в таблицу `Books`:
```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | 1         |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | 1         |
+----+-------------------+-----------+
```

Первая и третья записи таблицы `Books` зависимы от первой записи таблицы `Authors`, однако последующее изменение значения поля `id` первой записи таблицы `Authors` с `1` на `3` приводит не к ошибке, а к аналогичному изменению значений поля `author_id` первой и третье записей таблицы `Books`
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

DELETE FROM Authors
WHERE id = 1;
```
таблица `Books` будет иметь вид:
```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 2  | Heart of Darkness | 2         |
+----+-------------------+-----------+
```
таблица `Authors` будет иметь вид:
```
+----+--------+---------+
| id | name   | surname |
+----+--------+---------+
| 2  | Joseph | Conrad  |
+----+--------+---------+
```

Данный запрос практически полностью повторяет предыдущий запрос. Разница заключается в том, что здесь записи таблицы `Authors` не изменяется, а удаляется, поэтому и зависимые записи таблицы `Books` также удаляются

Если используется ключевое слово `SET NULL`, то при изменении или удалении данных в родительской таблице связанные записи в дочерней таблице в качестве значения внешнего ключа примут значение `NULL`
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE SET NULL
        ON DELETE SET NULL
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

UPDATE Authors
SET id = 3
WHERE id = 1;
```
как и после выполнения приведенного ниже запроса:
```sql
CREATE TABLE Authors
(
    id      INT PRIMARY KEY AUTO_INCREMENT,
    name    VARCHAR(40),
    surname VARCHAR(40)
);

CREATE TABLE Books
(
    id        INT PRIMARY KEY AUTO_INCREMENT,
    title     VARCHAR(40),
    author_id INT,
    FOREIGN KEY (author_id) REFERENCES Authors (id)
        ON UPDATE SET NULL
        ON DELETE SET NULL
);

INSERT INTO Authors (name, surname)
VALUES ('Stephen', 'King'),
       ('Joseph', 'Conrad');
       
INSERT INTO Books (title, author_id)
VALUES ('It', 1),
       ('Heart of Darkness', 2),
       ('Pet Sematary', 1);

DELETE FROM Authors
WHERE id = 1;
```
таблица `Books` будет иметь вид:
```
+----+-------------------+-----------+
| id | title             | author_id |
+----+-------------------+-----------+
| 1  | It                | NULL      |
| 2  | Heart of Darkness | 2         |
| 3  | Pet Sematary      | NULL      |
+----+-------------------+-----------+
```

В этих двух запросах, в отличие от двух примеров выше, используется ключевое слово `SET NULL`, поэтому изменение и удаление записи таблицы `Authors` приводит к тому, что связанные с ней записи таблицы `Books` в качестве значения внешнего ключа просто принимают значение `NULL`

Оператор `ON UPDATE` и `ON DELETE` можно  использовать как вместе, так и отдельно. Также каждый из операторов может задавать собственное поведение, например, `ON UPDATE` - `CASCADE`, а `ON DELETE` - `SET NULL`