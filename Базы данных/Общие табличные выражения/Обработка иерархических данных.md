#база_данных #реляционные #SQL #СУБД #WITH

##### База данных для примеров
Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Employees`, которая содержит информацию о сотрудниках некоторой компании:

```no-highlight
+----+----------+--------------+------------+
| id | name     | job          | manager_id |
+----+----------+--------------+------------+
| 1  | Matthew  | CEO          | NULL       |
| 2  | Caroline | CFO          | 1          |
| 3  | Tom      | CTO          | 1          |
| 4  | Sam      | Treasurer    | 2          |
| 5  | Ann      | Controller   | 2          |
| 6  | Anthony  | Dev Director | 3          |
| 7  | Lousie   | Sys Admin    | 3          |
| 8  | Travis   | Senior DBA   | 3          |
| 9  | John     | Developer    | 6          |
| 10 | Jennifer | Developer    | 6          |
| 11 | Maria    | Junior DBA   | 8          |
+----+----------+--------------+------------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — имя, третье -- должность, четвертое — идентификатор руководителя (также является сотрудником). Если у сотрудника нет руководителя, значением поля `manager_id` является `NULL`.
### Обработка иерархических данных
Данные в таблицах базы данных могут иметь совершенно произвольную структуру, и нередко - иерархическую. Примером таблицы с подобной организацией данных является таблица `Employees`, иерархия в которой выстраивается путем установления отношений руководитель-подчиненный между представленными в таблице сотрудниками.

Наиболее наглядно предложенная иерархия продемонстрирована на картинке ниже:
![[Pasted image 20250226143702.png]]Как видно из картинки, любой сотрудник может иметь ряд подчиненных, которые, в свою очередь, могут иметь своих подчиненных. Например, сотрудница по имени `Caroline` имеет в подчинении двух сотрудников: `Sam` и `Ann`. Более того, `Caroline` сама является подчиненной сотрудника по имени `Matthew`

Во время работы с подобного вида иерархическими данными достаточно удобными оказываются рекурсивные `CTE`. В качестве примера их использования напишем запрос, который определяет, на какой иерархической ступени располагается каждый сотрудник. Будем считать, что сотрудник, находящийся на вершине иерархии, занимает первую ступень, его подчиненные - вторую, и так далее.
```sql
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, name, 1 AS level
    FROM Employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT Employees.id, Employees.name, EmployeeHierarchy.level + 1
    FROM EmployeeHierarchy INNER JOIN Employees ON EmployeeHierarchy.id = Employees.manager_id
)

SELECT *
FROM EmployeeHierarchy;
```
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
| 4  | Sam      | 3     |
| 5  | Ann      | 3     |
| 6  | Anthony  | 3     |
| 7  | Lousie   | 3     |
| 8  | Travis   | 3     |
| 9  | John     | 4     |
| 10 | Jennifer | 4     |
| 11 | Maria    | 4     |
+----+----------+-------+
```
Проводя аналогию результата запроса с приведенной ранее картинкой. хорошо видно, что сотрудник по имени `Matthew` находится на первой иерархической ступени, его подчиненные `Caroline` и `Tom` - на второй, сотрудники `Sam`, `Ann`, `Anthony`, `Lousie` и `Travis`, являющиеся подчиненными `Caroline` или `Tom`, - на третьей, а `Jhon Jennifer` и `Maria` - не четвертой.

Теперь подробнее рассмотрим то, как именно получается данный результат. Тело используемого в примере рекурсивного **CTE** начинается с нерекурсивного запроса, который определяет сотрудника, находящегося на первой иерархической ступени. Таким сотрудником считается сотрудник, располагающийся на вершине иерархии и не имеющий руководителя. Затем следует рекурсивный запрос, с помощью которого определяется иерархическая принадлежность всех оставшихся сотрудников.

Для понимания того, каким образом происходит выполнение рекурсивного запроса, рассмотрим формирование содержимого **CTE** пошагово. Сначала выполняется нерекурсивны запрос, который определяет начальное содержимое **CTE**:
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
+----+----------+-------+
```
Затем выполняется рекурсивный запрос. В нем происходит внутреннее соединение результата выполнения нерекурсивного запроса и таблицы `Employees` с условием равенства полей `id` и `manager_id`, итогом которого является следующая таблица:
```
+----+---------+-------+----+----------+-----+------------+
| id | name    | level | id | name     | job | manager_id |
+----+---------+-------+----+----------+-----+------------+
| 1  | Matthew | 1     | 2  | Caroline | CFO | 1          |
| 1  | Matthew | 1     | 3  | Tom      | CTO | 1          |
+----+---------+-------+----+----------+-----+------------+
```
Задача этого соединения заключается в том, чтобы отобрать из таблицы `Employees` сотрудников, являющихся подчиненными сотрудника, находящего на первой ступени иерархии: отобранные сотрудники будут считаться сотрудниками второй ступени.

Далее рекурсивный запрос, работая с результатом соединения, извлекает таблицу следующего вида:
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```
Данная таблица дополняет текущее содержимое **CTE** , после чего оно принимает следующий вид:
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```
Следом рекурсивный запрос выполняется снова, однако в этот раз он работает с той таблицей, которую извлек при предыдущем выполнении:
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
+----+----------+-------+
```
В рекурсивном запросе происходит внутреннее соединение данной таблицы с таблицей `Employees` с тем же условием равенства полей `id` и `manager_id`, итогом которого является следующая таблица:
```
+----+----------+-------+----+---------+--------------+------------+
| id | name     | level | id | name    | job          | manager_id |
+----+----------+-------+----+---------+--------------+------------+
| 2  | Caroline | 2     | 4  | Sam     | Treasurer    | 2          |
| 2  | Caroline | 2     | 5  | Ann     | Controller   | 2          |
| 3  | Tom      | 2     | 6  | Anthony | Dev Director | 3          |
| 3  | Tom      | 2     | 7  | Lousie  | Sys Admin    | 3          |
| 3  | Tom      | 2     | 8  | Travis  | Senior DBA   | 3          |
+----+----------+-------+----+---------+--------------+------------+
```
Задача этого соединения заключается в том, чтобы отобрать из таблицы `Employees` сотрудников, являющихся подчиненными сотрудников, находящихся на второй ступени иерархии: отобранные сотрудники будут считаться сотрудниками третьей ступени.

Далее рекурсивный запрос, работая с результатом соединения, извлекает таблице следующего вида:
```
+----+---------+-------+
| id | name    | level |
+----+---------+-------+
| 4  | Sam     | 3     |
| 5  | Ann     | 3     |
| 6  | Anthony | 3     |
| 7  | Lousie  | 3     |
| 8  | Travis  | 3     |
+----+---------+-------+
```
Данная таблица дополняет текущее содержимое **CTE**, после чего оно принимает следующий вид:
```
+----+----------+-------+
| id | name     | level |
+----+----------+-------+
| 1  | Matthew  | 1     |
| 2  | Caroline | 2     |
| 3  | Tom      | 2     |
| 4  | Sam      | 3     |
| 5  | Ann      | 3     |
| 6  | Anthony  | 3     |
| 7  | Lousie   | 3     |
| 8  | Travis   | 3     |
+----+----------+-------+
```
Аналогичным образом рекурсивный запрос будет дополнять содержимое **CTE** до тех пор, пока вернут пустой результат. Поскольку рекурсивный запрос на каждом этапе выполняет соединение таблиц для поиска подчиненных определенных сотрудников, формирование содержимого **CTE** завершится в тот момент, когда рекурсивный запрос попытается найти подчиненных у тех сотрудников, у которых их нет

Помните, что в рекурсивном **CTE** рекурсивный запрос при втором и последующих вызовах работает с результатом, который был получен им же при предыдущем вызове.

В качестве следующего примера напишем запрос, который определяет иерархический путь до каждого сотрудника.
```sql
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, name,
           CONVERT(name, CHAR(100)) AS path
    FROM Employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT Employees.id, Employees.name,
           CONCAT(EmployeeHierarchy.path , ' -> ', Employees.name)
    FROM EmployeeHierarchy INNER JOIN Employees ON EmployeeHierarchy.id = Employees.manager_id
)
    
SELECT *
FROM EmployeeHierarchy;
```
```
+----+----------+---------------------------------------+
| id | name     | path                                  |
+----+----------+---------------------------------------+
| 1  | Matthew  | Matthew                               |
| 2  | Caroline | Matthew -> Caroline                   |
| 3  | Tom      | Matthew -> Tom                        |
| 4  | Sam      | Matthew -> Caroline -> Sam            |
| 5  | Ann      | Matthew -> Caroline -> Ann            |
| 6  | Anthony  | Matthew -> Tom -> Anthony             |
| 7  | Lousie   | Matthew -> Tom -> Lousie              |
| 8  | Travis   | Matthew -> Tom -> Travis              |
| 9  | John     | Matthew -> Tom -> Anthony -> John     |
| 10 | Jennifer | Matthew -> Tom -> Anthony -> Jennifer |
| 11 | Maria    | Matthew -> Tom -> Travis -> Maria     |
+----+----------+---------------------------------------+
```
Используемое в данном примере рекурсивное **CTE** практически повторяет предыдущее, разница заключается лишь в третьем поле `path`. Для каждого сотрудника в этом поле указывается его имя, а также имена всех руководителей в его иерархической цепи.

Не забывайте, что типы данных полей рекурсивного **CTE** определяются в нерекурсивном запросе