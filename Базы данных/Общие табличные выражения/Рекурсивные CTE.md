#база_данных #реляционные #SQL #СУБД #WITH 

**Рекурсивное обобщенное табличное выражение** или **рекурсивное CTE** - это **CTE** , содержимое которого последовательно формируется на основе самого себя. Тело рекурсивного **CTE** , в отличие от обычного **CTE** , включает два извлекающих запроса. Первый запрос используется для однозначного определения содержимого первой записи **CTE** , второй - для определения правила формирования всех остальных записей.

Запрос, определяющий первую запись **CTE** , обычно называют **нерекурсивным** ,  а запрос, описывающий процесс получения всех остальных записей, - **рекурсивным**

Содержимое каждой записи рекурсивного **CTE** , кроме первой, зависит только от содержимого предыдущей записи. Так, содержимое второй записи определяется на основе первой записи, содержимое третьей - на основе второй, и так далее. Например, если первая запись **CTE** включает число  `1`, а правило, определяющее оставшиеся записи **CTE** , имеет вид `<значение предыдущей записи> + 1`, то вторая запись будет включать число `2`, третья - `3`, и так далее.

Синтаксис создания рекурсивного **CTE** практически повторяет синтаксис создания обычного **CTE** и имеет следующий вид:
```css
WITH RECURSIVE <имя CTE> AS (
    <извлекающий запрос, определяющий первую запись CTE>
    <пара ключевых слов UNION ALL или UNION DISTINCT>
    <извлекающий запрос, определяющий правило формирования очередной записи CTE (второй, третьей, и так далее)>
)

<основной запрос, который может обращаться к рекурсивному CTE>
```
Как видно из шаблона, для создания рекурсивного **CTE** перед его именем необходимо указать ключевое слово `RECURSIVE`, а затем предоставить два извлекающих запроса, связав их либо парой ключевых слов `UNION ALL`, либо `UNION DISTINCT`. При использовании связки ключевых слов `UNION ALL` **CTE** будет включать повторяющиеся записи, если при формировании такие возникнут. При использовании `UNION DISTINCT` все повторяющиеся записи будут удалены.

### Примеры  использования рекурсивных CTE
**Пример 1** Напишем запрос, который генерирует последовательность из целых чисел от `1` до `10` включительно
```sql
WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number                         -- нерекурсивный запрос
    UNION ALL
    SELECT number + 1                          -- рекурсивный  запрос
    FROM NaturalNumbers
    WHERE number < 10
)

SELECT *
FROM NaturalNumbers;
```
```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 3      |
| 4      |
| 5      |
| 6      |
| 7      |
| 8      |
| 9      |
| 10     |
+--------+
```
В примере выше генерация последовательности выполняется при помощи рекурсивного **CTE** `NaturalNumbers`, тело которого включает два запроса: нерекурсивный и рекурсивный. Нерекурсивный запрос определяет содержимое  первой записи **CTE**. Рекурсивный запрос описывает правило формирования второй, третьей и всех последующих записей **CTE**. Поскольку содержимое **CTE** формируется на основе самого себя, извлечение в рекурсивном запросе выполняется из самого **CTE**.

Для понимания того, каким образом происходит выполнение рекурсивного запроса, рассмотрим формирование содержимого **CTE** пошагово. Сначала выполняется нерекурсивный запрос, который определяет начальное содержимое **CTE**:
```
+--------+
| number |
+--------+
| 1      |
+--------+
```
Затем выполняется рекурсивный запрос. Работая с результатом выполнения нерекурсивного запроса, он извлекает таблице следующего вида:
```
+--------+
| number |
+--------+
| 2      |
+--------+
```
Данная таблица дополняет начальное содержимое **CTE** , после чего оно принимает следующий вид:
```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```
Следом рекурсивный запрос выполняется снова, однако в этот раз он работает с той таблицей, которую извлек при предыдущем выполнении:
```
+--------+
| number |
+--------+
| 2      |
+--------+
```
Работая со своим предыдущим результатом, рекурсивный запрос извлекает таблице следующего вида:
```
+--------+
| number |
+--------+
| 3      |
+--------+
```
Аналогичным образом рекурсивный запрос будет дополнять содержимое **CTE** до тех пор, пока не вернут **пустой результат**. Поскольку рекурсивный запрос содержит условие `WHERE number < 10`, формулирование содержимого **CTE** завершится в тот момент, когда второй запрос попытается сгенерировать запись с числом `11`

Нерекурсивный и рекурсивный запросы в рекурсивном **CTE** должны извлекать таблицы с равным количеством полей.

**Пример 2** Напишем запрос, который генерирует последовательность из первых десяти нечетных целых чисел.
```sql
WITH RECURSIVE OddNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 2
    FROM OddNumbers
    LIMIT 10
)

SELECT *
FROM OddNumbers;  
```
```
+--------+
| number |
+--------+
| 1      |
| 3      |
| 5      |
| 7      |
| 9      |
| 11     |
| 13     |
| 15     |
| 17     |
| 19     |
+--------+
```
Пример выше демонстрирует альтернативный способ завершения формирования содержимого **CTE** - с помощью ключевого слова `LIMIT`. При использования данного ключевого слова рекурсивный запрос не обязан возвращать пустой результат, формирование содержимого **CTE** автоматически завершится в тот момент, когда сгенерированное количество записей станет равным числу, указанному после `LIMIT`

**Пример 3** Напишем запрос, который генерирует последовательность из первых десяти степеней числа `2`
```sql
WITH RECURSIVE PowersOfTwo AS (
    SELECT 1 AS degree,                        -- показатель степени
           2 AS power                          -- значение в соответствующей степени
    UNION ALL
    SELECT degree + 1,                         -- увеличиваем показатель степени на единицу
           power * 2                           -- возводим число в следующую степень
    FROM PowersOfTwo
    LIMIT 10
)

SELECT *
FROM PowersOfTwo;
```
```
+--------+-------+
| degree | power |
+--------+-------+
| 1      | 2     |
| 2      | 4     |
| 3      | 8     |
| 4      | 16    |
| 5      | 32    |
| 6      | 64    |
| 7      | 128   |
| 8      | 256   |
| 9      | 512   |
| 10     | 1024  |
+--------+-------+
```

**Пример 4** Напишем запрос, который генерирует последовательность из первых десяти числе Фибоначчи
```sql
WITH RECURSIVE Fibonacci AS (
    SELECT 1 AS fib_prev,                      -- предыдущее число Фибоначии
           1 AS fib_cur                        -- текущее число Фибоначии
    UNION ALL  
    SELECT fib_cur,                            -- заменяем предыдущее число текущим
           fib_cur + fib_prev                  -- прибавляем к текущему числу предыдущее
    FROM Fibonacci
    LIMIT 10
)

SELECT fib_prev AS number
FROM Fibonacci;
```
```
+--------+
| number |
+--------+
| 1      |
| 1      |
| 2      |
| 3      |
| 5      |
| 8      |
| 13     |
| 21     |
| 34     |
| 55     |
+--------+
```

### Примечания
**Примечание 1** Если при определении **рекурсивного** **CTE** пропустить ключевое слово `RECURSIVE`, произойдет ошибка
```sql
WITH NaturalNumbers AS (                       -- ключевое слово RECURSIVE не указано
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1                          
    FROM NaturalNumbers
    WHERE number < 10
)

SELECT *
FROM NaturalNumbers;
```
```
ERROR 1146: Table 'NaturalNumbers' doesn't exist
```
Если при определении **нерекурсивного** **CTE** указать ключевое слово `RECUTSIVE`, ошибки не будет
```sql
WITH RECURSIVE NaturalNumbers AS (             -- ключевое слово RECURSIVE указано
    SELECT 1 AS number
    UNION ALL
    SELECT 2                          
)

SELECT *
FROM NaturalNumbers;
```
```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```

**Примечание 2** В рекурсивном запросе рекурсивного **CTE** не могут использоваться агрегатные функции, а также операторы `GROUP BY`, `ORDER BY` и `DISTINCT`

**Примечание 3** Определить названия полей рекурсивного **CTE** можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия **CTE**
```sql
WITH RECURSIVE PowersOfTwo(degree, power) AS (
    SELECT 1,                                  -- поле degree
           2                                   -- поле power
    UNION ALL
    SELECT degree + 1,
           power * 2
    FROM PowersOfTwo
    LIMIT 10
)

SELECT *
FROM PowersOfTwo;
```
```
+--------+-------+
| degree | power |
+--------+-------+
| 1      | 2     |
| 2      | 4     |
| 3      | 8     |
| 4      | 16    |
| 5      | 32    |
| 6      | 64    |
| 7      | 128   |
| 8      | 256   |
| 9      | 512   |
| 10     | 1024  |
+--------+-------+
```

**Примечание 4** Типы данных полей рекурсивного **CTE** определяются в нерекурсивном запросе. Об этом полезно помнить в том случае, когда **CTE** имеет строковое поле, поскольку в рекурсивном запросе могут происходить попытки добавить в поле строки, длина которых превышает поддерживаемые полем значения
```sql
WITH RECURSIVE Beegeek AS (
    SELECT 'bee' AS field                      -- трехсимвольное строковое поле
    UNION ALL
    SELECT CONCAT(field, field)
    FROM Beegeek
    LIMIT 5
)

SELECT *
FROM Beegeek;
```
```
ERROR 1406: Data too long for column 'field' at row 1
```
В примере выше тип данных поля `field` рекурсивного **CTE** `Beegeek` определяется как строковое и трехсимвольное, потому что значение именно такого формата добавляется в поле первым. Последующие попытки добавить в поле `field` новые строки приводят к ошибке, поскольку их длина больше трех

Для решения данной проблемы перед добавлением значения в поле `field` можно сконвертировать его в более широкий тип, напрмер, с помощью функции `CONVERT()`
```sql
WITH RECURSIVE Beegeek AS (
    SELECT CONVERT('bee', CHAR(50)) AS field   -- пятидесяти символьное строковое поле
    UNION ALL
    SELECT CONCAT(field, field)
    FROM Beegeek
    LIMIT 5
)

SELECT *
FROM Beegeek;
```
```
+--------------------------------------------------+
| field                                            |
+--------------------------------------------------+
| bee                                              |
| beebee                                           |
| beebeebeebee                                     |
| beebeebeebeebeebeebeebee                         |
| beebeebeebeebeebeebeebeebeebeebeebeebeebeebeebee |
+--------------------------------------------------+
```

**Примечание 5** По умолчанию рекурсивный запрос в рекурсивном **CTE** может выполнить не более `1000` итераций.
```sql
WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1
    FROM NaturalNumbers
    LIMIT 2000                                 -- ограничение в 2000 записей
)

SELECT *
FROM NaturalNumbers;
```
```
ERROR 3636: Recursive query aborted after 1001 iterations. Try increasing @@cte_max_recursion_depth to a larger value.
```
Увеличив значение системной переменной `cte_max_recursion_depth`, отвечающей за максимально допустимое количество итераций рекурсивного запросе. данное ограничение можно обойти
```sql
SET @@cte_max_recursion_depth := 10000;

WITH RECURSIVE NaturalNumbers AS (
    SELECT 1 AS number
    UNION ALL
    SELECT number + 1
    FROM NaturalNumbers
    LIMIT 2000
)

SELECT *
FROM NaturalNumbers;
```
```no-highlight
+--------+
| number |
+--------+
| 1      |
| 2      |
| 3      |
| 4      |
| 5      |
| ...    |
| 1996   |
| 1997   |
| 1998   |
| 1999   |
| 2000   |
+--------+
```

**Примечание 6** Доступ к полям в рекурсивном запросе **CTE** осуществляется по имени, а не по положению
```sql
WITH RECURSIVE Numbers AS (
    SELECT 1 AS a,                             -- начальное значение первого поля
           -1 AS b                             -- начальное значение второго поля
    UNION ALL
    SELECT b * 2,                              -- значение первого поля берется из второго поля и умножается на 2
           a * 2                               -- значение второго поля берется из первого поля и умножается на 2
    FROM Numbers
    LIMIT 5
)

SELECT *
FROM Numbers;
```
```
+----+-----+
| a  | b   |
+----+-----+
| 1  | -1  |
| -2 | 2   |
| 4  | -4  |
| -8 | 8   |
| 16 | -16 |
+----+-----+
```

**Примечание 7** Нерекурсивный запрос в рекурсивном **CTE** может извлекать не только одну запись, но и несколько. В таком случае формирование содержимого **CTE** будет выполняться блоками по несколько записей
```sql
WITH RECURSIVE Numbers AS (
    SELECT 1 AS number
    UNION
    SELECT 2
    
    UNION ALL
    
    SELECT number + 1
    FROM Numbers
    LIMIT 10
)

SELECT *
FROM Numbers;
```
```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 2      |
| 3      |
| 3      |
| 4      |
| 4      |
| 5      |
| 5      |
| 6      |
+--------+
```
Здесь нерекурсивный запрос определяет начальное содержимое **CTE** следующим образом:
```
+--------+
| number |
+--------+
| 1      |
| 2      |
+--------+
```
Затем рекурсивный запрос, работая с результатом выполнения нерекурсивного запросе, извлекает таблице следующего вида:
```
+--------+
| number |
+--------+
| 2      |
| 3      |
+--------+
```
Данная таблица дополняет начальное содержимое CTE, после чего оно принимает следующий вид:
```
+--------+
| number |
+--------+
| 1      |
| 2      |
| 2      |
| 3      |
+--------+
```
Аналогичным образом рекурсивный запрос дополняет содержимое CTE до тех пор, пока количество записей в нем не станет равным `10`.