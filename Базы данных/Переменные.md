#база_данных #реляционные #SQL #СУБД 

##### База данных для примеров
Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Books`, которая содержит информацию о десяти различных книгах, размещенных в некотором интернет-магазине:
```
+----+------------------------------------------+---------------------+-------+
| id | title                                    | author              | price |
+----+------------------------------------------+---------------------+-------+
| 1  | The Shining                              | Stephen King        | 7.99  |
| 2  | Fight Club                               | Chuck Palahniuk     | 9.99  |
| 3  | The Catcher in the Rye                   | J.D. Salinger       | 3.49  |
| 4  | The Green Mile                           | Stephen King        | 15.99 |
| 5  | The Great Gatsby                         | F. Scott Fitzgerald | 7.99  |
| 6  | The Lord of the Rings                    | J.R.R. Tolkien      | 19.99 |
| 7  | It                                       | Stephen King        | 12.99 |
| 8  | The Silmarillion                         | J.R.R. Tolkien      | 11.99 |
| 9  | Haunted                                  | Chuck Palahniuk     | 13.99 |
| 10 | Harry Potter and the Prisoner of Azkaban | J.K. Rowling        | 9.99  |
+----+------------------------------------------+---------------------+-------+
```
Первое поле этой таблицы содержит идентификатор книги, второе — название, третье — данные об авторе, четвертое — цену книги в долларах.
### Переменные
**Переменная** в программировании - это именованная область памяти, которая хранит определенные данные и позволяет неоднократно к ним обращаться. С помощью переменных можно сохранять значения, полученные во время промежуточных вычислений, выполнять операции с этими значениями и предавать их между различными частями программы.

Каждая переменная имеет **уникальное имя**, по которому к ней можно обращаться. конкретные данные, которые хранятся в переменной, называют **значением** переменной

Многие языки программирования поддерживают работу с переменными, и `SQL` не является исключении. В `SQL` выделяют два типа переменных: **системные** и **пользовательские**. Системные переменные используются для хранения технической информации и для настройки различных аспектов работы **СУБД**. Примером системной переменной является переменная `version`, с помощью которой можно узнать версию установленной **СУБД**.

Пользовательские переменные, в отличие от системных, определяются программистом, а не **СУБД**, и используются при составлении запросов для определенных целей. Например, они могут хранить значения, полученные во время выполнения промежуточных запросов, или различного вида константные значения, которые часто повторяются в запросах
### Пользовательские переменные
Создание пользовательской переменной и присвоение ей значения выполняется с помощью операторов `SET` и `:=`. Сначала следует оператор `SET`, а затем между оператором `:=` указываются имя переменной и ее значение.

В результате выполнения приведенного ниже запроса:
```sql
SET @variable := 1;
```
будет создана пользовательская переменная с именем `variable` и значением `1`.

Обратите внимание, что перед именем пользовательской переменной располагается знак `@`. Его необходимо использовать при создании любой пользовательской переменной и при каждом обращении к ней, поскольку он подсказывает **СУБД** о том, что следующее за знаком `@` имя следует расценивать исключительно как имя пользовательской переменной, а не поля, таблицы или какого-либо другого объекта

Имя пользовательской переменной может включать буквенно-цифровые символы, точку (`.`), нижнее подчеркивание (`_`) и знак доллара (`$`). Максимальное количество  символов в имени переменной равняется `64`.

Чтобы воспользоваться пользовательской переменной после ее определения достаточно обратиться к ней по ее имени.
```sql
SET @variable := 1;
    
SELECT @variable;
```
```
+-----------+
| @variable |
+-----------+
| 1         |
+-----------+
```
Значением пользовательской переменной необязательно должно быть явно определенное значение, это может быть результат некоторого вычисления или возвращаемое значение функции.
```sql
SET @variable := SQRT(2);
    
SELECT @variable;
```
```
+--------------------+
| @variable          |
+--------------------+
| 1.4142135623730951 |
+--------------------+
```
Пользовательские переменные нечувствительны к регистру, поэтому, например, к переменной с именем `variable` можно обратиться как с использованием имени `variable`, так и `Variable` или `VARIABLE`.
```sql
SET @variable := 1;
    
SELECT @variable, @Variable, @VARIABLE;
```
```
+-----------+-----------+-----------+
| @variable | @Variable | @VARIABLE |
+-----------+-----------+-----------+
| 1         | 1         | 1         |
+-----------+-----------+-----------+
```
Внутри одного блока `SET` можно определить как одну пользовательскую переменную, так и несколько. Во втором случае достаточно перечислить определение каждой переменной через запятую
```sql
SET @variable1 := 1,
    @variable2 := 2;
```
будут созданы пользовательские переменные с именами `variable1` и `variable2` и значениями `1` и `2` соответственно.

Пользовательские переменные могут участвовать в математических выражениях, операциях сравнения, функция в  качестве аргументов и использоваться в контексте запроса как любые другие значения
```sql
SET @min_price := 7.99,
    @max_price := 9.99;
    
SELECT title, price
FROM Books
WHERE price BETWEEN @min_price AND @max_price;
```
```
+------------------------------------------+-------+
| title                                    | price |
+------------------------------------------+-------+
| The Shining                              | 7.99  |
| Fight Club                               | 9.99  |
| The Great Gatsby                         | 7.99  |
| Harry Potter and the Prisoner of Azkaban | 9.99  |
+------------------------------------------+-------+
```
Запрос выше извлекает данные о тех книгах, цена которых заключена между `7.99` и `9.99` долларами, при этом левая граница цены определяется переменной `@min_prive`, а правая - `@max_price`. В данном случае использование пользовательских переменных удобно тем, что при необходимости изменить правую или левую границе цены будет достаточно изменить значение соответствующей переменной, не изменяя при этом сам извлекающий запрос

### Присвоение переменным данных из таблиц
Значением пользовательской переменной может являться не только вычисляемое значение, но и результат выполнения запроса.
```sql
SET @min_price := (SELECT MIN(price)
                   FROM Books);
    
SELECT @min_price;
```
```
+------------+
| @min_price |
+------------+
| 3.49       |
+------------+
```
В примере выше определяется переменная `@min_prive`, которой в качестве значения присваивается минимальное значение поля `price` таблицы `Books`. Обратите внимание, что если при определении значения пользовательской переменной используется запрос, то он должен быть заключен в круглые скобки.

Запрос, определяющий значение пользовательской переменой всегда должен возвращать одиночное значение (одно поле и одна запись), в противном случае произойдет ошибка
```sql
SET @min_price := (SELECT price
                   FROM Books);
    
SELECT @min_price;
```
```
ERROR 1242: Subquery returns more than 1 row
```

Определить пользовательскую переменную можно прямо внутри извлекающего запроса в блоке оператора `SELECT` без использования ключевого слова `SET`
```sql
SELECT MIN(price) INTO @min_price
FROM Books;

SELECT @min_price;
```
```
+------------+
| @min_price |
+------------+
| 3.49       |
+------------+
```
Внутри одного блока `SELECT` можно определить как одну пользовательскую переменную, так и несколько.
```sql
SELECT MIN(price), MAX(price) INTO @min_price, @max_price
FROM Books;

SELECT @min_price, @max_price;
```
```
+------------+------------+
| @min_price | @max_price |
+------------+------------+
| 3.49       | 19.99      |
+------------+------------+
```

Обратите внимание на то, что при определении пользовательских переменных с помощью оператора `SELECT`, запрос всегда должен возвращать одну запись, в противном случае произойдет ошибка
```sql
SELECT price INTO @min_price
FROM Books;

SELECT @min_price;
```
```
ERROR 1172: Result consisted of more than one row
```

### Системные переменные
Системные переменные используются для хранения информации и настройки параметров **СУБД** в соответствии с требованиями конкретного пользователя или приложения. Например. уже упомянутая ранее системная переменная `version` используется для получения версии установленной **СУБД**, а, скажем, переменная `sort_buffer_size` определяет размер буфера, выделяемого при выполнении операции сортировки

Как и в случае с пользовательскими переменными, при обращении к системным переменным используется специальный префикс из двух знаков `@`, который подсказывает **СУБД** о том, что следующее за знаками имя следует воспринимать исключительно как имя системной переменной
```css
SELECT @@version;
```
```
+-----------+
| @@version |
+-----------+
| 8.0.27    |
+-----------+
```
Запрос выше обращается к системной переменной с именем `version` и извлекает ее значение.

Системные переменные делятся на два вида: **глобальные** и **сессионные**. Глобальные переменные определяет администратор базы данных. Такие переменные создаются во время запуска базы данных, и для всех пользователей, которые в будущем подключатся к ней для работы, значения глобальных переменных будут равны и изменить их они не смогут.

Сессионные переменные создаются во время каждого подключения к базе данных, и их значения пользователям изменять допускается. Важно понимать, что сессионные переменные создаются для каждого подключения отдельно, и если один пользователь изменить значение сессионной переменной, то у других пользователей оно не изменится.

С полным списком системных переменных и их описанием можно ознакомиться по [ссылке](https://vds-admin.ru/mysql/sistemnye-peremennye-mysql-servera-fail-mycnf)

Обладая правами администратора, с системной переменной можно работать как глобально, так и сессионно. Чтобы определить значение глобальной переменной, при обращении к ней перед именем необходимо указать префикс `global`
```sql
SET @@global.sort_buffer_size := 262146;
```
значение глобальной переменной `sort_buffer_size` будет равняться `262146`.

При изменении глобальной переменной префикс `global.` необходимо по той причине, что по умолчанию обращение происходит к сессионной переменной, и если, например, в запросе выше данные префикс убрать, то значение переменной `@@sort_buffer_size` будет изменено лишь в рамках сессии, даже если запрос выполняется администратором.

```sql
SET @@sort_buffer_size := 262146;
```
значение сессионной переменной `sort_buffer_size` будет равняться `262146`.

Указать, что обращение происходит именно к сессионной переменной, можно не только опустив префикс `global.`, но и добавив префикс `session.`.

```sql
SET @@session.sort_buffer_size := 262146;
```
значение сессионной переменной `sort_buffer_size` будет равняться `262146`.

Используя префиксы `global.` и `session.`, можно получить как глобальное значение системной переменной, так и сессионное.
```sql
SET @@session.sort_buffer_size := 262146;

SELECT @@global.sort_buffer_size,     -- глобальное значение
       @@session.sort_buffer_size;    -- сессионное значение
```
```
+---------------------------+----------------------------+
| @@global.sort_buffer_size | @@session.sort_buffer_size |
+---------------------------+----------------------------+
| 262144                    | 262146                     |
+---------------------------+----------------------------+
```

### Создание переменных через `SELECT...INTO`
Для создания переменных мы можем использовать оператор `INTO`, который помещается прямо в тело запроса `SELECT`. 
```MySQL
SELECT title, author, price
  INTO @title, @author, @price
  FROM Directors
 WHERE autor = 'J.K. Rowling'
```
В результате такого запроса будут созданы переменные `@title`, `@aurot`, `@price`. Присваиваются они по позиционному принципу из переменных, которые были запрошены в `SELECT`

### Примечания
**Примечание 1** Попытка определить пользовательскую переменную, имя которой совпадает с именем существующей переменной, приведет к переопределению переменной, а не к ошибке
```sql
SET @variable := 1;
SET @variable := 2;

SELECT @variable;
```
```
+-----------+
| @variable |
+-----------+
| 2         |
+-----------+
```

**Примечание 2** Пользовательские переменные нельзя использовать в блоке оператора `LIMIT` для ограничения количества извлекаемых записей
```sql
SET @limitvalue := 5;

SELECT *
FROM Books
LIMIT @limitvalue;
```
```
ERROR 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@limitvalue' at line 3
```

**Примечание 3** Пользовательская переменная, определенная одним пользователем, не видна другим пользователям. Другими словами, пользовательская переменная является специфичной для сессии.

**Примечание 4** Значением пользовательской переменной может быть значение из ограниченного набора типов данных: целое число, число с плавающей точкой, число с фиксированной точкой, строка или значение `NULL`. Если переменной присваивается значение иного типа, например, дата, то оно автоматически будет преобразовано в строковое

**Примечание 5** При определении пользовательской переменной с помощью ключевого слова `SET` допустимо использовать оператор `=`
```sql
SET @variable = 1;
```

## PostgreSQL
В `PostgreSQL` нет поддержки пользовательских переменных, поэтому приходится пользоваться иными синтаксическими методами, например:

Переведем этот **MySQL** код на **PostgreSQL**
```MySQL
set @number = 2361822;
select @number;
```
```
+-----------+
| @number   |
+-----------+
| 2361822   |
+-----------+
```
Через **CTE**:
```PostgreSQL
WITH number AS (
    SELECT 2361822 AS num
)
SELECT num FROM number;
```
```
+-----------+
| num       |
+-----------+
| 2361822   |
+-----------+
```
Естественно, хранить в рамках одного **CTE** можно сколько угодно переменных

Через `DO` блоки:
```PostgreSQL
DO $$ 
DECLARE 
    number TEXT;
BEGIN
    number := 2361822;
    RAISE NOTICE number;
END $$;
```