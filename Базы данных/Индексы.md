#база_данных #реляционные #SQL #СУБД 

##### Таблица для примера
```
+----+---------------------------------------------------+-----------------+--------------+
| id | title                                             | author          | release_year |
+----+---------------------------------------------------+-----------------+--------------+
| 1  | Fight Club                                        | Chuck Palahniuk | 1996         |
| 2  | The Green Mile                                    | Stephen King    | 1996         |
| 3  | The Lord of the Rings: The Fellowship of the Ring | J.R.R. Tolkien  | 1954         |
| 4  | It                                                | Stephen King    | 1986         |
| 5  | The Lord of the Rings: The Two Towers             | J.R.R. Tolkien  | 1954         |
| 6  | Harry Potter and the Prisoner of Azkaban          | J.K. Rowling    | 1999         |
+----+---------------------------------------------------+-----------------+--------------+
```
### Индексы
Индексы - структура данных, предназначенная для ускорения поиска и сортировки данных. Индексы позволяют быстро находить нужные записи таблицы на основе значений одного или нескольких полей. Без индексов поиск данных в больших таблицах может быть медленным и ресурсоемким, поскольку подразумевает просмотр всей таблицы от первой записи до последней
#### Кластеризованные индексы
**Кластеризизованные индексы** хранят записи таблицы, отсортированные по их **ключевым** значениям. Эти ключевые значения - это поля, включенные в определение индекса. Существует только один кластеризованный индекс для каждой таблицы, так как записи могут храниться в единственном порядке.

**СУБД** использует первичный ключ для определения порядка хранения записей в кластеризованном индексе. Если первичный ключ отсутствует, **СУБД** автоматически выбирает в качестве первичного ключа перовое **уникальное непустое** поле таблицы и впоследствии также использует его для определения порядка хранения записей в индексе. Если таблица не имеет ни первичного ключа, ни уникального непустого поля, **СУБД** генерирует скрытое суррогатное (синтетическое) поля для хранения целочисленных идентификаторов записей и использует его в качестве первичного ключа.

Кластеризованный индекс организует  **физический порядок** хранения записей таблицы. Это означает, что записи, имеющие близкие ключевые значения, также будут близко расположены в памяти. Данная особенность кластеризованного индекса обеспечивает быстрый поиск записей (посредством бинарного поиска) по значениям первичного ключа, особенно по диапазонным значениям.

Однако плотное хранение записей является как преимуществом, так и недостатком. Например, добавление новых записей или обновление существующих может потребовать переупорядочивания данных, что может быть затратно по времени

### Некластеризованныые индексы
Кластеризованный индекс позволяет выполнять быстрый поиск и сортировку записей таблицы, однако лишь на основе значений первичного ключа. Для применения преимуществ кластеризованного индекса к любому полю таблицы используется **некластеризованные индексы**.

Некластеризованный индекс представляет собой структуру данных, которая содержит **уникальные** значения поля таблицы, указанного в качестве индекса. Каждое значение некластеризованного индекса связано со всеми записями таблицы, которые имеют  такое же значение в индексированном поле. Также для дополнительной эффективности некластеризованный индекс хранит значения индексированного поля в **упорядоченном** виде.
![[Pasted image 20250211133044.png]]
Сам некластеризованный индекс хранится отдельно от таблицы в качестве самостоятельного объекта и содержит лишь значения индексированного поля и ссылки на соответствующие записи. Это означает, что данные таблицы могут быть организованны на диске в произвольном порядке, но некластеризованный индекс все равно позволит эффективно находить нужные записи.

Таким образом, основная идея некластеризованного индекса состоит в том, чтобы создать вспомогательную структуру данных, связанную с некоторым поем таблицы и ее записями, которая обеспечит быстрый поиск и сортировку записей таблицы по данному полю.

В отличие от кластеризованных, некластеризованные индексы могут создаваться в любом количестве.
### Создание индексов
Кластеризованный индекс не требует создания, поскольку им обладает любоя таблица. Поэтому в **SQL** вручную можно создать лишь  некластеризованный индекс. Для этого используется оператор `CREATE INDEX`, синтаксис которого имеет следующий вид:
```sql
CREATE INDEX <имя некластеризованного индекса> ON <имя таблицы>(<имя индексируемого поля>);
```
Предположим, мы хотим создать для таблицы `Books` некластеризованный индекс с именем `idx_release_year` на основе поля `release_year`. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:
```sql
CREATE INDEX idx_release_year 
ON Books(release_year);
```
Если изображать структуру `idx_release_year` схематично:
![[Pasted image 20250211134052.png]]Стоит обратить внимание  на то, что в некластеризованном индексе `idx_release_year` данные хранятся уполрядоченно, в то время как в таблице порядок зависит от кластеризованного индекса и может отличаться

Теперь рассмотрим, как **СУБД** будет выполнять поиск записей в таблице `Books`, если она имеет предложенный выше индекс `idx_release_year`. Представим, что мы хотим получить все названия книг, которые были выпущены в `1996` году:
```sql
SELECT title 
FROM Books 
WHERE release_year = 1996;
```
Поскольку поиск выполняется по индексированному полю `relese_year`, сперва **СУБД** перейдет к соответствующему некластеризованному индексу `idx_release_year`. Затем она получит ссылки на все записи, которые в качестве значения индексированного поля содержат число `1996`. Это записи с индетификаторами `1` и `2`, которые будут результатом поиска.

Некластеризованный индекс может быть создан на основе как одного поля, так и нескольких. Например, если нам часто приходится искать книги различных авторов, выпущенных в конкретном году, мы можем определить некластеризованный индекс на основе полей `autor` и `releasse_year`, чтобы ускорить подобный поиск. Запрос, выполняющий эту операцию, будет выглядеть следующим образом:
```sql
CREATE INDEX idx_author_release_year
ON Books(author, release_year);
```
Если схематично изобразить структуру индекса `idx_author_release_year`, то она будет иметь следующий вид:
![[Pasted image 20250211135218.png]]Несложно заметить, что в некластеризованном индексе `idx_author_release_year` данные также хранятся упорядоченно, в то время как в таблице порядок зависит от кластеризованного индекса и может отличаться.

Некластеризованный индекс хранит все значения индексированного поля, с помощью которого ссылается на любые записи таблицы. Поэтому чем больше количество полей в индексе, тем больше памяти он занимает.
### Удаление и переименование индексов
Удаление индекса выполняется практически так же, как и добавление. Разница заключается лишь в том, что вместо оператора `CREATE INDEX` нужно указать оператор `DROP INDEX`.

Предположим, наша таблица `Books` имеет некластеризованный индекс с именем `idx_release_year` и мы хотим его удалить. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:
```sql
DROP INDEX idx_release_year ON Books;
```
Для переименования индекса используется связка операторов `ALERT TABLE` и `RENAME INSEX`, синтаксис которых имеет следующий вид:
```sql
ALTER TABLE <имя таблицы>
RENAME INDEX <текущее имя индекса> TO <новое имя индекса>;
```
Предположим, наша таблица `Books` имеет некластеризованный индекс с именем `idx_release_year` и мы хотим изменить его имя на `release_year_index`. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:
```sql
ALTER TABLE Books
RENAME INDEX idx_release_year TO release_year_index;
```
### Сравнение производительности
Чтобы убедиться в преимуществе использования индексов, мы провели ряд тестов на на таблице `Books`. добавив в нее 1000, 10000, 100000 и 1000000 записей. для тестирования мы использовали следующий запрос, который выполняли на каждом количестве записей:
```sql
SELECT title
FROM Books
WHERE release_year = 1996;
```
Изначально у таблицы `Books` отсутствует некластеризованный индекс, поэтому при выполнении данного запроса **СУБД** просматривает таблицу от начала до конца и добавляет в выборку те записи, которые удовлетворяют условию

Время, за которое выполняется запрос без использования индекса, представлено в таблице ниже:

| **Количество записей** | **Время выполнения запроса (в секундах)** |
| ---------------------- | ----------------------------------------- |
| 1000                   | 0.0005                                    |
| 10000                  | 0.0016                                    |
| 100000                 | 0.015                                     |
| 1000000                | 0.15                                      |
После создания индекса на основе поля `release_year` поиск по этому полю будет осуществляться гораздо быстрее, так как нужно просматривать не каждую запись, а только те, у которых значение поля `relese_year` равняется `1996`. **СУБД** найдет это значение в индексе всего за несколько шагов, после чего просто вернет все записи, на которые это значение указывает

Время, за которое выполняется запрос при использовании индекса, представлено в таблице ниже:

| **Количество записей** | **Время выполнения запроса (в секундах)** |
| ---------------------- | ----------------------------------------- |
| 1000                   | 0.0003                                    |
| 10000                  | 0.0006                                    |
| 100000                 | 0.003                                     |
| 1000000                | 0.03                                      |
Несложно заметить, что выполнение запроса ускорилось в несколько раз. При этом чем больше количество записей, тем заметнее будет разница
### Примечания
#### Примечание 1.
Индексы не стоит использовать для тех полей, которые редко используются при фильтрации записей, а также тех, которые часто обновляются
#### Примечание 2.
Индексы ускоряют выполнение операции извлечения, однако при этом они могут замедлить операции вставки, обновления и удаления, так как эти операции требуют обновления индексов.
#### Примечание 3.
В **SQL** индексы представляют собой структуру данных, которая называется **сбалансированное дерево** или **B-Tree**. Почитать подробнее о **B-Tree** можно по [ссылке](https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
#### Примечание 4.
При использовании индексов на основе нескольких полей важно понимать, что их эффективность будет зависеть от того, по каким полям осуществляется фильтрация. Например, если мы создадим индекс для таблицы `Books` на основе полей `author` и `release_year`, то сможем эффективно использовать фильтрацию либо по этим двум полям, либо по полю `author`, так как их значения в индексе будут упорядочены. Значения поля `release_year` в индексе могут быть не упорядочены, поэтому СУБД в любом случае будет просматривать их все.
#### Примечание 5.
 Если необходимо получить информацию об индексах таблицы, можно воспользоваться оператором `SHOW INDEX`, синтаксис которого имеет следующий вид:
```sql
SHOW INDEX FROM <имя таблицы>;
```
Результатом приведенного ниже запроса:
```sql
SHOW INDEX FROM Books;
```
является:
```
+-------+------------+-------------------------+--------------+--------------+ ... +---------+------------+
| Table | Non_unique | Key_name                | Seq_in_index | Column_name  | ... | Visible | Expression |
+-------+------------+-------------------------+--------------+--------------+ ... +---------+------------+
| books | 0          | PRIMARY                 | 1            | id           | ... | YES     | NULL       |
| books | 1          | idx_release_year        | 1            | release_year | ... | YES     | NULL       |
| books | 1          | idx_author_release_year | 1            | author       | ... | YES     | NULL       |
| books | 1          | idx_author_release_year | 2            | release_year | ... | YES     | NULL       |
+-------+------------+-------------------------+--------------+--------------+ ... +---------+------------+
```