#база_данных #реляционные #SQL #СУБД #WHERE #BETWEEN

```
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | NULL         |
| 2  | 3     | My Lover             | The Sounds | 99488   | NULL         |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+-------+----------------------+------------+---------+--------------+
```
##### Скрипт создания таблицы для примера:
```MySQL
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO Songs (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, NULL),
       (3, 'My Lover', 'The Sounds', 99488, NULL),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-10'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-09-19');
```
```PostgreSQL
DROP TABLE IF EXISTS "Songs";
CREATE TABLE "Songs"
(
    id           SERIAL PRIMARY KEY,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO "Songs" (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, NULL),
       (3, 'My Lover', 'The Sounds', 99488, NULL),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-10'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-09-19');
```


### Оператор WHERE
Оператор `WHERE` позволяет задавать определенные условия при извлечении записей. Если запись удовлетворяет условиям, она попадает в результирующую таблицу.
```PostgreSQL
SELECT *
FROM "Songs"
WHERE artist = 'The Sounds';
```
```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
+----+----------+-----------+------------+---------+--------------+
```
В этом примере используется проверка на равенство. Запрос извлекает все поля таблицы, но возвращает не все записи, а только те, значение поля `artist` которых равно строка `The Sounds`

Так же стоит обратить внимание, что на оператор `WHERE` располагается после названия таблицы. Если в запросе так же есть оператор `ORDER BY`, оператор `WHERE` должен располагаться до него
```PostgreSQL
SELECT *
FROM "Songs"
WHERE artist = 'The Sounds'
ORDER BY streams;
```
```
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
+----+----------+-----------+------------+---------+--------------+
```
### Сравнение с диапазоном значений `BETWEEN`
Для сравнения с диапазоном значений используется оператор `BETWEEN`. Его синтаксис немного отличается от других оператором, так как для него требуются два значения: начальное и конечное

Извлечем из таблицы `Songs` данные о песнях, количество прослушиваний которых находится в диапазоне `[50000; 100000]`.
```PostgreSQL
SELECT trackname, artist, streams
FROM "Songs"
WHERE streams BETWEEN 50000 AND 100000;
```
```
+--------------+------------+---------+
| trackname    | artist     | streams |
+--------------+------------+---------+
| Crazy on You | Heart      | 76338   |
| My Lover     | The Sounds | 99488   |
+--------------+------------+---------+
```
Как видно из примера выше, при использовании оператора `BETWEEN` нужно указывать два значения: нижнюю и верхнюю границы диапазона. Оба значения должны быть разделены ключевым словом `AND`. При этом извлекаются все значения из диапазона, включая те, что равны граничным значениям.

Извлечем из таблицы `Songs` данные о песнях, которые занимают второе, третье и четвертое места, и отсортируем их по занимаемой позиции.
```PostgreSQL
SELECT place, trackname, artist
FROM "Songs"
WHERE place BETWEEN 2 AND 4
ORDER BY place;
```
```
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
| 4        | Crazy on You         | Heart      |
+----------+----------------------+------------+
```

### Проверка на присутствие и отсутствие значения
Чтобы проверить, содержит ли поле значение `NULL`, нельзя просто записать `<название поля> = NULL`, поскольку значение `NULL` трактуется как неопределенное, и мы не можем выполнить проверку такого значения ни на равенство, ни на неравенство.

Для определения того, находится ли в поле значение `NULL`, предусмотрен оператор `IS NULL`. Противоположным для него оператором является `IS NOT NULL`, который позволяет определить, что в поле не находится значение `NULL`.
```
+--------------+------------+--------------+
| trackname    | artist     | release_date |
+--------------+------------+--------------+
| Crazy on You | Heart      | NULL         |
| My Lover     | The Sounds | NULL         |
+--------------+------------+--------------+
```

Извлечем из таблицы `Songs` данные о песнях, которые имеют дату выхода, и отсортируем их по этой дате в порядке убывания.
```PostgreSQL
SELECT trackname, artist, release_date
FROM "Songs"
WHERE release_date IS NOT NULL
ORDER BY release_date DESC;
```
```
+----------------------+------------+--------------+
| trackname            | artist     | release_date |
+----------------------+------------+--------------+
| Spent the Day in Bed | Morrissey  | 2017-09-19   |
| Thrill               | The Sounds | 2016-11-10   |
| Running up That Hill | Kate Bush  | 1985-08-05   |
+----------------------+------------+--------------+
```
### Список операторов:

|               |                      |
| ------------- | -------------------- |
| **Оператор**  | **Проверка**         |
| `=`           | Равенство            |
| `<=>`         | Эквивалентность      |
| `!=` или `<>` | Неравенство          |
| `<`           | Меньше               |
| `<=`          | Меньше или равно     |
| `>`           | Больше               |
| `>=`          | Больше или равно     |
| `BETWEEN`     | Вхождение в диапазон |
| `IS NULL`     | Значение `NULL`      |
| `IS NOT NULL` | Не значение `NULL`   |
По умолчанию в `MySQL` операторы сравнения не учитывают регистр при сравнении строковых значений, в `PostgreSQL` учитывают.
```MySQL
SELECT 'bee' = 'Bee',
       'bee' <=> 'Bee',
       'bee' > 'Bee',
       'bee' < 'Bee';
```
```
+---------------+-----------------+---------------+---------------+
| 'bee' = 'Bee' | 'bee' <=> 'Bee' | 'bee' > 'Bee' | 'bee' < 'Bee' |
+---------------+-----------------+---------------+---------------+
| 1             | 1               | 0             | 0             |
+---------------+-----------------+---------------+---------------+
```

Для учета регистра необходимо преобразовать одну из сравниваемых строк в тип данных `BINARY` с помощью функций `CAST()` или `CONVERT()`. `BINARY` — это строковый тип данных аналогичный типу `CHAR` за исключением того, что он хранит строки в двоичном виде.
```MySQL
SELECT CAST('bee' AS BINARY) = 'Bee' AS `'bee' = Bee'`,
       CAST('Bee' AS BINARY) = 'Bee' AS `'Bee' = Bee'`,
       CAST('bee' AS BINARY) <=> 'Bee' AS `'bee' <=> Bee'`,
       CONVERT('bee', BINARY) > 'Bee' AS `'bee' > Bee'`,
       CONVERT('bee', BINARY) < 'Bee' AS `'bee' < Bee'`;
```
```
+--------------+--------------+----------------+--------------+--------------+
| 'bee' = Bee' | 'Bee' = Bee' | 'bee' <=> Bee' | 'bee' > Bee' | 'bee' < Bee' |
+--------------+--------------+----------------+--------------+--------------+
| 0            | 1            | 0              | 1            | 0            |
+--------------+--------------+----------------+--------------+--------------+
```

Если нужно выполнить сравнение строк в `PostgreSQL` без учета регистра, необходимо изменить регистр всех символов обоих аргументов на один и тот же
```PostgreSQL
SELECT *
FROM users
WHERE LOWER(username) = LOWER('ExampleUser');
```