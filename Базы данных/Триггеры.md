#база_данных #реляционные #SQL #СУБД 

**Триггер** — это запрос, который автоматически выполняется во время применения операций `INSERT, DELETE` или `UPDATE` по отношению к определенной таблице. Например, триггер, ассоциированный с оператором `DELETE` по отношению к условной таблице `Table`, будет выполняться всякий раз, когда из этой таблицы будут удаляться записи.

Триггер всегда привязывается к таблице и не может существовать в отрыве от нее. Другими словами, если удалится таблица, будет удален и привязанный к ней триггер.

Триггеры применяются для самых различных задач. К примеру, с их помощью можно автоматически преобразовывать добавляемые в таблицу данные в нужный формат, что позволяет обеспечивать непротиворечивость данных. Также их можно использовать для выполнения действий по отношению к одной таблице на основе изменений, которые были сделаны в другой таблице, что может быть полезно для ведения журнала событий.
### Создание триггеров
Процесс создания триггеров не представляет большой сложности, однако имеет ряд важных особенностей, требующих уточнения, поэтому для лучшего его понимания сперва подробнее ознакомимся с синтаксисом

Общий шаблон для создания триггера имеет следующий вид:
```sql
DELIMITER //
CREATE TRIGGER <имя триггера>
<время срабатывания триггера> <операция, которая вызывает триггер>
ON <имя таблицы>
FOR EACH ROW
BEGIN
    <тело триггера>;
END //
DELIMITER ;
```

Несложно заметить, что шаблон начинается не совсем с создания триггера, а с ключевого слова `DELIMITER`. Оно используется для изменения разделителя, которым по умолчанию является точка с запятой (`;`). Здесь в качестве нового разделителя устанавливается двойной слэш (`//`).

Изменение разделителя перед созданием триггера является важной частью, поскольку запрос в теле триггера должен быть завершен символом `;`. Для разделения фрагментов запроса в теле триггера также используется точка с запятой. Если заранее не переопределить разделитель, СУБД посчитает, что символ `;` в теле триггера завершает не запрос, а создание самого триггера, что приведет к ошибке, поскольку в таком случае создание триггера будет оборвано на половине.

Непосредственно создание триггера начинается с оператора `CREATE TRIGGER`, после которого указывается имя триггера. Затем определяются время срабатывания триггера и операция, которая вызывает триггер. Время срабатывания определяется одним из операторов `BEFORE` и `AFTER`, а операция, вызывающая триггер, — одним из операторов `INSERT, DELETE` и `UPDATE`

Например, сочетание операторов `BEFORE INSERT` создаст триггер, который будет выполняться всякий раз, когда в таблицу добавляется запись, причем триггер будет выполняться **перед** добавлением записи. С другой стороны, сочетание операторов `AFTER INSERT` создаст триггер, который также будет выполняться всякий раз, когда в таблицу добавляется запись, однако этот триггер уже будет выполняться **после** добавления записи.

Оператор `BEFORE` используется в том случае, если нужно, чтобы триггер выполнялся перед вызывающей его операцией. При необходимости выполнения триггера после вызывающей его операции используется оператор `AFTER`.

После операции, вызывающей триггер, указывается ключевое слово `ON` и название таблицы, для которой создается триггер. Затем следует набор ключевых слов `FOR EACH ROW`. Внутрь последующего блока `BEGIN END` помещается запрос, который и будет выполняться каждый раз при срабатывании триггера. Завершается создание триггера обновленным разделителем `//` и возвратом к стандартному разделителю в виде символа `;`.
### Доступ к значениям записи
Операция, вызывающая триггер, всегда связана с какой-либо записью таблицы, и триггер имеет доступ к значениям этой записи. Уровень доступа определяется типом триггера:
- `BEFORE INSERT` - имеет доступ к значениям добавляемой записи; может изменять значения добавляемой записи
- `AFTER INSERT` - имеет доступ к значениям добавленной записи
- `BEFORT UPDATE` - имеет доступ к старым и новым значениям обновляемой записи; может изменять новые значения обновляемой записи
- `AFTER UPDATE` - имеет доступ к старым и новым значениям обновленной записи
- `BEFORE DELETE` - имеет доступ к значениям удаляемой записи
- `AFTER DELETE` - имеет доступ к значениям удаленной записи

Рассмотрим подробнее, к примеру, триггер типа `BEFORE UPDATE`, который выполняется до изменения какой-либо записи. Изменение записи всегда сопровождается старыми и новыми значениями, и триггер типа `BEFORE UPDATE` может обратиться и к тем, и к другим.

Для обращения к старым значениям записи используется переменная `OLD`, к новым — `NEW`. Например, если необходимо обратиться к старому значению условного поля `field`, то сделать это можно с помощью `OLD.field`.

Также триггер типа `BEFORE UPDATE` может не только обратиться к новым значениям записи, но и изменить их. Выполняется это с помощью оператора `SET`, после которого указывается имя поля, а затем знак равенства и новое значение. Например, если необходимо изменить новое значение условного поля `field`, скажем, на число `1`, то сделать это можно следующим образом:
```sql
SET NEW.field = 1
```
### Примеры  использования триггеров
**Пример 1**. Создадим триггер `name_and_surname_formatting`, который перед добавлением строкового значения в поле `name` или `surname` таблицы `Authors` переводит ее первый символ в верхний регистр, а остальные — в нижний.
```sql
DELIMITER //
CREATE TRIGGER name_and_surname_formatting
BEFORE INSERT
ON Authors
FOR EACH ROW
BEGIN
    SET NEW.name = CONCAT(UPPER(LEFT(NEW.name, 1)), LOWER(SUBSTRING(NEW.name, 2)));
    SET NEW.surname= CONCAT(UPPER(LEFT(NEW.surname, 1)), LOWER(SUBSTRING(NEW.surname, 2)));
END //
DELIMITER ;

INSERT INTO Authors (name, surname) 
VALUES ('LEO', 'TOLSTOY'),
       ('william', 'shakespeare'),
       ('fYODOr', 'dOSTOYEVSKy');
       
SELECT id, name, surname
FROM Authors;
```
```
+----+---------+-------------+
| id | name    | surname     |
+----+---------+-------------+
| 1  | Stephen | King        |
| 2  | Chuck   | Palahniuk   |
| 3  | Jerome  | Salinger    |
| 4  | Leo     | Tolstoy     |
| 5  | William | Shakespeare |
| 6  | Fyodor  | Dostoyevsky |
+----+---------+-------------+
```

**Пример 2.** Создадим триггер `name_and_surname_logging`, который фиксирует каждое изменение имени и фамилии автора в таблице `Authors`. Подробная информация об изменениях будет записываться в дополнительную таблицу `AuthorsNameHistory`, которая имеет следующую структуру:
```
+--------+-----------+----------+-------------+----------+-------------+
| log_id | author_id | old_name | old_surname | new_name | new_surname |
+--------+-----------+----------+-------------+----------+-------------+
| ...    | ...       | ...      | ...         | ...      | ...         |
+--------+-----------+----------+-------------+----------+-------------+
```
Первое поле этой таблицы содержит идентификатор изменения, второе — идентификатор автора, данные которого были изменены, третье — старое имя, четвертое — старую фамилию, пятое — новое имя, шестое — новую фамилию.
```sql
DELIMITER //
CREATE TRIGGER name_and_surname_logging
AFTER UPDATE
ON Authors
FOR EACH ROW
BEGIN
    INSERT INTO AuthorsNameHistory (author_id, old_name, old_surname, new_name, new_surname)
    VALUES (OLD.id, OLD.name, OLD.surname, NEW.name, NEW.surname);
END //
DELIMITER ;

UPDATE Authors
SET name = 'Richard',
    surname = 'Bachman'
WHERE name = 'Stephen' AND surname = 'King';
       
SELECT author_id, old_name, old_surname, new_name, new_surname
FROM AuthorsNameHistory;
```
```
+-----------+----------+-------------+----------+-------------+
| author_id | old_name | old_surname | new_name | new_surname |
+-----------+----------+-------------+----------+-------------+
| 1         | Stephen  | King        | Richard  | Bachman     |
+-----------+----------+-------------+----------+-------------+
```
### Удаление триггеров
Триггеры, как и многие другие объекты базы данных, могут быть удалены. Для этого необходимо воспользоваться оператором `DROP TRIGGER`, а затем указать имя удаляемого триггера

Предположим, в нашей базе содержится триггер с именем `name_and_surname_formatting` и мы хотим его удалить. Тогда запрос, выполняющий это, будет выглядеть следующим образом:
```sql
DROP TRIGGER name_and_surname_formatting;
```
