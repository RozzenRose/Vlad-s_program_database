#база_данных #реляционные #SQL #СУБД #INNER_JOIN

#### Таблица для примеров
**Первая таблица.** Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:
```no-highlight
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Chuck Palahniuk |
| 2  | Stephen King    |
| 3  | John Tolkien    |
+----+-----------------+
```
Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

**Вторая таблица.** Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:
```no-highlight
+----+-----------+-----------------------+
| id | author_id | title                 |
+----+-----------+-----------------------+
| 1  | 1         | Fight Club            |
| 2  | 2         | The Green Mile        |
| 3  | 3         | The Lord of the Rings |
| 4  | 2         | It                    |
| 5  | 1         | Haunted               |
+----+-----------+-----------------------+
```
Первое поле этой таблицы содержит идентификатор книги, второе — идентификатор автора, третье — название книги.

**Третья таблица.** Информация о пользователях библиотеки располагается в таблице `Users`, которая имеет следующий вид:
```no-highlight
+----+---------------------+
| id | user                |
+----+---------------------+
| 1  | Keanu Reeves        |
| 2  | Matthew McConaughey |
| 3  | Thomas Hanks        |
| 4  | Bradd Pitt          |
| 5  | Liam Neeson         |
+----+---------------------+
```
Первое поле этой таблицы содержит идентификатор пользователя, второе — имя и фамилию.

**Четвертая таблица.** Информация об аренде книг, то есть о том, какой пользователь какую книгу взял на чтение, располагается в таблице `BooksRental`, которая имеет следующий вид:
```no-highlight
+----+---------+---------+
| id | book_id | user_id |
+----+---------+---------+
| 1  | 4       | 1       |
| 2  | 1       | 3       |
| 3  | 2       | 3       |
| 4  | 4       | 4       |
| 5  | 3       | 1       |
+----+---------+---------+
```
Первое поле этой таблицы содержит идентификатор аренды, второе — идентификатор арендованной книги, третье — идентификатор пользователя, арендовавшего книгу.
### Внутреннее соединение
То, какие записи из соединяемых таблиц попадут в результат соединения, определяется видом выполняемого соединения. Например, во время выполнения соединения может возникнуть ситуация, что для одной записи нет соответствующей записи в другой таблице. Поведение при таких ситуациях будет зависеть именно от вида соединения.

При внутреннем соединении двух таблиц отбираются все пары записей, для которых выполняется условие соединения. Если записи невозможно поставить в пару запись из другой таблицы так, чтобы условие соединения выполнялось, запись будет отброшена.

В качестве примера рассмотрим внутреннее соединение таблиц `BooksRental` и `Users` с условием `BooksRental.user_id = Users.id`. Таблица, получаемая в результате данного соединения, имеет следующий вид:
```
+----+---------+---------+----+--------------+
| id | book_id | user_id | id | user         |
+----+---------+---------+----+--------------+
| 1  | 4       | 1       | 1  | Keanu Reeves |
| 2  | 1       | 3       | 3  | Thomas Hanks |
| 3  | 2       | 3       | 3  | Thomas Hanks |
| 4  | 4       | 4       | 4  | Bradd Pitt   |
| 5  | 4       | 1       | 1  | Keanu Reeves |
+----+---------+---------+----+--------------+
```
В данной таблице присутствуют все записи из таблицы `BooksRental`, поскольку для каждой из них можно подобрать соответствующую запись из таблицы `Users`. С другой стороны, в таблице отсутствуют вторая и пятая записи из таблицы `Users`, так как для них соответствующих записей в таблице `BooksRental` нет.

Говоря простыми словами, в примере выше каждой арендованной книге сопоставляется информация о том, кто ее арендовал, и, поскольку некоторые пользователи не арендовали ни одной книги, информации о них в таблице, полученной в результате соединения, нет.

### Оператор `INNER JOIN`
В `SQL` внутреннее соединение выполняется с помощью оператора `INNER JOIN` и ключевого слова `ON`. Сначала указывается первая таблица, затем оператор `INNER JOIN`, а после вторая таблица. Завершается выражение ключевым словом `ON`, после которого располагается условие соединения

Общий синтаксис внутреннего соединения имеет следующий вид:
```css
<первая таблица> INNER JOIN <вторая таблица> ON <условие соединения>
```
В качестве примера выполним рассмотренное ранее соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` и извлечем из полученной в результате соединения таблицы все данные.
```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
```
+----+-----------+-----------------------+----+-----------------+
| id | author_id | title                 | id | author          |
+----+-----------+-----------------------+----+-----------------+
| 1  | 1         | Fight Club            | 1  | Chuck Palahniuk |
| 2  | 2         | The Green Mile        | 2  | Stephen King    |
| 3  | 3         | The Lord of the Rings | 3  | John Tolkien    |
| 4  | 2         | It                    | 2  | Stephen King    |
| 5  | 1         | Haunted               | 1  | Chuck Palahniuk |
+----+-----------+-----------------------+----+-----------------+
```
По сути, связка операторов `INNER JOIN` и `ON` выполняет внутреннее соединение двух таблиц и возвращает полученный результат в виде новой таблицы. Поэтому, указывая после ключевого слова `FROM` выражение, выполняющее соединение таблиц, мы подразумеваем то, что извлечение должно происходить из таблицы, что будет получена в результате соединения.

Запрос, который извлекает данные из таблицы, полученной в результате соединения, называют **многотабличным**

Таблица, полученная в результате приведенного выше соединения, сопоставляет каждой книге ее автора. Поэтому если мы извлечем из нее лишь поля `title` и `author`, то получим решение задачи, что была предложена в начале урока
```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
```
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Таблица, получаемая во время соединения таблиц, нередко может включать поля, имеющие одинаковые имена. К примеру, в таблицах `Bools` и `Authors` такими полями являются поля с именем `id`. Обращаться к таким полям можно, но только по их полным именам
```sql
SELECT Books.id, Authors.id
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
```
+----+----+
| id | id |
+----+----+
| 1  | 1  |
| 2  | 2  |
| 3  | 3  |
| 4  | 2  |
| 5  | 1  |
+----+----+
```
Поскольку таблица, получаемая в результате соединения, это все еще обычная таблица, с ней допустимо выполнять все изученные нами операции: сортировать, фильтрацию и группировку. Например, с помощью фильтрации мы можем получить названия книг лишь определенного автора

```sql
SELECT title
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE author = 'Chuck Palahniuk';
```
```
+------------+
| title      |
+------------+
| Fight Club |
| Haunted    |
+------------+
```

В качестве дополнительного примера выполним соединение таблиц `BooksRental` и `Books` с условием `booksRental.book_id = Books.is`
```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id;
```
```
+----+---------+---------+----+-----------+-----------------------+
| id | book_id | user_id | id | author_id | title                 |
+----+---------+---------+----+-----------+-----------------------+
| 1  | 4       | 1       | 4  | 2         | It                    |
| 2  | 1       | 3       | 1  | 1         | Fight Club            |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        |
| 4  | 4       | 4       | 4  | 2         | It                    |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings |
+----+---------+---------+----+-----------+-----------------------+
```

В таблице, полученной в результате данного соединения, каждой арендованной книге сопоставляется ее название. И вновь следует обратить внимание на то, как именно выполняется внутреннее соединение: из таблиц `BookRental` и `Books` берутся лишь те пары записей, для которых выполняется условие соединения. Например, пятая запись из таблицы `Books` не берется, так как для нее нельзя подобрать запись из таблицы `BooksRental` так, чтобы условие соединения выполнялось
### Соединение нескольких таблиц
Таблица, полученная в результате соединения, сама может быть соединена с другой таблицей, благодаря чему мы можем выполнять соединение не только двух таблиц, но и большего их количества

В качестве примера выполним соединение трех таблиц: `BoolsRental`, `Books` и `Users`
```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id;
```
```
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| id | book_id | user_id | id | author_id | title                 | id | user         |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| 1  | 4       | 1       | 4  | 2         | It                    | 1  | Keanu Reeves |
| 2  | 1       | 3       | 1  | 1         | Fight Club            | 3  | Thomas Hanks |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        | 3  | Thomas Hanks |
| 4  | 4       | 4       | 4  | 2         | It                    | 4  | Bradd Pitt   |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings | 1  | Keanu Reeves |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
```

В данном примере выполняется поочередное соединение таблиц `BoolsRental`, `Books` и `Users`: сначала соединяются таблицы `BooksRenalt` и `Books`, затем полученный результат соединяется с таблицей `Users`. Стоит обратить внимание, что в условии соединения с таблицей `Users` обращение к полю `user_id` происходит по имени первой таблицы - `BooksRental`. Несмотря на то что таблица `Users` соединяется с результатом соединения, таблиц `BooksRental` и `Books`, а не с таблицей `BooksRental`, такое обращение корректно

Используя таблице, полученную в результате приведенного выше соединения, можно получить информацию о том, какие книги были арендованы каждым пользователем. Для этого достаточно извлечь все значения полей `user` и `title`
```sql
SELECT user, title
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id
ORDER BY user;
```
```
+--------------+-----------------------+
| user         | title                 |
+--------------+-----------------------+
| Bradd Pitt   | It                    |
| Keanu Reeves | It                    |
| Keanu Reeves | The Lord of the Rings |
| Thomas Hanks | Fight Club            |
| Thomas Hanks | The Green Mile        |
+--------------+-----------------------+
```
### Самосоединения
Соединять одну таблицу можно не только с другой таблицей, но и с самой собой. Подобное может быть удобно во время работы с таблицей, содержащей рекурсивный внешний ключ.

Предположим, мы имеем таблицу `Staff`, которая хранит информацию о сотрудниках некоторой компании:
```
+----+----------------+------------+
| id | staffer        | manager_id |
+----+----------------+------------+
| 1  | Bill Gates     | NULL       |
| 2  | Alan Turing    | 1          |
| 3  | Isaac Newton   | 1          |
| 4  | Edgar Codd     | 2          |
+----+----------------+------------+
```
Первое поле этой таблицы содержит идентификатор сотрудника, второе — имя и фамилию, третье — идентификатор руководителя (также является сотрудником). Если у сотрудника нет руководителя, значением поля `manager_id` является `NULL`.

Закономерной задачей при работе с таблицей `Staff` возникает определение руководителя каждого сотрудника. Решить такую задачу можно, соединив таблицу с самой собой и сопоставив каждой записи из первой таблицы такую запись из второй таблицы, значение поля `id` которой равняется значению поля `manager_id` записи из первой таблицы. Условием соединения в таком случае будет `Staff.id = Staff.manager_id`. Несложно понять, что в таком случае мы сталкиваемся с проблемой именования таблиц, поскольку по условию неясно, какие таблицы имеются в виду (разные или одна и та же), поэтому для однозначного определения таблиц каждой таблице необходимо дополнительно дать псевдоним.
```sql
SELECT S1.staffer,
       S2.staffer AS manager
FROM Staff AS S1 INNER JOIN Staff AS S2 ON S1.manager_id = S2.id;
```
```
+----------------+-------------+
| staffer        | manager     |
+----------------+-------------+
| Alan Turing    | Bill Gates  |
| Isaac Newton   | Bill Gates  |
| Edgar Codd     | Alan Turing |
+----------------+-------------+
```