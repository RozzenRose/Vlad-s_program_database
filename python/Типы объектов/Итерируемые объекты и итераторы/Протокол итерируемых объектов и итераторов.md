#итерируемые_объекты #python 


**У всех итерируемых объектов** есть #магический_метод `__iter__()`, который создает итератор на основе итерируемого объекта. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод
```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(type(words))
print(type(iterator))
```
```
<class 'list'>
<class 'list_iterator'>
```

**У всех итераторов** есть магический метод `__next__()`, который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот магический метод
```python
words = ['Rozzen', 'Rose', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
```
```
Rozzen
Rose
```

Если объект не является итератором, то есть у него нет магического метода `__next__()`, то вызов функции `next()` приведет к ошибке
```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```
```
TypeError: 'list' object is not an iterator
```

**У всех итераторов** также есть и метод `__iter__()`, который возвращает сам итератор. Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором
```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)          # за кулисами вызывается метод words.__iter__()
iterator2 = iter(iterator1)      # за кулисами вызывается метод iterator1.__iter__()

print(iterator1 == iterator2)
```
```
True
```
Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект - итератор на основе этого итерируемого объекта

Возникает вопрос, для чего итераторы содержат магический метод `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический  метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` - превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен вернуть сам объект

Отсюда следует, что если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на его основе

В итераторах метод `__iter__()` нужен для совместимости. Ведь если `for` работает как с итераторами, так и итерируемыми объектами, но последние требуют преобразования к итератору, и `for`вызывает `__iter()__` без оценки того, что ему передали, то требуется, чтобы оба (итератор и итерируемый объект) поддерживали этот метод. С точки зрения наличия в классе метода `__iter__()` итераторы можно считать подвидом итерируемых объектов
![[Pasted image 20240625163613.png]]
Попробуем вывести основные правила работы с итераторами, назовем это протоколом:
1. чтобы получить итератор, мы должны передать функции `iter()` итерируемый объект
2. далее мы передаём итератор функции `next()`
3. когда элементы в итераторе закончились, вызов функции `next()` возбуждает исключение `StopIteration`

Особенности:
1. любой объект, передаваемый функции `iter()` без исключения `TypeError` — итерируемый объект
2. любой объект, передаваемый функции `next()` без исключения `TypeError` — итератор
3. любой объект, передаваемый функции `iter()` и возвращающий сам себя — итератор

Этим правилам будет починяться любой итерируемый объект