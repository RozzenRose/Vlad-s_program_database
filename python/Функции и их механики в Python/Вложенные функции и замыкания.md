#python #функция 


Python позволяет определять функции внутри других функций. Их называют вложенными функциями или внутренними функциями.
```python
def speak(text):
    def whisper(t):                      # объявляем вложенную функцию
        return t.lower() + '...'
    return whisper(text)                 # вызываем вложенную функцию и возвращаем ее результат

print(speak('Hello, World'))         
```
определяет вложенную функцию `whisper()` внутри функции `speak()` и выводит:
```
hello, world...
```
Каждый раз, когда мы вызываем функцию `speak()`, она определяет новую функцию `whisper()`, а затем вызывает ее. При этом функция `whisper()` не существует вне родительской функции `speak()`.

Вызов внутренней функции напрямую приведет к исключению:
```python
whisper('Hello')
```
```
NameError: name 'whisper' is not defined
```
Как и код:
```python
speak.whisper('Hello')
```
```
AttributeError: 'function' object has no attribute 'whisper'
```

Если нам нужно получить доступ к вложенной функции `whisper()` извне, то мы можем вернут ее родительской функцией.

Функция высшего порядка `get_speak_func()` определяет две вложенные функции `whisper()` и `yell()`. В зависимости от аргумента `volume`, переданного родительской функции `get_speak_func()`, она выбирает и возвращает вызывающей стороне одну из вложенных функций:
```python
def get_speak_func(volume):
    def whisper(text):
        return text.lower() + '...'
    def yell(text):
        return text.upper() + '!'

    if volume > 0.5:
        return yell
    else:
        return whisper
```
Функции высшего порядка - это функции, которые принимают и/или возвращают другие функции.

Обратите внимание на то, что функция `get_speak_func()` на самом деле не вызывает одну из своих вложенных функций - она просто выбирает подходящую функцию на основе на основе аргумента `volume`, а затем возвращает объект этой функции
```python
whisper = get_speak_func(0.3)     # функция whisper()
yell = get_speak_func(0.7)        # функция yell()

print(whisper('Hello'))           # говорим шепотом
print(yell('Hello'))              # кричим
```
```python
hello...
HELLO!
```
Таким образом, функции не только могут принимать поведение через аргументы, но также могут возвращать поведение

#### Замыкание
Вложенные функции могут захватывать и переносить с собой часть состояния родительской функции

Перепишем немного функцию `get_speak_func()`, чтобы новая версия сразу принимала два аргумента `volume` и `text`:
```python
def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    
    if volume > 0.5:
        return yell
    else:
        return whisper
```
```python
yell = get_speak_func('Hello, World', 0.7)

print(yell())
```
```
HELLO, WORLD!
```
Теперь вложенные функции `whisper()` и `yell()` не имеют параметра `text`. Они его получают и используют через родительскую функцию `get_speak_func()`. Функции, которые делают это, называются замыканиями. Замыкание запоминает значения из включающей его области, даже если поток программы больше не находится в этой области.

Таким образом, замыкание - это особый вид функции. Она определена в теле другой функции и создается каждый раз во время ее выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.
```python
def closure():
    count = 0
    def inner():
        nonlocal count
        count += 1
        print(count)
    return inner

start = closure()
another = closure()             # другое замыкание, со своими локальными значениями

start()                         # выводит 1
start()                         # выводит 2
another()                       # выводит 1
start()                         # выводит 3
```
Замыкания очень полезны при решении многих задач. С их помощью могут не только возвращать поведение, но и предварительно настраивать это поведение.

Рассмотрим несколько примеров, в которых используются замыкания.

***Пример 1*** В этом примере функция `greeting_creator()` служит фабрикой для создания и настройки функции присвоения. Обратите внимание на то, что вложенная функция `greet()` может обращаться к аргументу `greeting_word` своей родительской функции `greeting_creator()`.
```python
def greeting_creator(greeting_word):
    def greet(name):
        return f'{greeting_word}, {name}'

    return greet

say_hi = greeting_creator('Hi')
say_hello = greeting_creator('Hello')

print(say_hi('Timur'))
print(say_hello('Soslan'))
```
```
Hi, Timur
Hello, Soslan
```

***Пример 2*** В этом примере функции `make_adder()` и `multiplier_of()` служат фабриками для создания и настройки функций "сумматора" и "мультиплексора". Обратите внимание на то, что вложенные функции `add()` и  `mult()` могут обращаться к аргументу `n` своих родительских функций `make_adder()` и `multiplier_of()`
```python
def make_adder(n):
    def add(x):
        return x + n
    return add

def multiplier_of(n):
    def mult(x):
        return x * n
    return mult

plus_3 = make_adder(3)
plus_5 = make_adder(5)
multiply_3 = multiplier_of(3)
multiply_5 = multiplier_of(5)

print(plus_3(10), plus_3(100))
print(plus_5(10), plus_5(100))
print(multiply_3(10), multiply_3(100))
print(multiply_5(10), multiply_5(100))
```
```
13 103
15 105
30 300
50 500
```
Имейте в виду, что вложенные функции, которые возвращает родительская функция, могут быть анонимными. Приведенный выше код можно переписать в виде:
```python
def make_adder(n):
    return lambda x: x + n

def multiplier_of(n):
    return lambda x: x * n
```

***Пример 3*** В этом примере функция `line_generator()` служит фабрикой для создания и настройки линейной функции вида `y = kx + b`. Обратите внимание на то, что вложенная функция `func()` может обращаться к аргументам `k` и `b` своей родительской функции `line_generator()`
```python
def line_generator(k, b):
    def func(x):
        return k * x + b
    return func

line_func_1 = line_generator(2, 5)        # получаем функцию y = 2*x + 5
line_func_2 = line_generator(-6, 9)       # получаем функцию y = -6*x + 9

print(line_func_1(10))                    # печатаем значение 2*10 + 5
print(line_func_2(4))                     # печатаем значение -6*4 + 9
```
```
25
-15
```
Обратите внимание на то, что во всех предыдущих примерах наши вложенные функции (замыкания) использовали нелокальные переменные, которые являлись параметрическими для родительской функции. Вложенные функции могут обращаться ко всем локальным переменным родительской функции, независимо от того, были они определены во внешней функции или пришли из аргументов внешней функции.

#### Когда использовать замыкания
Концепция замыканий, то есть функций, захватывающих нелокальные переменные, находят много применений при написании кода. Замыкания хороши для:
- воздержания от жестко закодированных констант
- воздержания от использования глобальных переменных
- воздержания от создания ненужных типов данных (классов)
- замыкания нужны для реализации декораторов, о которых мы поговорим чуть позже

Сокрытие данных основное преимущество замыканий.

Вложенные (внутренние) функции позволяют избавиться от глобальных переменных. Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной. Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».

Если функция использует глобальные переменные, это тоже замыкание. Но чаще всего замыканием называют все-таки функцию, которая использует `нелокальные переменные`. Такая функция как бы «таскает за собой» свои внешние переменные, но никому их не показывает.

Прочитать подробнее про замыкания можно на википедии по [ссылке](https://en.wikipedia.org/wiki/Closure_(computer_programming)).