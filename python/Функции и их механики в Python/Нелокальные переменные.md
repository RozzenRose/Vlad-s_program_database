#python #функция #_closure__ #nonlocal 

При поиске переменной с указанным именем приоритет (правило размещения имен) следующий:
1. сначала ищем локальную переменную
2. если не нашли локальную, ищем нелокальную
3. если не нашли нелокальную, ищем глобальную
4. и в самом конце — встроенную в язык

Промежуточная область видимости, которая доступна вложенным функциям, называется нелокальной. Если вложенность функций больше двух уровней, нелокальная переменная ищет в "ближайшей" области видимости, т.е. в функции вложенностью меньше на один. Если не находит, поиск переходит в самую большую ближнюю из внешних областей видимости, затем чуть более далекую - и так далее, пока не найдется нужное имя. Фактически интерпретатор ищет там, "где поближе"

#### Ключевое слово `nonlocal`
Вложенная функция видит переменные в родительской функции, которые называются нелокальными или свободными переменными
```python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
```
```
UnboundLocalError: local variable 'num' referenced before assignment
```
Дело в том, что вложенная функция не просто обращается (получает значение) к переменной `num`, но и пытаться его изменить! Внутренняя функция видит переменные в объемлющей функции, но, если она хочет такую переменную изменить, должна объявить ее `nonlocal`
```python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        nonlocal num
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
```
```
15
```

#### Атрибут `__closure__`
Все функции содержат специальный атрибут `__closure__`, который представляет из себя кортеж, содержащий данные, связанные с вложенными областями видимости, то есть с нелокальными переменными
```python
def outer_function(arg):
    num = 5
    name = 'Timur'
    numbers = [1, 2, 3]
    def inner_function():      # определяем вложенную функцию
        print(arg)
        print(num)
        print(numbers)
    return inner_function      # возвращаем вложенную функцию
        
inner = outer_function('python')

for var in inner.__closure__:
    print(var.cell_contents)
```
```
python
5
[1, 2, 3]
```
Обратите внимание на то, что кортеж `__closure__` содержит внутри себя специальный тип данных. Для получения самого значения захваченной переменной нужно использовать атрибут `cell_contents`

 Отличная статья про то, каким образом ищутся имена в программах Python доступна по [ссылке](https://realpython.com/python-scope-legb-rule/).