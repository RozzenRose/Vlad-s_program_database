#python #генератор #yield


***Функция генератор*** - это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение `yield`, а не `return`

Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные. Когда обычная функция достигает оператора `return`, локальные переменные уничтожаются и значение возвращается вызывающей стороне. Последующий вызов  той же функции создает новое локальное пространство имен и новый набор локальных переменных.

Функция генератор, напротив сохраняет локальные переменные от вызова к вызову.

Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от `0` (включительно) до ***n*** (не включительно)
```python
def generate_ints(n):
    for num in range(n):
        yield num
```
Используем этот генератор в коде:
```python
generator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4

print(type(generator1))

print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))

generator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2

for num in generator2:
    print(num)

num1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1

print(num1, num2)
```
```
<class 'generator'>
0
1
2
3
4
0
1
2
0 1
```
По сути, функция `generatr_ints()` просто возвращает генератор, порождающий последовательность нужных чисел.

***Генератор - это итератор***, который порождает значения, переданные `yield`. Когда выполнение доходит до конца функции, объект генератор возбуждает исключение `StopIterator` в полном соответствии с протоколом итератора

Работа с генератором происходит по стандартному сценарию работы с итератором. Мы можем:
- вызывать функцию `next()` для получения очередного значения генератора
- итерироваться с помощью цикла `for` по генератору
- распаковывать генератор
- проверять принадлежность с помощью оператора `in`
- и т.д.

Функция генератор возвращает объект специального типа `<class 'generator'>`, который реализует протокол итератора, то есть является самым настоящим итератором

Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий протокол итератора.

Класс `GenerateInts` полностью аналогичен указанной выше функции генератору:
```python
class GenerateInts:                             
    def __init__(self, n):         # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
```
Применим этот класс:
```python
iterator1 = GenerateInts(5)           # создаем итератор, содержащий числа 0 1 2 3 4

print(type(iterator1))

print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))

iterator2 = GenerateInts(3)           # создаем итератор, содержащий числа 0 1 2

for num in iterator2:
    print(num)

num1, num2 = GenerateInts(2)          # создаем итератор, содержащий числа 0 1

print(num1, num2)
```
```
<class '__main__.GenerateInts'>
0
1
2
3
4
0
1
2
0 1
```
Просто попробуй оценить насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количество строк кода

Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно
```python
def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4

print(*generate_1234())         # распаковка генератора
```
Этот код содержит определение функции генератора `generate_1234()`, которая порождает последовательность значение `1`, `2`, `3`, `4` и выводит:
```
1 2 3 4
```

Любой итератор является итерируемым объектом, в то время как любой генератор является итератором, а значит и итерируемым объектом
![[Pasted image 20240627155235.png]]
#### Функции генераторы с побочными действиями
Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:
- вывод текста на экран
- запись данных в файл
- приостановка исполняющейся программы на некоторое время
- и т.д.

Рассмотрим определение функции генератора, которая печатает текст во время выполнения
```python
def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')

for char in generate_AB():
    print('-->', char)
```
```
start
--> A
continue
--> B
end
```
Для итерирования цикл `for` сначала получает итератор, то есть выполняет следующий код:
```python
iterator = iter(generate_AB())
```
а затем на каждой итерации вызывает функцию `next(iterator)`. В теле цикла на каждой итерации печатается строка `-->` и значение, полученное при вызове `next(iterator)`

Во время первой итерации и первом вызове `next(iterator)` генератор, перед тем как сгенерировать значение `'A'` (то есть дойти до строки `yield 'A'`), сначала выполняет строку `print('start')`

Во время второй итерации и втором вызове `next(iterator)` генератор, перед тем как сгенерировать значение `'B'` (то есть дойти до строки `yield 'B'`), сначала выполнять строку `print('continue')`

Во время второй итерации и втором вызове `next(iterator)` генератор выполняет строку `print('end')` и завершает свою работу, возбуждая исключение `StopIteration`. Цикл `for` перехватывает это исключение и нормально завершается

#### Ключевое слово `return` в теле функции генератора
В случае, если в теле функции-генератора будет содержаться ключевое слово `return` приводит к возбуждению исключения `StopIteration`
```python
def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4

for num in generate_ints():
    print(num)
```
```
1
2
```
Стока `return 3` в функции генераторе `generate_ints()` возбуждает исключение `StopIteration`, которое перехватывает цикл `for`, после чего он завершается. Обратите внимание на то, что само значение `3` не выводится

#### Особенности и ограничения функции генераторов
Основные особенности, присущие всем функциям генераторам:
- любая функция, содержащая ключевое слово `yield`, является функцией генератором
- когда вызывается функция генератор, то она **не возвращает единственное значение**, как это делает обыкновенная функция
- функция генератор всегда возвращает объект типа `generator`, который поддерживает протокол итератора

Разница между `yield` и оператором `return` заключается в том, что для ключевого слова `yield` состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора `__next__()` функция возобновляет свое выполнение их той точки, из которой завершила в прошлый раз

Генератор является итератором, поэтому он обладает всеми его особенностями:
- нельзя получить длину генератора функцией `len()`
- нельзя распечатать элементы генератора функцией `print()` без предварительной распаковки
- у генератора нельзя получить элемент по индексу
- после итерации по генератору он становится пустым

#### Примеры использования функции генераторов
В прошлом уроке мы рассматривали примеры по созданию собственных итераторов с помощью создания соответствующих классов. Давайте перепишем их с использованием функции генераторов

##### Пример 1
Реализуем функцию генератор `counter()`, которая возвращает генератор, порождающий последовательность целых чисел от значения `low` до `high` включительно с шагом один.
Значения `low` и `high` передаются в качестве аргументов в функцию генератор
Напишем генератор:
```python
def counter(low, high):
    for num in range(low, high + 1):
        yield num
```
Применим генератор:
```python
counter1 = counter(3, 10)

for i in counter1:
    print(i)

counter2 = counter(100, 103)
print(next(counter2))
print(next(counter2))
```
```
3
4
5
6
7
8
9
10
100
101
```

##### Пример 2
реализуем функцию генератор `even_numbers()`, которая возвращает генератор, порождающий бесконечную последовательность целых четных чисел от значения `being`. Значение `being` передается в качестве аргумента в функцию генератор
Пишем генератор:
```python
def even_numbers(begin):
    begin += begin % 2
    while True:
        yield begin
        begin += 2
```
Применяем генератор:
```python
evens1 = even_numbers(10)                     # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = even_numbers(101)                    # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```
```
10
12
14
16
18
20
102
104
106
108
```

##### Пример 3
Реализуем функцию генератор `string_wrapper()`, которая возвращает генератор, порождающий последовательность символов `text`, обрамленных специальным символом `synbol`. Значения `text` и `symbol` передаются в качестве аргументов в функцию генератор
Напишем генератор:
```python
def string_wrapper(text, symbol):
    for char in text:
        yield symbol + char + symbol
```
Применим генератор:
```python
string_wrapper1 = string_wrapper('beegeek', '~')

for char in string_wrapper1:
    print(char)
 
string_wrapper2 = string_wrapper('Python', '+')
print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))

print(list(string_wrapper('stepik', '-')))
```
```
~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
```

Ручная реализация соответствующего класса итератора

##### Пример 4
Реализуем функцию генератор `factorials()`, которая возвращает генератор, порождающий бесконечную последовательность факториалов всех натуральных чисел (от 1 до бесконечности). Функция генератор не принимает аргументов.
Пишем генератор:
```python
def factorials():
    value = 1
    index = 1
    while True:
        yield value
        index += 1
        value *= index
```
Применим его:
```python
infinite_factorials = factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
```
```
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```

#### [[Конструкция yield from]]
#### [[Генераторные выражения]]
#### [[Конвейеры генераторов]]