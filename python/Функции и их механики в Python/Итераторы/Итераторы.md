#итерируемые_объекты #python #итератор #изменяемый_объект 


***Итераторы*** - специальный объект, который выдает свои элементы по одному за раз

Если итератор передать во встроенную функцию `next()`, то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` приведет к возникновению исключения `StopIteration`

Основными преимуществами использования итераторов являются:
- однотипность работы с объектами разных типов
- ленивые вычисления и экономия потребляемой памяти
- комбинация множества итераторов для создания понятной и читабельной программы

Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, множества, строки, словари, объекты типа `range` имеют разные типы, но мы можем использовать любой из этих объектов:
- в цикле `for`
- в функциях высшего порядка `map(), filter(), reduce(), reversed()` и т.д.
- для проверки наличия некоторого значения с помощью оператора принадлежности `in`
- для распаковки элементов с помощью `*` и т.д.

Цикл `for` в Python работает по следующему принципу:
- создает итератор на основе итерируемого объекта
- запрашивает очередной элемент из итератора с помощью функции `next()` и передает его в выполняемый блок кода (тело цикла)
- останавливается при получении исключения `StopIteration`

Благодаря этому, в цикл `for` можно передать и список, и кортеж, и строку, и объект типа `range`, и многие другие объекты, которые имеют свои итераторы
```python
numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
```
за кулисами превращается в:
```python
numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```
#### Ленивые вычисления
Ленивые вычисления предполагают, что не нужно ничего не делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление
```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```
```
0
1
2
3
4
```
Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает но основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число `4`

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение
```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```
```
48
48
48
```
Все объекты `range` имеют один и тот же размер в памяти - `48 байт`. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.
```python
from sys import getsizeof

numbers1 = list(range(5))                  # 5 чисел в списке
numbers2 = list(range(100000))             # 100000 чисел в списке

print(getsizeof(numbers1))
print(getsizeof(numbers2))
```
размер в байтах:
```
96
800056
```
Чем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно
```python
from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке

print(getsizeof(numbers3))
```
Выполнение такого кода приведет к возникновению исключения `MemoryError`. Python не позволит создать такой большой список

Объекты типа `range` являются ленивыми, преобразовывать их в списки стоит только тогда, когда это действительно необходимо

#### Комбинация множества итераторов
У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом
```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```
```
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```
Обратите внимание на то, что все три объекта `filter_iterator`, `map_iterator`, `enumerate_iterator` являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают. Другими словами, при обращении к очередному элементу `enumerate_iterator` произойдет последовательное о
### Синтаксические особенности итераторов
Самое простое, что можно сделать с итератором - это его последовательный обход с помощью цикла `for`
```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)
```
```
3
6
1
90
34
25
23
21
```
По сути, за кулисами цикл `for` вызывает встроенную функцию `next()`, передавая ей в качестве аргумента итератор `positive_numbers`. Функция `next()` последовательно возвращает значения итератора, принимая к ним функцию `abs()` до тех пор, пока не будет возвращено последнее значение, после чего возбуждается исключение `StopIteration` и цикл `for` завершается. По мере вызова функций `next()` итератор `positive_numbers` опустошается и в конце концов становится совершенно бесполезным
```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

for num in positive_numbers:             # обходим пустой итератор, тело цикла выполнено не будет
    print(num)
```
```
3
6
1
90
34
25
23
21
``` 
поскольку после первого цикла `for` итератор `positive_numbers` становится пустым и его повторный обход ни к чему не приведет.

При этом `for`  сам перехватывает исключение `StopIteration`. Если самостоятельно вызывать функцию `next()` на пустом итераторе, мы получим исключение `StopIteration`
```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

print(next(positive_numbers))            # пытаемся получить элемент из пустого итератора
```
#### Преобразование в коллекцию
Помимо последовательного прохода по итератору с помощью цикла `for` мы можем использовать встроенные функции `list()`, `tuple()` и т.д. для преобразования итератора в коллекцию
```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                 # создаем объект итератора
positive_numbers_list = list(positive_numbers)       # преобразуем итератор в список

print(positive_numbers_list)
```
```
[3, 6, 1, 90, 34, 25, 23, 21]
```
Функция `list()` в данном случае преобразует итератор в список и за кулисами обходит итератор до конца, тем самым опустошая его
```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                  # создаем объект итератора

positive_numbers_list1 = list(positive_numbers)       # преобразуем итератор в список
positive_numbers_list2 = list(positive_numbers)       # преобразуем пустой итератор в список

print(positive_numbers_list1)
print(positive_numbers_list2)
```
```
[3, 6, 1, 90, 34, 25, 23, 21]
[]
```
Так как получить значения итератора можно лишь единожды

#### Оператор принадлежности in
Оператор принадлежности `in` работает и с итераторами. Проверка на вхождение осуществляется путем перебора всех элементов последовательно, и как только элемент обнаружен, поиск прекращается
```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
```
```
True
```
Однако тут нужно понимать, что по мере поиска итератор опустошается, поскольку оператор `in` за кулисами вызывает функцию `next()` для получения следующего элемента
```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(15 in iterator)
```
```
True
False
```
При этом после второй проверки на принадлежность итератор `iterator` полностью опустошается и последующие поиски по нему всегда будут приводить к результату `False`
```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(23 in iterator)
```
```
True
True
```
поскольку как только элемент `15` обнаружен, поиск прекращается, и в итераторе остается три числа `16`, `23`, `42`

#### Распаковка итератора
Мы также можем распаковывать содержимое итератора, автоматически опустошая его
```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(*iterator)
print(list(iterator))
```
```
4 8 15 16 23 42
[]
```

### [[python/Функции и их механики в Python/Итераторы/Создание кастомных итераторов|Создание кастомных итераторов]]