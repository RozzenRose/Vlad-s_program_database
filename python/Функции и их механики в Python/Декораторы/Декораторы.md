#python #декоратор

![[198661149_4660014150681951_1462244621338214611_n.jpg|500]]
**Декоратор** - это функция, которая принимает другую функцию, расширяет ее поведение, не изменяя ее явно, и возвращает новую функцию

Объявления:
```python
def null_decorator(func):
	return func
```
`null_decorator` вообще ничего не делает с переданной ему функцией, возвращает ее в исходном виде

Пример:
```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

say = sample_decorator(say)          # декорируем функцию

say()                                # вызываем декорированную функцию
```
```no-highlight
Начало функции
Привет Мир!
Конец функции
```
`sample_decorator()` является функцией-декоратором. Как можно заметить, она является функцией высшего порядка, так как принимает функцию в  качестве аргумента, а также возвращает функцию. Внутри `sample_decorator()` мы определили другую функцию - обёртку, которая обёртывает передаваемую функцию `say()` и затем изменяет ее поведение. Декоратор возвращает эту обертку

Декорирование функции `say()` происходит в следующей строке:
```python
say = sample_decorator(say)
```

После декорирования переменная `say` указывает на внутреннюю функцию `wrapper()`. ***Важно понимать*** то, что при вызове функции `sample_decorator(say)` с переданной в качестве аргумента функцией `say()` возвращается вложенная функция `wrapper()` в качестве результата. Функция `wrapper()`, в свою очередь, имеет ссылку на переданную в качестве аргумента функцию `say()` и вызывает эту функцию между двумя вызовами встроенной функции `print()`
```python
print(say)                         # до декорирования
say = sample_decorator(say)
print(say)                         # после декорирования
```
```
<function say at 0x00000122AD3F0F70>
<function sample_decorator.<locals>.wrapper at 0x00000122AD3F1090>
```
Таким образом, после декорирования мы получаем совершенно другую функцию, которая расширяет функционал начальной функции

Декораторы обертывают функцию, изменяя ее поведение

#### Примеры синтаксиса:
##### Пример 1:
```python
def null_decorator(func):
    return func

def say():
    print('Привет Мир!')

say = null_decorator(say)            # декорируем функцию

say()
```
можно переписать в виде:
```python
def null_decorator(func):
    return func

@null_decorator                      # декорируем функцию
def say():
    print('Привет Мир!')

say()
```
##### Пример 2:
```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

say = sample_decorator(say)          # декорируем функцию

say()                                # вызываем декорированную функцию
```
можно переписать в виде:
```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

@sample_decorator                    # декорируем функцию
def say():
    print('Привет Мир!')

say()
```
Добавив `@sample_decorator` перед определением функции `say()`, мы модифицировали ее поведение. Однако, запись с `@` является всего лишь синтаксическим сахаром для записи
```python
say = sample_decorator(say)
```
Иными словами, выражение `@sample_decorator` вызывает функцию `sample_decorator()` с `say` в качестве аргумента и присваивает имени `say` возвращаемую функцию

При этом использование синтаксиса через `@` декорирует функцию сразу во время определения. Это затрудняет доступ к недекорированной функции. Поэтому мы можем декорировать некоторые функции вручную, чтобы сохранить возможность вызывать и недекорированную версию функции.

#### Изменение поведения функции
Декоратор может менять поведение декорируемой функции. Накатаем декоратор, который преобразует строковый результат декорированной функции в верхний регистр
```python
def uppercase_decorator(func):
    def wrapper():
        original_result = func()
        modified_result = original_result.upper()
        return modified_result

    return wrapper
```
Вместо того чтобы просто возвращать исходную функцию, как этот делал `null_decorator()`, декоратор `uppercase_decorator()` определяет и возвращает новую функцию `warpper()`. Функция `wrapper()`, являясь замыканием, имеет доступ к недекорированной функции `func` и может выполнять дополнительный код до и после вызова функции `func`
```python
@uppercase_decorator
def greet():
    return 'Hello world!'

print(greet())
```
```
HELLO WORLD!
```
В отличие от `null_decorator()`, наш новый декоратор `uppercase_decorator()` возвращает другой объект функции, в чем несложно убедиться
```python
def greet():
    return 'Hello world!'

print(greet)
greet = uppercase_decorator(greet)     # ручное декорирование
print(greet)
```
```
<function greet at 0x000001CF72B40F70>
<function uppercase_decorator.<locals>.wrapper at 0x000001CF72B41090>
```
Декоратор `uppercase_decorator()` сам по себе является функцией. Единственный способ повлиять на новое поведение функции, которую он декорирует - это заменить исходную функцию замыканием. Вот почему декоратор `uppercase_decorator()` определяет и возвращает другую функцию `wrapper()`, которую затем можно вызвать позже, запустить исходную функцию и изменить ее результат

#### Применение нескольких декораторов
Мы можем без каких-либо проблем применять к функции несколько различных декораторов. Это накапливает их эффекты, и делает декораторы очень полезными на практике

Рассмотрим два декоратора `bold()`и `italic()`, которые заключают результат вызова функнции в HTML-теги:
```python
def bold(func):
    def wrapper():
        return '<b>' + func() + '</b>'
    return wrapper

def italic(func):
    def wrapper():
        return '<i>' + func() + '</i>'
    return wrapper
```
Применим их к функции `greet()`.
Приведенный ниже код:
```python
@bold
@italic
def greet():
    return 'Hello world!'

print(greet())
```
выводит:
```html
<b><i>Hello world!</i></b>
```
Декораторы применяются в порядке ***снизу вверх***. Таким образом, мы можем явно использовать декорирование, обойдясь без специального синтаксиса. В таком случае цепочка вызовов функций декораторов будет выглядеть так
```python
greet = bold(italic(greet))
```
Таким образом, сначала применяется декоратор `italic()`, который оборачивает результат вызова декорируемой функции в теги `<i></i>`, а затем результирующая обернутая функция снова обертывается декоратором `bold()`, который оборачивает результат вызова декорируемой функции в теги `<b></b>`

#### Декорирование функций, принимающих аргументы
Изменим функцию `greet()` так, чтобы она принимала аргумент `name`:
```python
def greet(name):
    return f'Hello {name}!'
```
 Попробуем применить наш декоратор `bold()` к новой функции `greet()`
 ```python
@bold
def greet(name):
    return f'Hello {name}!'

print(greet('VlaDICK'))
```
```
TypeError: bold.<locals>.wrapper() takes 0 positional arguments but 1 was given
```
Проблема в том, что внутренняя функция `wrapper()` не принимает никаких аргументов, а мы пытались ей передать один аргумент `VlaDICK`. Эту проблему можно исправить, позволив `wrapper()` принять один аргумент, но тогда она не будет работать для функции, которые не принимают аргументов или принимают больше одного аргумента.

Решение заключается в использовании `*args` и `*kwargs` во внутренней функции, что позволит ей принимать произвольное число позиционных и именованных аргументов:
```python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'

    return wrapper

@bold
def greet1(name):
    return f'Hello {name}!'

@bold
def greet2():
    return 'Hello world!'

@bold
def greet3(name, surname):
    return f'Hello {name} {surname}!'

print(greet1('VlaDICK'))
print(greet2())
print(greet3('Rozzen', 'Rose'))
```

```html
<b>Hello VlaDick!</b>
<b>Hello world!</b>
<b>Hello Rozzen Rose!</b>
```
В примере выше вложенная функция `wrapper()` принимает произвольное число позиционных и именованных аргументов и передает их в декорируемую функцию `func()`. Теперь декоратор `@bold` будет работать как для функций, которые вообще не принимают аргументы, так и для функции которые принимают произвольное количество позиционных и именованных аргументов.

#### Возврат значений из декорируемой функции
В Python все функции возвращают значение. Даже если тело функции не содержит явно инструкции `return`, она вернет значение `None`. Нужно быть очень внимательным к декорированию функций, которые возвращают значения, которые затем используются.

Допустим, мы написали следующий декоратор:
```python
def talk(func):
    def wrapper(*args, **kwargs):
        dash = '-' * 15
        print(dash)
        func(*args, **kwargs)           # вызываем декорируемую функцию
        print(dash)

    return wrapper
```
И мы хотим декорировать простую функцию, которая возвращает значение:
```python
@talk
def greet(name):
    return f'Hello {name}!'

print(greet('VlaDICK'))
```
выводит:
```
---------------
---------------
None
```

Декоратор съел возвращаемое значение из функции `greet()`, так как вложенная функция `wrapper()` явно не возвращает какого-либо значения, и в итоге вызов декорируемой функции `greet('VlaDick')` вернул `None`.

Чтобы исправить этот недочет, необходимо сделать так, чтобы вложенная функция `wrapped()` возвращала задекорированное значение, которое, в свою очередь, возвращает функция. Изменим декоратор `talk()` следующим образом:
```python
def talk(func):
    def wrapper(*args, **kwargs):
        dash = '-' * 15
        result = func(*args, **kwargs)
        return dash + '\n' + result + '\n' + dash

    return wrapper
```
Приведенный ниже код:
```python
@talk
def greet(name):
    return f'Hello {name}!'

print(greet('Timur'))
```
выводит:
```
---------------
Hello Timur!
---------------
```
Вот теперь заебись

#### [[Сохранение атрибутов __name__ и __doc__ для декорируемой функции]]
#### [[Декораторы с аргументами]]
### Частные случаи декораторов:
##### - [[Декоратор изменения времени работы функции]]
##### - [[Декоратор отслеживания количество вызовов]]
##### - [[Декоратор замедления времени выполнения функции]]