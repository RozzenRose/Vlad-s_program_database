#python #декоратор #_name__ #_doc__

Все функции содержат специальные атрибуты `__name__` и `__doc__`, которые содержат полезную информацию:
- `__name__` — имя функции
- `__doc__` — строка документации

Рассмотрим применение декоратора `bold` к функции `greet()`
```python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper

@bold
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'

print(greet.__name__)
print(greet.__doc__)
```
```
wrapper
None
```
После того как к функции `greet()` был применен декоратор, ее атрибуты `__name__` и `__doc__` изменились на имя и строку документации внутренней функции `wrapper()` декоратора `bold` Хотя чисто технически это верно, это не очень хорошо.

Одно из решений этой проблемы выглядит следующим образом:
```python
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    return wrapper

@bold
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'

print(greet.__name__)
print(greet.__doc__)
```
```
greet
Функция приветствия пользователя.
```
Теперь у функции `greet()` атрибуты `__name__` и `__doc__` не перетираются после применения декоратора.

Решение проблемы связанное с перетиранием атрибутов `__name__` и `__doc__` является рабочим, однако каждый раз писать в декораторе строки кода, которые восстанавливают значения данных атрибутов, не очень хорошо.

Для решения проблемы перетирания данных атрибутов на практике используют другой декоратор, который находится в модуле `functools` и называется `wraps`. Таким образом, чтобы предотвратить перетирание атрибутов `__name__` и `__doc__` декорируемой функции, декораторы должны использовать декоратор `functools.wraps`, который сохраняет информацию о первоначальной функции
```python
import functools

def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper

@bold
def greet(name):
    '''Функция приветствие пользователя.'''
    return f'Hello {name}!'

print(greet.__name__)
print(greet.__doc__)
```
```
greet
Функция приветствие пользователя.
```
Теперь у функции `greet()` атрибуты `__name__` и `__doc__` не перетираются после применения декоратора `bold`

#### Шаблон декоратора общего назначения
Все декораторы в большинстве случаев делают примерно одно и то же. Наиболее частый шаблон декоратора выглядит следующим образом:
```python
import functools

def decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Что-то выполняется до вызова декорируемой функции
        value = func(*args, **kwargs)
        # декорируется возвращаемое значение функции
        # или что-то выполняется после вызова декорируемой функции
        return value
    return wrapper
```
На основе этого шаблона можно строить декораторы общего назначения