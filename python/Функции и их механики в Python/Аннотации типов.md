#python 

Раньше на Python писали в основном небольшие скрипты, но в последнее время язык стал значительно популярнее и сегодня на Python написано много сложных систем из сотен тысяч строк кода. В таких обстоятельствах документирующее свойство системы типов становится очень полезным. В достаточно крупной кодовой базе при отсутствии информации о типах очень сложно угадать, какие именно объекты используются в программе.

***Аннотации типов*** - это специальный синтаксис для объявления типов параметров функции и их возвращаемых значений (PEP 485). В Python 3.6 эта возможность была расширена - стало можно объявлять типы переменных вообще в любом месте программы.

Аннотации типов - это возможность, а не обязанность. У программиста есть выбор - добавлять информацию о типах или не добавлять.

Таким образом программист при написании кода расставляет информацию о типах переменных, параметров  и возвращаемых значений функций.  Это никак не влияет на выполнение программы. Python вообще никак не использует эту информацию, он лишь перекладывает ее в специальные атрибуты функции или переменных, делая доступной для сторонних утилит. То есть, если указанно, что функция принимает строковый аргумент, то это никак не помешает вызывать ее с целым числом или списком - в зависимости от тела функции, она может отработать, а может завершится ошибкой, но сама возможность вызова с любыми типами аргументов никак не ограничивается.

#### Простые типы

Рассмотрим определенные функции `greet()`, которая по задумке принимает строковый аргумент `name` и возвращает строковое значение приветствие
```python
def greet(name):
    return f'Hello {name}!'
```
С помощью аннотаций типов можем переписать функцию в виде:
```python
def greet(name: str) -> str:
    return f'Hello {name}!'
```
Как мы видим, типы параметров, записываются после имени параметра через знак двоеточия, а тип возвращаемого значения функции записывается после знака "стрелки". Теперь программист просто взглянув на сигнатуру функции может понять, что функция принимает строку и возвращает строку. При этом можно понять, что если передать в ее другой тип, то она не сможет корректно отработать

Если некоторый аргумент имеет значение по умолчанию, то его тип должен предшествовать значения по умолчанию:
```python
def greet(name: str = 'world') -> str:
    return f'Hello, {name}!'
```
Точно так же можно использовать и любые другие базовые (не являющиеся коллекциями) типы в Python: `int`, `float`, `bool`, `str`, `NoneType`

***Пример 1*** Функция `print_hello()` принимает два аргумента типа `str` и `bool` и возвращает значение `None`
```python
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

***Пример 2*** Функция `avg()` принимает три аргумента типа `int()` и возвращает значение `float`
```python
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3
```
Как уже было сказано выше, помимо специального синтаксиса для объявления параметров функций и их возвращаемых значений в Python 3.6 стало можно объявлять типы переменных вообще в любом месте программы.

Вот так можно добавить аннотации типов к переменным в любом месте кода (Python 3.6+):
```python
name: str = 'VlaDICK'
age: int = 29
height: float = 171.5
is_married: bool = False
```
Можно также аннотировать переменные, не назначая им сразу значения:
```python
surname: str
gender: bool
```

#### Типы коллекций
Перейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно добавлять аннотации типов, используя сами имена классов `list, tuple, set. dict`:
```python
def sum_square(nums: list) -> int:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```
Это не слишком информативно, потому что кроме самого типа `list` было бы еще полезно знать, какие данные он в себе содержит. В нашем примере непонятно, списком каких типов является параметр `nums`.
В этом коде:
```python
numbers: list
person: tuple
prices: dict
answers: set
```
также неизвестно, какие данные должны хранится в коллекциях `numbers`, `person`, `prices` и `answers`

Начиная с Python 3.9 можно использовать стандартные классы, указывая их в квадратных скобках после указания типа коллекции, ничего ниоткуда не импортируя:
```python
numbers: list[int]                                # тип всех элементов списка
person: tuple[str, int, bool]                     # тип каждого элемента кортежа
prices: dict[str, int]                            # тип ключей, тип значений
answers: set[float]                               # тип всех элементов множества
```
В более ранних версиях необходимо использовать модуль `typing`
Документация модуля `typing` доступна по [ссылке](https://docs.python.org/3/library/typing.html).

Если нужно в аннотации указать что входной аргумент может быть двух типов, мы можем указать эти типы через `|`
```python
def get_digits(number: int|float) -> list[int]:
    return [int(item) for item in str(number) if item.isdigit()]
```
#### Атрибут `__annotations__`
Доступ к использованным в функции аннотациям можно получить через атрибут `__annotations__`, в котором аннотации представлены в виде словаря, где ключами являются названия параметров, а значениями - их типы. При этом, возвращаемое функцией значение хранится в записи с ключом `return`
```python
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3

print(avg.__annotations__)
```
```
{'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}
```

