#Python #рекурсия

Чтобы понять рекурсию, нужно сначала понять рекурсию
![[Pasted image 20240607114704.png|430]]

Рекурсия реализуется при помощи рекурсивных функций
Рекурсивная функция - это функция, которая вызывает сама себя
Вообще это такая штука, которую проще показать, чем рассказать

Рассмотрим рекурсивную функцию на примере функции `message()`, которая вызывает саму себя
```python
def message():
    print('Это рекурсивная функция')
    message()

message()
```
```
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
...
```
И этот результат будет повторяться бесконечно (почти)

Функция `message()` выводит на экран строку текста `Это рекурсивная функция`, а затем вызывает саму себя. При каждом вызове функцией самой себя цикл повторяется. Несложно заметить что при такой реализации функции `message()` в ней не предусмотрен способ остановки рекурсивных вызовов. Эта функция выглядит как бесконечный цикл, поскольку отсутствует программный код, который остановил бы ее бесконечные вызовы.

Вообще в таких случаях происходит переполнение аппаратного #стек и возбуждается исключение `RecursionError`

Подобно циклу, рекурсивная функция должна иметь определенный способ управлять количеством своих повторов.
```python
def message(times):
    if times > 0:
        print('Это рекурсивная функция')
        message(times - 1)

message(5)
```
```
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
Это рекурсивная функция
```
Теперь функция `message()` принимает аргументы `times`, который задает количество раз, которые функция должна выводить сообщение. Строка текста `Это рекурсивная функция` будет выводиться до тех пор, пока `times`больше нуля, при этом функция будет вызывать саму себя повторно, передавая уменьшенный на единицу аргумент.

Во время каждого вызова функция `mesasge()` в оперативной памяти создается новый экземпляр переменной `items`. При первом вызове функции `times` имеет значение 5. Когда функция себя вызывает, создается новый экземпляр переменной `times` и в него передается значение 4. "Этот цикл повторяется до тех пор, пока в функцию в качестве аргумента не будет передан 0

![[Pasted image 20240607121410.png]]

Как видно из рисунка, функция `message()` вызывается шесть раз. В первый раз она вызывается из основной программы, а остальные пять раз она вызывает саму себя. Количество раз, которые функция вызывает саму себя, называется ***глубиной рекурсии***. В этом примере глубина рекурсии равняется пяти. Кода функция достигает своего шестого вызова, значение переменно `times` равно 0. В этой точку условное выражение оператора `if` становится ложным, и поэтому функция завершает свою работу. Поток управления программы возвращается из шестого экземпляра функции в точку в пятом экземпляре непосредственно после вызова рекурсивной функции.

Поскольку после вызова рекурсивной функции больше нет инструкций, пятый экземпляр функции `message()` возвращает поток управления программы назад в четвертый экземпляр функции и т.д.

Что бы нагляднее это показать давайте модифицируем функцию `message()`, добавив строку кода, которая выводит текущее значение  переменной `items` после рекурсивного вызова.
```python
def message(times):
    if times > 0:
        print('Это рекурсивная функция.')
        message(times - 1)
        print(times)

message(5)
```
```
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
Это рекурсивная функция.
1
2
3
4
5
```
Сначала печатается значение 1, затем 2 и так далее до 5. То есть сначала выполняется `print(times)` в пятом экземпляре, затем в четвертом и так до первого

Рекурсия может оказаться мощным инструментом для решения повторяющихся задач. Задача может быть решена на основе рекурсии, если ее разделить на уменьшенные задачи, которые по структуре идентичны общей задаче.

При помощи рекурсии можно сделать все то же самое, что можно сделать при помощи циклов и наоборот. 

Рекурсивные алгоритмы обычно менее эффективны, чем итеративные алгоритмы. Это связано с тем, что процесс вызова функций требует выполнения итератором нескольких действий. Эти действия включают выделение памяти под параметры и локальные переменные и для хранения адреса местоположения программы. Таки действия, которые иногда называются накладными расходами, происходят при каждом вызове функции. Накладные расходы не требуются при использовании цикла.

Тем не менее некоторые повторяющиеся задачи легче решаются на основе рекурсии, чем на основе цикла. Там, где цикл приводит к более выстроенному времени исполнения, программист может быстрее разработать рекурсивный алгоритм. В целом рекурсивная функция работает следующим образом:
- если в настоящий момент задача может быть решена без рекурсии, то функция ее решает
- если в настоящий момент задача не может быть решена, то функция ее сводит к уменьшенной и при этом аналогичной задаче и вызывает саму себя для решения этой уменьшенной задачи

Для того чтобы применить такой подход, во-первых, мы идентифицируем по крайней мере один случай, в котором задача может быть решена без рекурсии. Он называется **базовым случаем**. Во-вторых, мы определяем то, как задача будет решаться рекурсивно во всех остальных случаях. Это называется **рекурсивным случаем**. В рекурсивном случае мы все время должны сводить задачу к уменьшенному варианту исходной задачи. С каждым рекурсивным вызовом задача уменьшается. В результате будет достигнут базовый случай, и рекурсия прекратится.

***Хвостовая рекурсия*** - частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции
```python
def message(times):
    if times > 0:
        print('Это рекурсивная функция')
        message(times - 1)
```
Пример функции с рекурсией, которая не является хвостовой:
```python
def message(times):
    if times > 0:
        print('Это рекурсивная функция.')
        message(times - 1)
        print(times)
```
Хвостовой вид рекурсии примечателен тем, что может быть легко заменён на итерацию путём корректной перестройки кода функции. Оптимизация хвостовой рекурсии путём преобразования её в итерацию реализована во многих языках программирования. В Python такой оптимизации нет.

Для полного понимания рекурсии стоит прочесть о ней [[Рекурсия|тут]]

LRU cache