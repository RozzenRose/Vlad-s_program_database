#python #хеш #хеширование 


Создание хорошей хеш-функции задача не из простых. Однако попытка создать хеш-функцию с нуля - отличный способ узнать, как работает хеширование

##### 1 версия хеш-функции
Хеш-функция перебирает все символы переданной строки и для каждого символа вычисляет его номер в таблице `Unicode` с помощью функции `ord()`, а затем вычисляет сумму всех полученных номеров:
```python
def hash_function(obj):
    return sum(ord(character) for character in obj)

print(hash_function('Python'))
```
```
642
```
Такая реализация хеш-функции содержит серьезную проблему, она работает только со строковым аргументом

##### 2 версия хеш-функции
Хеш-функция сначала преобразует переданный объект в строку с помощью функции `str()`, а затем выполняет указанное выше преобразование:
```python
def hash_function(obj): 
	return sum(ord(character) for character in str(obj))

print(hash_function('Python'))
print(hash_function(123))
print(hash_function(12.34))
print(hash_function(None))
print(hash_function(True))
```
```
642
150
248
400
416
```
Теперь хеш-функция работает с объектом любого типа. Однако новая версия хеш-функции все еще содержит проблемы. Очевидно, что небольшое изменение начальных данных мало влияет на итоговое хеш-значение. В этом несложно убедиться, если поменять последний символ переданной строки
```python
print(hash_function('Python'))
print(hash_function('Pythoo'))
print(hash_function('Pythop'))
```
```
642
643
644
```
Такая функция не чувствительна к порядку символов во входных данных, а это значит, что анаграммы одного и того же слова, такие как `Python` и `Ypthon`, приводят к возникновению коллизий

Что бы избежать таких приколов, можно использовать не только порядковый номер символа в таблице `Unicode`, но и его позиционный индекс в изначальных данных

##### 3 версия хеш-функции
Здесь мы берем сумму произведений, полученных путем умножения порядковых значений символов и их соответствующих индексов. Стоит обратить внимание, что индексы пронумерованы с `1`, а не с `0`Ю в противном случае первый символ всегда будет отбрасываться, так как его значение будет умножаться на ноль
```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1))

print(hash_function('Python'))
print(hash_function('yPthon'))
print(hash_function('thonPy'))
```
```
2301
2260
2223
```
Теперь наша хеш-функция довольно универсальна и не приводит к возникновению большого количества коллизий. Можно заметить, что чем больше входные данные, тем больше будет хеш-значение
```python
print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```
```
2301
2380463000
187200003610000000
```
Но мы всегда может справится с неограниченным простом при помощи оператора `%`:
```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1)) % 123456761

print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```
```
2301
34784541
116170254
```
Использование оператора `%` позволяет загнать вычисляемое хеш-значение в нужный диапазон. В нашем случае получаем, что хеш-значения будут в диапазоне `[0; 123456761]`. Однако нужно помнить, что выбор меньшего пула хеш-значений увеличивает вероятность возникновения коллизий. В качестве максимального количества хеш-значения рекомендуется использовать большую константу (желательно просто число)