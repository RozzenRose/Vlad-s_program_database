#python #исключения #ошибки #try-except

![[Pasted image 20240605144625.png]]
Далеко не для каждой ошибки можно выполнить обработку так, чтобы программа продолжала выполняться. Однако в некоторых случаях такая обработка может быть выполнена. Собственно, о таких потенциально "отлавливаемых" ошибках, их перехвате и обработке будет идти речь в этой статье.

Общая идея, заложенная в основу метода обработки исключений, такая: программный код, в котором теоретически может возникнуть ошибка, выделяется специальным образом – "берется на контроль". Если при выполнении этого программного кода ошибка не возникает, то ничего особенного не происходит. Если при выполнении "контролируемого" кода возникает ошибка, то выполнение кода останавливается и автоматически создается объект-исключение, содержащий описание возникшей ошибки.

С практической точки зрения мы можем думать об исключении как о некотором сообщении, которое генерируется интерпретатором Python в силу возникшей ошибки при выполнении кода или из-за некоторых других обстоятельств, близких по своей природе к ошибке выполнения кода. Хотя ошибка и исключение – это не одно и то же (исключение является следствием ошибки), мы обычно отождествляем эти понятия.

Для обработки исключительных ситуаций в языке Python используется конструкция [[try-except]]Существуют разные вариации использования этой конструкции. Мы начнем с наиболее простой.
#### Пример обработки исключений
После ключевого слова `try` и двоеточия размещается блок программного кода, который мы подозреваем на предмет возможного возникновения ошибки. Этот код будем называть ***контролируемым***. По завершении этого блока указывается ключевое слово `except` (с двоеточием), после которого идет еще один блок программного кода. Этот код будем называть ***кодом обработки ошибки (исключения)***.
```python
try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
```
Если при выполнении кода в блоке `try` ошибка не возникла, то код обработки ошибки (исключения) в блоке `except` выполняться не будет.  Если при выполнении кода в блоке `try` возникла ошибка, то выполнение кода `try` блока прекращается, и выполняется код обработки ошибки (исключения) в блоке `excet`. После этого управление передается следующей команде после конструкции `try-except`.

Рассмотрим пример использования инструкции `try-except`. Контролируемый код содержит считывание данных от пользователя с последующей конвертацией к числовому типу `int` и выводом частного введенных чисел.
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')

print('Работа программы завершена!')
```
Результатом выполнения этого программного кода зависит от того, какие значения будут введены. Рассмотрим несколько ситуаций.

**Ситуация 1.** На вход подаются два ненулевых целых числа, например `10` и `2`. Тогда результатом выполнения кода будет:
```no-highlight
Частное чисел равно 5.0
Работа программы завершена!
```

**Ситуация 2.** На вход подаются не числа, а строки, например `abc` и `qwerty`. Тогда результатом выполнения кода будет:
```no-highlight
Вы ввели некорректные данные!
Работа программы завершена!
```

**Ситуация 3.** На вход подаются два целых числа, второе из которых ноль, например `10` и `0`. Тогда результатом выполнения кода будет:
```no-highlight
Вы ввели некорректные данные!
Работа программы завершена!
```

Такой код не будет различать типы ошибок. Блок `Except` будет запускаться при возникновении любого исключения.

#### Обработка нескольких исключений
Более утонченная обработка ошибок (исключительных ситуаций) подразумевает более индивидуальный подход. Речь идет о том, чтобы обработка ошибок базировалась на типе или характере ошибки. Разумеется, это возможно. Причем описанная выше схема обработки исключений претерпевает минимальные изменения. В конструкции `try-except` после блока `try` указывается несколько `ехсерt` блоков, причем для каждого блока явно указывается тип ошибки (исключения), который обрабатывается в этом блоке. Ключевое слово, определяющее тип ошибки, указывается после ключевого слова `except` соответствующего блока.
```python
try:
   
except тип_ошибки_1:  # контролируемый код
   
except тип_ошибки_2:  # код обработки ошибки (исключения)
    
...
except тип_ошибки_n: # код обработки ошибки (исключения)

```
Этот код выполняется следующим образом. Выполняются команды `try` блока. Если возникал ошибка, то выполнение команд `try` блока прекращается и начинается ***последовательный просмотр*** `except` блоков на предмет совпадения типа ошибки, которая возникла, и типа ошибки, указанного после ключевого слова в `except` блоке. Как только совпадение найдено, выполняются команды соответствующего `except` блока, после чего управление переходит к команде после конструкции `try-except`

Если при переборе `except` блоков совпадение по типу ошибки не найдено, выполнение кода прекращается и повторяется сообщение об ошибке. Если при выполнении `try` блока ошибок не было, коды в `except` блоках не выполняются. 

Исправим код из прошлого примера так, что бы он начал различать ошибки:
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except ValueError:
    print('Нужно было ввести числа!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')

print('Работа программы завершена!')
```
Как мы видим, по сравнению с предыдущим примером изменилась только та часть кода, что связана с `except` блоками. Теперь мы имеем два `except` блока. После первого ключевого слова `except` указанно название `ValueError`. К типу `ValueError` относятся ошибки, возникающие при передаче в функцию аргумента с неподдерживаемым значением. Во втором `except` блоке обрабатываются ошибки типа `ZeroDivisionError`. К этому типу относятся ошибки, возникающие при попытке выполнить деление на ноль.

Стоит также обратить внимание на следующее обстоятельство: обрабатываются в данном случае только ошибки типов `ValueError` и `ZeroDivisionError`. Если бы теоретически возникла ошибка какого-то иного типа, то она бы перехвачена не была.

В рассмотренном выше примере мы создали для разных типов ошибок разные `except` блоки. Иногда приходится для нескольких типов ошибок создавать один `except` блок. В этом случае после ключевого слова `except` в круглых скобках через запятую перечисляются те типы ошибок, для которых выполняется обработка в данном блоке.
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError):
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except:
    print('Если не сработал ни один из предыдущих блоков except.')

print('Работа программы завершена!')
```
В этом примере последний блок `except` будет обрабатывать любое исключение, кроме тех, которые были указаны в блоках `except` выше.

#### Необязательный блок `else`
Помимо блоков `try` и `except`, в инструкции `try-except` может также использоваться необязательный блок `else`.

Блок `else` размещается после последнего `ехсерt` блока и содержит программный код, который **выполняется только в том случае**, если при выполнении кода в `trу` блоке ошибок (исключений) не было.
```python
try:

except тип_ошибки_1:    # контролируемый код

except тип_ошибки_2:    # код обработки ошибки (исключения)

...
except тип_ошибки_n:    # код обработки ошибки (исключения)

else:    # код обработки ошибки (исключения)

```
Рассмотрим код:
```python
try:
    num = int(input())
    print('Квадрат числа равен:', num ** 2)
except ValueError:
    print('Вы ввели некорректные данные!')
else:
    print('Ошибки не произошло!')

print('Работа программы завершена!')
```
Результаты выполнения этого кода зависят от того, какое значение будет введено. Рассмотрим ситуации:

**Ситуация 1.** На вход подается целое число, например `10`. Тогда результатом выполнения кода будет:
```
Квадрат числа равен: 100
Ошибки не произошло!
Работа программы завершена!
```

**Ситуация 2.** На вход подается не число, а строка, например, `abc`. Тогда результатом выполнения кода будет:
```
Вы ввели некорректные данные!
Работа программы завершена!
```
Блок `else` в конструкции `try-except` подобен блоку `else` в конструкциях `for/while`. Он срабатывает если в контролируемом коде не произошло ошибок (если тело цикла завершилось штатным способом, без `break`)



#### Необязательный блок `finally`
Помимо необязательного блока `else`, в инструкции `try-except`  можно также использовать необязательный блок `finally`

Блок `finally` размещается после последнего `except` блока, либо после блока `else`, если он присутствует и содержит программный код, который ***выполняется в любом случае***, независимо от того, возникла ошибка (исключение) при выполнении кода `try` блока или нет.
Шаблон:
```python
try:

except тип_ошибки_1:    # контролируемый код

except тип_ошибки_2:    # код обработки ошибки (исключения)

...
except тип_ошибки_n:    # код обработки ошибки (исключения)

finally:    # код, который выполняется всегда

```
Инструкции внутри блока `finally` будут выполнены, даже если блок `try` содержит `break, continue, return`
В случае  если `finally` упакован в функцию, код внутри блока будет выполняться до команды `return`

Рассмотрим код:
```python
try:
    num = int(input())
    print('Квадрат числа равен:', num ** 2)
except ValueError:
    print('Вы ввели некорректные данные!')
finally:
    print('Блок кода выполняется всегда!')

print('Работа программы завершена!')
```
Результат выполнения этого кода зависит от того, какое значение будет введено. Рассмотрим варианты:
**Ситуация 1.** На вход подается целое число, например, `10`. Тогда результатом выполнения кода будет:
```
Квадрат числа равен: 100
Блок кода выполняется всегда!
Работа программы завершена!
```

**Ситуация 2.** На вход подается не число, а строка, например, `abc`. Тогда результатом выполнения кода будет:
```
Вы ввели некорректные данные!
Блок кода выполняется всегда!
Работа программы завершена!
```
Блок `finally` располагается после блока `else`, в случае присутствия последнего.

Блок `finally` особенно удобен при работе с файлами, которые нужно обязательно закрывать, независимо от того, произошла ошибка (исключение) или нет.
```python
try:
    file = open('data.txt', encoding='utf-8')
    try:
        text = file.read()
    except:
        print('При чтении из файла произошла ошибка!')
    else:
        print('Чтение из файла прошло успешно!')
    finally:
        file.close()
except FileNotFoundError:
    print('Файл с указанным именем не найден!')
```
демонстрирует возможность использования блока `finally`. В этом коде файл будет закрыт в любом случае, вне зависимости от того, произошла ошибка или нет. Обратите также внимание на вложенность блоков `try-except`.

Блок `finally` может также использоваться без блоков `except` и `else`. В этом случае, если в блоке `try` возникает ошибка (исключение), то сначала выполняется блок `finally`, а затем ошибка (исключение) продолжает «всплывание» к обработчику более высокого уровня.
```python
try:
    file = open('data.txt', encoding='utf-8')
    try:
        text = file.read()
    finally:
        file.close()
except FileNotFoundError:
    print('Файл с указанным именем не найден!')
except:
    print('Произошла ошибка!')
```
В этом случае ошибка не будет обработана, и будет проверена блоками `except` более высокого уровня, если их нет, выполнение кода будет остановлено:
```python
try:
    х = 10 / 0
finally:
    print('Блoк finally')
```
```
Блoк finally
Traceback (most recent call last):
  File "main.py", line 2, in <module>
    х = 10 / 0
ZeroDivisionError: division by zero
```

#### Основные типы исключений

|Тип исключения|Описание|
|---|---|
|`BaseException`|является классом самого верхнего уровня и базовым для всех прочих  <br>классов исключений|
|`Exception`|базовый класс для большинства встроенных в Python исключений. Именно  <br>его, а не `BaseException`, необходимо наследовать при создании пользовательского класса  <br>исключения|
|`AssertionError`|возбуждается инструкцией `assert`|
|`AttributeError`|возбуждается при попытке обращения к несуществующему атрибуту объекта|
|`EOFError`|возбуждается функцией `input()` при достижении конца файла с вводными данными|
|`ImportError`|возбуждается, если невозможно импортировать модуль или пакет|
|`IndexError`|возбуждается при попытке получить элемент коллекции по несуществующему индексу|
|`KeyError`|возбуждается при попытке получить элемент коллекции по несуществующему ключу|
|`MemoryError`|возбуждается, если интерпретатору существенно не хватает оперативной памяти|
|`NameError`|возбуждается при попытке обратиться к необъявленной переменной|
|`TypeError`|возбуждается при несоответствии типов|
|`ValueError`|возбуждается при передаче в функцию аргумента с неподдерживаемым значением|
|`ZeroDivisionError`|возбуждается при попытке выполнить деление на ноль|
|`NotImplementedError`|возбуждается, если наследник класса не переопределил метод, который должен был переопределить|

#### Работа с объектом возбужденного исключения
Если нужен доступ к сгенерированному исключению как к объекту, то используется специальный синтаксис.
```python
try:
    nums = [10, 5, 20, 25]
    print(nums[100])
except (KeyError, IndexError) as err:    # записываем сгенерированное исключение в переменную err
    print(err)
    print(type(err))
```
```1c
list index out of range
<class 'IndexError'>
```
В этом примере в переменную `err` попадает объект типа `IndexError`

Посмотреть все атрибуты объекта сгенерированного исключения можно с помощью функции `dir()`
```python
try:
    print(1 / 0)
except ZeroDivisionError as err:
    print(dir(err))
```
```
['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']
```
Наибольший интерес представляет из себя атрибут `args`

Если при обработке всех исключений одним блоком `except` мы хотим получить доступ к объекту исключения, то нужно явно указать его тип.
```python
try:
    х = 1 / 0
except Exception as err:
    print(err)
```

Для получения информации об исключении можно воспользоваться функцией `exc_info()` из модуля `sys`. данная функция возвращает кортежи из трех значений: типа исключения, значения и объекта с трассировочной информацией об исключении, которое в данный момент обрабатывается.
```python
from sys import exc_info

try:
    х = 1 / 0
except Exception as err:
    print(exc_info())
```
```no-highlight
(<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 
```
Можно еще представить все это в удобный вид при помощи модуля `traceback`

Для того, что бы вытащить конкретное имя ошибки можно запросить атрибут `__name__`
```python
try:
    х = 1 / 0
except Exception as err:
    print(type(err).__name__)
    print(err.__class__.__name__)
```
```
ZeroDivisionError
ZeroDivisionError
```
#### [[Пользовательские исключения]]
#### [[Оператор assert]] проверки работоспособности кода
#### [[try-except]] перехват исключений в кода в конкретных местах