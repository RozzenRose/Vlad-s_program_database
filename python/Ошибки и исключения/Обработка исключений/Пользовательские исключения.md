#python #исключения #ошибки #try-except

![[Pasted image 20240606012630.png]]
В Python можно создавать собственные типы исключений. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана программа.

Для создания собственного типа исключения необходимо создать класс, являющийся потомком (наследником) одного их уже существующего типа исключения. Как уже было сказано в прошлом уроке, самым верным вариантом является класс `Exception`
```python
class NegativeAgeError(Exception):
    pass
```
Описывает новый тип исключения с именем `NegativeAgeError`, который является потомком класса `Exception`. Класс `Excention` содержит весь необходимый функционал, позволяющий работать с исключениями, поэтому в большинстве случаев достаточно создать пустой класс, который является потомком класса `Exeption`. Теперь мы можем работать с типом исключения `NegativeAgeError`, к с любым встроенным исключением.
```python
try:
    print('Введите свой возраст')
    age = int(input())
    if age < 0:
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age)
except ValueError:
    print('Возраст должен быть числом')
except NegativeAgeError as e:
    print(e)
```
при вводе некорректных значений приводит к возбуждению соответствующих типов исключений:
- `ValueError` – при нечисловых значениях 
- `NegativeAgeError` – при отрицательных числовых значениях
#### Методики LBYL и EAFP
При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:
- **LBYL (Look Before You Leap)** — посмотри перед прыжком
- **EAFP (Easier to Ask Forgiveness than Permission)** — проще извиниться, чем спрашивать разрешение

Рассмотрим код:
```python
data = {'Timur': 29, 'Ivan': 54}

data['Anri'] += 1
```
приводит к возникновению исключения `KeyError`, поскольку ключ `Anri` отсутствует в словаре

Мы можем исправить такой код двумя способами

**Способ 1.** Перестраховаться и заранее проверить, что все получится. Это идеология LBYL-подхода. 
```python
data = {'Timur': 29, 'Ivan': 54}

if 'Anri' in data:
    data['Anri'] += 1
else:
    print('Ключ Anri отсутствует в словаре.')
```
Аналогия с LBYL-подходом такая: поглядели на светофор, потом по сторонам. Если горит зеленый свет и нет препятствий, можно переходить. 

**Способ 2.** Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода EAFP. 
```python
data = {'Timur': 29, 'Ivan': 54}

try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri отсутствует в словаре.')
```

Да я знаю, что можно через метод `get()` к словарям обращаться не вызывая исключений, иди нахуй умник!

Насколько я понимаю, EAFP подход позволяет писать более лаконичный и аккуратный код без миллиарда проверок. Но вроде, как он должен получаться в среднем медленнее, чем LBYL - код, поскольку исключения сравнительно долго обрабатываются интерпретатором. Имеет смысл на эту тему поискать инфы отдельно