#python #исключения #ошибки


![[Pasted image 20240605153236.png]]
Можно конечно возбуждать исключения допуская намеренные ошибки в коде, но вообще для этого есть специальный функционал.

Для возбуждения исключений используется оператор `raise`. В качестве аргумента оператор `raise` использует экземпляр класса, унаследованного от `Exception`(`Иерархия исключений`). Класс указывает на тип исключения, а аргумент, передаваемый конструктору этого исключения, обычно описывает подробности возникновения исключительной ситуации.

Если возбуждаемые пользователем исключения не перехватываются, то они распространяются вплоть до стандартного обработчика исключений и прекращают работу программы с выводом стандартного сообщения об ошибке. А перехватываются они стандартными методами.
```python
try:
    raise IndexError('ошибочка')             # возбуждение исключения вручную
except Exception as err:
    print(err)
    print(type(err)) 
```
```
ошибочка
<class 'IndexError'>
```
Еще пример:
```python
def get_month_name(index):
    if not index.isdigit():
        raise TypeError('Аргумент должен быть числом.')
    if int(index) < 1 or int(index) > 12:
        raise ValueError('Аргумент должен быть целым числом от 1 до 12.')
     ...
```

Оператор возбуждения исключений `raise` имеет несколько вариантов формата:
- `raise` <экземпляр класса>
- `raise` <название класса>
- `raise` <экземпляр или название класса> `from` <объект исключения>
- `raise`

***В первом варианте*** оператора `raise` указывается экземпляр класса возбуждаемого исключения с аргументами при необходимости.
```python
raise ValueError('Описание исключения')
```

***Во втором варианте*** оператора `raise`  указывается только название класса исключения
```python
raise ValueError # эквивалентно: raise ValueError()
```

***В третьем варианте*** оператора `raise` сначала указывается экземпляр класса или просто название класса, а потом объект исключения, на основании которого создается новое исключение. В этом случае объект исходного исключения сохраняется в атрибуте `__cause__`. При обработке вложенных исключений эти данные используются для вывода информации не только о последнем исключении, но и о первоначальном исключении.
```python
try:
    х = 1 / 0
except Exception as err:
   raise ZeroDivisionError('Описание исключения') from err
```

***В четвертом варианте*** оператора `raise` мы повторно возбуждаем и пробрасываем выше последнее перехваченное исключение.
```python
try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
```


Сам механизм исключений достаточно медленный, поэтому, например, не очень хорошей идеей будет возбуждать исключение внутри цикла, когда мы точно знаем, что их будет достаточно большое количество.

При помощи `raise`  можно пробросить перехваченное исключение на уровень выше в процессе его обработки:
```python
try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
```

При создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор исключения принимает переменное количество аргументов.
```python
try:
    raise ValueError('Произошла ошибка')
except ValueError as e:
    print(e)
```
```python
Произошла ошибка
```
Примечательно то, что при передаче переменной с исключением в функцию `print()`
происходит вывод именно тех аргументов, которые были указаны при создании объекта исключения. И если таких аргументов было передано несколько, они будут выведены все в виде кортежа.
```python
try:
    raise ValueError('Ой', 'Произошла ошибка')
except ValueError as e:
    print(e)
```
```no-highlight
('Ой', 'Произошла ошибка')
```
 Для того чтобы получить указанные значения, мы используем атрибут `args`, который является кортежем.
```python
try:
    x, y = 10, 0
    if y == 0:
        raise ZeroDivisionError('Произошло деление на ноль.')
except ZeroDivisionError as err:
    print(err)
    print(err.args)
    print(type(err.args))
```
```
Произошло деление на ноль.
('Произошло деление на ноль.',)
<class 'tuple'>
```
