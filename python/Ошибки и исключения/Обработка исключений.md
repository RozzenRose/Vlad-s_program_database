#python #исключения #ошибки #try-except


Далеко не для каждой ошибки можно выполнить обработку так, чтобы программа продолжала выполняться. Однако в некоторых случаях такая обработка может быть выполнена. Собственно, о таких потенциально "отлавливаемых" ошибках, их перехвате и обработке будет идти речь в этой статье.

Общая идея, заложенная в основу метода обработки исключений, такая: программный код, в котором теоретически может возникнуть ошибка, выделяется специальным образом – "берется на контроль". Если при выполнении этого программного кода ошибка не возникает, то ничего особенного не происходит. Если при выполнении "контролируемого" кода возникает ошибка, то выполнение кода останавливается и автоматически создается объект-исключение, содержащий описание возникшей ошибки.

С практической точки зрения мы можем думать об исключении как о некотором сообщении, которое генерируется интерпретатором Python в силу возникшей ошибки при выполнении кода или из-за некоторых других обстоятельств, близких по своей природе к ошибке выполнения кода. Хотя ошибка и исключение – это не одно и то же (исключение является следствием ошибки), мы обычно отождествляем эти понятия.

Для обработки исключительных ситуаций в языке Python используется конструкция [[try-except]]Существуют разные вариации использования этой конструкции. Мы начнем с наиболее простой.

#### Пример обработки исключений
После ключевого слова `try` и двоеточия размещается блок программного кода, который мы подозреваем на предмет возможного возникновения ошибки. Этот код будем называть ***контролируемым***. По завершении этого блока указывается ключевое слово `except` (с двоеточием), после которого идет еще один блок программного кода. Этот код будем называть ***кодом обработки ошибки (исключения)***.
```python
try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
```
Если при выполнении кода в блоке `try` ошибка не возникла, то код обработки ошибки (исключения) в блоке `except` выполняться не будет.  Если при выполнении кода в блоке `try` возникла ошибка, то выполнение кода `try` блока прекращается, и выполняется код обработки ошибки (исключения) в блоке `excet`. После этого управление передается следующей команде после конструкции `try-except`.

Рассмотрим пример использования инструкции `try-except`. Контролируемый код содержит считывание данных от пользователя с последующей конвертацией к числовому типу `int` и выводом частного введенных чисел.
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')

print('Работа программы завершена!')
```
Результатом выполнения этого программного кода зависит от того, какие значения будут введены. Рассмотрим несколько ситуаций.

**Ситуация 1.** На вход подаются два ненулевых целых числа, например `10` и `2`. Тогда результатом выполнения кода будет:
```no-highlight
Частное чисел равно 5.0
Работа программы завершена!
```

**Ситуация 2.** На вход подаются не числа, а строки, например `abc` и `qwerty`. Тогда результатом выполнения кода будет:
```no-highlight
Вы ввели некорректные данные!
Работа программы завершена!
```

**Ситуация 3.** На вход подаются два целых числа, второе из которых ноль, например `10` и `0`. Тогда результатом выполнения кода будет:
```no-highlight
Вы ввели некорректные данные!
Работа программы завершена!
```

Такой код не будет различать типы ошибок. Блок `Except` будет запускаться при возникновении любого исключения.

#### Обработка нескольких исключений
Более утонченная обработка ошибок (исключительных ситуаций) подразумевает более индивидуальный подход. Речь идет о том, чтобы обработка ошибок базировалась на типе или характере ошибки. Разумеется, это возможно. Причем описанная выше схема обработки исключений претерпевает минимальные изменения. В конструкции `try-except` после блока `try` указывается несколько `ехсерt` блоков, причем для каждого блока явно указывается тип ошибки (исключения), который обрабатывается в этом блоке. Ключевое слово, определяющее тип ошибки, указывается после ключевого слова `except` соответствующего блока.
```python
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
```
Этот код выполняется следующим образом. Выполняются команды `try` блока. Если возникал ошибка, то выполнение команд `try` блока прекращается и начинается ***последовательный просмотр*** `except` блоков на предмет совпадения типа ошибки, которая возникла, и типа ошибки, указанного после ключевого слова в `except` блоке. Как только совпадение найдено, выполняются команды соответствующего `except` блока, после чего управление переходит к команде после конструкции `try-except`

Если при переборе `except` блоков совпадение по типу ошибки не найдено, выполнение кода прекращается и повторяется сообщение об ошибке. Если при выполнении `try` блока ошибок не было, коды в `except` блоках не выполняются. 

Исправим код из прошлого примера так, что бы он начал различать ошибки:
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except ValueError:
    print('Нужно было ввести числа!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')

print('Работа программы завершена!')
```
Как мы видим, по сравнению с предыдущим примером изменилась только та часть кода, что связана с `except` блоками. Теперь мы имеем два `except` блока. После первого ключевого слова `except` указанно название `ValueError`. К типу `ValueError` относятся ошибки, возникающие при передаче в функцию аргумента с неподдерживаемым значением. Во втором `except` блоке обрабатываются ошибки типа `ZeroDivisionError`. К этому типу относятся ошибки, возникающие при попытке выполнить деление на ноль.

Стоит также обратить внимание на следующее обстоятельство: обрабатываются в данном случае только ошибки типов `ValueError` и `ZeroDivisionError`. Если бы теоретически возникла ошибка какого-то иного типа, то она бы перехвачена не была.

В рассмотренном выше примере мы создали для разных типов ошибок разные `except` блоки. Иногда приходится для нескольких типов ошибок создавать один `except` блок. В этом случае после ключевого слова `except` в круглых скобках через запятую перечисляются те типы ошибок, для которых выполняется обработка в данном блоке.
```python
try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError):
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except:
    print('Если не сработал ни один из предыдущих блоков except.')

print('Работа программы завершена!')
```
В этом примере последний блок `except` будет обрабатывать любое исключение, кроме тех, которые были указаны в блоках `except` выше.



#### Основные типы исключений
Самые часто встречающиеся типы исключений:
- `IndexError`: возникает, когда индекс (например, для элемента списка) указан неправильно (выходит за границы допустимого диапазона)
- `KeyError`: возникает при неверно указанном ключе словаря
- `NameError`: возникает, если не удается найти переменную с некоторым названием
- `SyntaxError`: возникает при наличии в исходном коде синтаксических ошибок
- `TypeError`: возникает при несоответствии типов, когда для обработки требуется значение определенного типа, а передается значение другого типа
- `FileNotFoundError`: возникает при открытии несуществующего файла
- `ValueError`: возникает, когда в функцию передается аргумент с неподдерживаемым значением
- `ZeroDivisionError`: возникает при попытке выполнить деление на ноль