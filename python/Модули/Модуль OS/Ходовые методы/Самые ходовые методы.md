#python #OS #методы


Это самые часто используемые методы модуля `OS`:
- `os.path()` - отличный подмодуль для путей, ос советую (позволяет работать с путями кросплатформенно  и не думать о разных особенностях, вроде направления слеша), самое тут полезное, которое 100% пригодится
- `os.kill()`- отправляет сигнал процессу.
- `os.makedirs()` - рекурсивно создаёт директории.
- `os.listdir()` - список файлов и директорий в папке.
- `os.walk()` - герация имен файлов и директорий в дереве каталогов
- `os.rename()` - переименование файлов и директорий
- `os.system()` - пересылает терминальные команды в в подоболочку `subshell`
- `os.environ()` -  предоставляет доступ к переменным окружения операционной системы
- `os.name()` - позволяет узнать что за ос
#### os.kill()
```python
import os
os.kill(pid, sig)
```
- `pid`: Целое число, представляющее **идентификатор процесса**, которому нужно отправить сигнал.
- `sig`: Целое число, представляющее **номер сигнала** или **константу сигнала**, доступную на хост-платформе и определенную в модуле `signal`.

1. **Отправка сигнала SIGTERM процессу**: В этом примере скрипт создает дочерний процесс с помощью `os.fork()`, получает его **идентификатор процесса (PID)** и пытается отправить сигнал **SIGTERM** дочернему процессу с помощью `os.kill()`. В зависимости от успешности передачи сигнала выводится соответствующее сообщение:
```python
import os
import signal

# Определение PID целевого процесса
pid = os.fork()

try:
    os.kill(pid, signal.SIGTERM)
    print(f"Отправлен сигнал SIGTERM процессу {pid}")
except OSError:
    print(f"Не удалось отправить сигнал SIGTERM процессу {pid}")
```

2. **Приостановка дочернего процесса с помощью сигнала SIGSTOP**: В этом примере скрипт создает дочерний процесс с помощью `os.fork()`. Родительский процесс отправляет дочернему процессу сигнал **SIGSTOP**, вызывая его приостановку. Затем получается информация о статусе дочернего процесса с помощью `os.waitpid()` и выводится сигнал, вызвавший остановку дочернего процесса:
```python
import os
import signal

pid = os.fork()

if pid:
    print("В родительском процессе")
    os.kill(pid, signal.SIGSTOP)
    print("Сигнал отправлен, дочерний процесс приостановлен.")
    info = os.waitpid(pid, os.WSTOPPED)
    stop_signal = os.WSTOPSIG(info[1])
    print(f"Дочерний процесс остановлен сигналом №{stop_signal}")
    print(f"Имя сигнала: {signal.Signals(stop_signal).name}")
    os.kill(pid, signal.SIGCONT)
    print("\nСигнал отправлен, дочерний процесс продолжил выполнение.")
else:
    print("\nВ дочернем процессе")
    print(f"Идентификатор процесса: {os.getpid()}")
    print("Привет, братан!")
    print("Завершение работы")
```
```
В родительском процессе
Сигнал отправлен, дочерний процесс приостановлен.
Дочерний процесс остановлен сигналом №19
Имя сигнала: SIGSTOP

Сигнал отправлен, дочерний процесс продолжил выполнение.

В дочернем процессе
Идентификатор процесса: 21
Привет, братан!
Завершение работы

```
#### os.makedirs()
Создание вложенных директорий с помощью метода:
```python
import os

# Директория "ihritik"
directory = "ihritik"
parent_dir = "/home/User/Documents/GeeksForGeeks/Authors"
path = os.path.join(parent_dir, directory)
os.makedirs(path)
print(f"Директория '{directory}' создана")

# Директория "c"
directory = "c"
parent_dir = "/home/User/Documents/GeeksforGeeks/a/b"
mode = 0o666  # Режим доступа
path = os.path.join(parent_dir, directory)
os.makedirs(path, mode)
print(f"Директория '{directory}' создана")
```
```
Директория 'ihritik' создана
Директория 'c' создана
```


#### os.listdir()
Возвращает список директорий и файлов в указанной директории. Если директория не указана, вернутся список директорий и файлов в текущей директории.

Файлы в текущей директории:
```python
import os

# os.listdir() возвращает список файлов и директорий в текущей рабочей директории
dir_list = os.listdir()
print("Файлы и директории в текущей рабочей директории:")
print(dir_list)
```

Файлы в корневой директории:
```python
import os

# Получение списка всех файлов и директорий
path = "/"
dir_list = os.listdir(path)
print("Файлы и директории в '", path, "':")
# Вывод списка
print(dir_list)
```

#### os.walk()
Генерирует имена файлов и директорий в дереве каталогов, обходя дерево сверху вниз или снизу вверх. Для каждой директории в дереве, начиная с указанной верхней директории, он возвращает объект типа `tuple` (dirpath, dirnames, filenames)
```python
import os

# Путь к директории, которую нужно обойти
top_path = "/path/to/directory"

# Обход директории
for dirpath, dirnames, filenames in os.walk(top_path):
    # Вывод пути текущей директории
    print(f"Текущая директория: {dirpath}")
    # Вывод поддиректорий в текущей директории
    print(f"Поддиректории: {dirnames}")
    # Вывод файлов в текущей директории
    print(f"Файлы: {filenames}")
    print("-------------------------------")
```
Этот скрипт выведет структуру каталогов, начиная с `top_path`, показывая пути к каждой директории и списки содержащихся в них поддиректорий и файлов. 

#### os.rename()
Переименовывает файлы и директории
```python
import os

# Указываем текущее имя файла и новое имя файла
current_name = "old_file.txt"
new_name = "new_file.txt"

# Переименовываем файл
os.rename(current_name, new_name)
print("Файл успешно переименован!")
```

#### os.system()
 Метод `os.system()` в **Python** используется для выполнения команды (в виде строки) в подоболочке (subshell). Этот метод реализован с помощью вызова стандартной функции на языке C `system()` с некоторыми ограничениями. Если команда генерирует какой-либо вывод, он отправляется в стандартный поток вывода интерпретатора.

1. Получение текущей даты: 
```python
import os

# Выполнение команды "date"
os.system('date')
```
```
The current date is: 22-May-24 
Enter the new date: (dd-mm-yy)
```
2. Запуск приложения Notpad:
```python
import os

# Запуск Notepad
os.system('notepad')
```

#### os.environ()
Метод `os.environ` в **Python** предоставляет доступ к переменным окружения операционной системы. Это словароподобный объект, который содержит все переменные окружения в виде пар ключ-значение
```python
import os

# Получение значения переменной окружения 'HOME'
home_directory = os.environ.get('HOME')
print(f"Домашний каталог пользователя: {home_directory}")

# Установка новой переменной окружения
os.environ['MY_VARIABLE'] = 'my_value'
print(f"Значение MY_VARIABLE: {os.environ['MY_VARIABLE']}")

# Вывод всех переменных окружения
print("Все переменные окружения:")
for key, value in os.environ.items():
    print(f"{key}={value}")
```