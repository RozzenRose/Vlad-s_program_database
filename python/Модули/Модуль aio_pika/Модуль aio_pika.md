#aio_pika #RabbitMQ

`aio_pika` - это высокоуровневая обёртка над aiormq, для асинхронной работы с **AMQP**/**RabbitMQ**
#### Основные сущности:
- `Connection` — соединение с брокером
- `Channel` — канал в соединении
- `Exchange` — точка, куда публикуют сообщения
- `Queue` — очередь, из которой получают
- `Message` / `IncomingMessage` — объект сообщения
- Различные вспомогательные объекты: robust-версии, подтверждения и т.д.
#### Подробнее:

|Класс / интерфейс|Назначение|Основные методы / свойства|
|---|---|---|
|`Connection` / `RobustConnection`|Управляет соединением с RabbitMQ|- `channel()` — создать канал - `close()` — закрыть соединение - У `RobustConnection` есть логика авто-переподключения (reconnect) ([GitHub](https://github.com/mosquito/aio-pika/blob/master/aio_pika/robust_connection.py?utm_source=chatgpt.com "aio-pika/aio_pika/robust_connection.py at master - GitHub"))|
|`Channel`|Канал внутри соединения (для работы с обменами/очередями)|- `declare_queue(...)` — объявить очередь - `declare_exchange(...)` — объявить exchange - `default_exchange` — свойство, стандартный exchange - `set_qos(...)` — установить качество обслуживания (prefetch) - `close()`, `is_closed` и др. - `publish(...)` у exchange (см. ниже)|
|`Exchange`|Обмен сообщений (point of routing)|- `publish(message, routing_key, ...)` — публиковать сообщение в обмен - И методы биндинга / отмены биндинга (в зависимости от типа)|
|`Queue`|Очередь, из которой потребляют сообщения|- `bind(exchange, routing_key)` / `unbind(...)` - `consume(callback, ...)` — начать потребление - `get(...)` — синхронно (в рамках асинхронного кода) получить одно сообщение - У `Queue` может быть итератор: `async with queue.iterator() as it:` и затем `async for message in it:` - `delete()`, `purge()` и др. методы управления очередью|
|`Message` / `IncomingMessage`|Объект сообщения|- `body` — содержимое (байты) - `headers`, `content_type`, `delivery_mode` и др. - У `IncomingMessage` есть методы: `ack()`, `nack()`, `reject()` - Контекстный менеджер `message.process()` — полезно использовать `async with message.process(): ...` чтобы автоматически подтвердить / вернуть и т.д.|
|Другие вспомогательные классы / утилиты|—|Например, `Pool` (для пулов соединений / каналов), паттерны (в модулях `aio_pika.patterns`), и др.|
#### Практические примеры:
В фреймворке навалом всяких сущностей и вообще мне кажется, что интерфейс перегружен. Зато это делает его гибким. Тем не менее для применения приходится строить довольно длинные логические цепочки из объектов и методов. Все это растягивается на несколько файлов `.py` и конечно требует построения инфраструктуры.

Я буду разворачивать **RabbitMQ** в **Docker**. Вот так будет выглядеть `docker-compose.yml`:
```d
service:
	rabbitmq:
	    image: rabbitmq:3-management-alpine
	    container_name: nmnh_rabbitmq
	    environment:
	      - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER}
	      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
	    ports:
	      - "5672:5672"     # AMQP
	      - "15672:15672"   # Web UI
	    healthcheck:
	      test: [ "CMD", "rabbitmq-diagnostics", "ping" ]
	      interval: 10s
	      timeout: 5s
	      retries: 5
	      start_period: 10s
	    restart: unless-stopped
```
 Так же всякие переменные окружения и `url` будут собираться через `PydanticSettings`. И как он работает я тут объяснять не буду. Объект `settings` можно заменить просто на свои данные.

В системах **очередей сообщений (message queues)** обычно используются следующие термины для участников обмена сообщениями:
1. **Producer (или Publisher)** — **производитель сообщений**  
    Это компонент, который **отправляет (публикует)** сообщения в очередь.  
    Иногда в прикладном коде его могут называть **клиентом**, **издателем** или **кастомером**, но правильный термин — **Producer**.
2. **Consumer (или Subscriber)** — **потребитель сообщений**  
    Это компонент, который **читает (подписывается на)** сообщения из очереди.  
    Его также могут называть **воркером (worker)**, если он не просто получает сообщение, а **обрабатывает задачу**, например в фоновой обработке (background job processing).

Всего разберем три случая:
- [[Producer]] - наше приложение отправляет задание и получает ответ.
- [[Consumer]] - наше приложение получает задание, выполняет его и отправляет ответ.
- [[Producer, Consumer]] - наше приложение получает задание, выполняя задание отправляет задание в другое приложение, ждет от него ответ и отправляет ответ. То есть приложение и получает задания от другого приложения и отправляет задания в другое приложение одновременно.