#модуль #datetime 

Модуль используется для работы с датой и временем в формате ISO8601

### Типы объектов

| **Название типа данных**            | Изменяемость | **Характеристика**                                                                                  |
| ----------------------------------- | ------------ | --------------------------------------------------------------------------------------------------- |
| [[date (дата)]]<br>YYYY-MM-DD       | Неизменяемый | представляет собой информацию о дате, исключая данные о времени, на основе Григорианского календаря |
| [[time (время)]]<br>HH:MM:SS.ffffff | Неизменяемый | представляет собой информацию о времени, полностью исключая сведения о дате                         |
| `datetime`                          |              | содержит информацию о времени и дате, основываясь на данных из Григорианского календаря             |
| `timedelta`                         |              | описывает определенный период во времени, который находится между двумя различными моментами        |
| `tzinfo`                            |              | представляет различные сведения о часовом поясе                                                     |
| `timezone`                          |              | описывает время, руководствуясь стандартом UTC                                                      |
Стоит помнить, что компьютеры вообще то хранят данные о текущей дате и времени виде секунд 00.00.00UTC 1970 года
### Операторы сравнения

Объекты типа `date` и `tiem` вооще-то можно сравнивать при помощи стандартных операторов сравнения `==, !=, <, >, <=, >=`
```python
from datetime import date, time

date1 = date(2022, 10, 15)
date2 = date(1999, 12, 26)

time1 = tiem(13, 10, 5)
time2 = time(21,32, 59)

print(dete1 < date2)
print(time1 < time2)
```
```
False
True
```
### sort() sorted() max() min()

К итерируемым объектам, состоящем из объектов `time` и `date` можно применять встроенные методы сортировки или определения максимальных и минимальных значений в итерируемых объектах.
ce()

На основе переменной даты или времени можно получить другую при помощи метода `replace()`
```python
from datetime import date

date1 = date(1992, 10, 6)
date2 = date1.replace(year=1995)
date3 = date2.replace(month=12, day=20)

print(date1)
print(date2)
print(date3)
```
```
1992-10-06
1995-10-06
1995-12-20
```
### Как работает str() и repr() на объектах data и time

`str()` - делает строки, представляя их читабельном для человека виде
`repr()` - делает строки, представляя данные в формальном виде
```python
from datetime import date, time

my_date = date(1995, 12, 20)
my_time = time(11, 20, 54)

print(str(my_date))
print(str(my_time))
```
```
1995-12-20
11:20:54
```
На самом деле, если из этого кода убрать из принта преобразование в строку, вывод не изменится. Потому что `print` уже содержит преобразование в `str`

Зато если перед этим преобразовать перед этим переменные методом `repr()`, мы получим объект типа `str`, содержащий формальное представление объекта
```python
from datetime import date, time

my_date = date(1995, 12, 20)
my_time = time(11, 20, 54)

print(repr(my_date))
print(repr(my_time))
```
```
datetime.date(1995, 12, 20)
datetime.time(11, 20, 54)
```

Но `print` не применит `str()` к объектам внутри списков
```python
from datetime import date 

dates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)] # список дат 

print(dates)
```
```
[datetime.date(2021, 12, 31), datetime.date(2019, 10, 6), datetime.date(2022, 11, 8)]
```
Имеет смысл распаковать список
```python
print(*dates)
```
```
2021-12-31
2019-20-06
2022-11-08
```