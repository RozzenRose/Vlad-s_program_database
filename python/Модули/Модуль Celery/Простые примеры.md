#FastAPI 

#### Выполнение задач в фоне
Представим. что нам нужно сгенерировать тяжелый отчет по запросу и синхронное выполнение здесь не подходит. Поэтому мы отправляем запрос на сервер для его генерации, после чего задача встает в очередь. Когда очередь дойдет до нашей задачи - начнется генерация отчета. Теперь перейдем к реализации.

Создание асинхронной задачи начинается с определения функции, которая будет выполняться асинхронно. Для этого используем декоратор **@task**
```python
import timefrom celery 
import Celery

app = Celery('myapp', broker='pyamqp://guest@localhost//')

@app.taskdef generate_report_task(arg1, arg2):    
	print("Start generating report")    
	time.sleep(10)    
	print("Report generated")
```
Осталось только запустить. Есть три способа это сделать: `apply_async`, `delay` и обычный вызов `call`

`apply_async` - это метод, который предоставляет максимальную гибкость при запуске задачи и принимает большое количество аргументов.
```python
nerate_report_task.apply_async(args=[arg1_value], kwargs={'key': 'value'})
```
`delay` - в отличие от `apply_async` имеет ограниченный список принимаемых аргументов. Такой способ запуска мы рассматриваем, когда нужно просто запустить задачу без необходимости передавать именованные аргументы и другие параметры.
```python
generate_report_task.delay(arg1_value, arg2_value)
```
Этот метод часто используется, когда задача принимает всего несколько аргументов и нам нужно просто ее запустить.

Последний способ - это обычный вызов функции. В таком случае задача будет выполнена сразу же, а не назначена в очередь.
```python
generate_report_task(arg1_value, arg2_value)
```

#### Выполнить задачу через час
Следующая задача - пользователь создал статью и хочет опубликовать ее через один час. Настало время узнать об аргументах, которые принимает `apply_async`

Вариантов здесь - два. Самый просто - аргумент `countdown` - в переводе "обратный отчет". Он позволяет задать время в секундах, через которое задача станет доступна для выполнения.
```python
from datetime import datetime

@app.task
def publish_article(arg1, arg2):    
	print(f"Publish time: {datetime.now()}")
	
publish_article_after = 60 * 60 # 60 минут
result = publish_article.apply_async(args=[article_id], countdown=publish_article_after)
```

#### Выполнить задачу завтра в полдень
Теперь наш пользователь хочет выложить статью завтра в полдень. Эта ситуация очень похожа на предыдущую и мы могли бы использовать `countdown`. Но он лучше подходит для небольших промежутков времени - через минуту или пол часа. А для назначения задачи на конкретное время намного удобнее использовать аргумент `eta`. Он расшифровывается как _Estimated Time of Arrival_, что в переводе "Ожидаемое время прибытия".

**Здесь есть две важных детали:**
- при использовании Redis отложенные с помощью `eta` задачи столкнутся с той же проблемой, что и `countdown` из-за `VISIBILITY_TIMEOUT`.
- `eta` - это не точное время, в которое будет выполнена задача. Указывая время, мы говорим Celery - "задача должна быть выполнена не раньше этого времени". Как только это время наступит - задача будет выполнена в порядке очереди и будет зависеть от количества задач в очереди.
```python
from datetime import datetime

# Получим время для примера. В нормальной ситуации - 
# нам придет аргумент с временем публикации
now = datetime.now()
tomorrow = now + timedelta(days=1)

publish_article_datetime = datetime(tomorrow.year, tomorrow.month, tomorrow.day, 12, 0, 0)

result = publish_article.apply_async(args=["some_value"], eta=publish_article_datetime)
```