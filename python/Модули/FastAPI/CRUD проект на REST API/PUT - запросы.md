#FastAPI #put 

![[aac63888a48fcf1edccd01b2f9090c09.jpg]]
В **REST** архитектуре **PUT** - запросы используются для обновления или замены существующего ресурса. Это один из основных **HTTP**-методов, и его использование в **REST API** следует принципам **RESTful** дизайна.

**Ключевые аспекты PUT-запросов в REST:**
- **Идентификация ресурса:** PUT-запрос всегда обращается к конкретному ресурсу, идентифицируемому его URI (Uniform Resource Identifier). URI указывает на местоположение ресурса на сервере.
- **Полная замена:** В идеале, PUT-запрос должен заменять весь ресурс полностью. Клиент отправляет полное представление ресурса в теле запроса. Сервер затем заменяет существующий ресурс на новый, предоставленный клиентом. Это ключевое отличие от PATCH-запроса, который используется для частичного обновления.
- ем заменяет существующий ресурс на новый, предоставленный клиентом. Это ключевое отличие от PATCH-запроса, который используется для частичного обновления.
- **Идемпотентность:** PUT-запросы идемпотентны. Это означает, что повторное выполнение того же PUT-запроса с теми же данными приведёт к тому же результату. Сервер должен обрабатывать повторные запросы как однократные.
- **Состояние сервера:** PUT-запрос изменяет состояние сервера. После успешного выполнения PUT-запроса состояние ресурса на сервере будет отражать данные, предоставленные клиентом.

В скелете нашего **API** у нас есть функция, которая принимает `PUT` запросы, принимая `message_id` из параметра пути и сам текст записи. Метод мы объявили с помощью декоратора `@app.put`

Давайте создадим метод для обновления существующий записи:
```python
from fastapi import FastAPI, status, Body  
  
app = FastAPI()  
  
messages_db = {0: "First post in FastAPI"}

@app.put("/message/{message_id}")  
async def update_message(message_id: int, message: str = Body()) -> str:  
    messages_db[message_id] = message  
    print(messages_db)  
    return 'Message updated!'
```
Функция `update_message` обернута в декоратор `PUT` запросов, и принимает переменную `message_id` из параметра пути и переменную `message` из самого тела запроса используя класс `Body`. Далее мы в нашей БД(словарь) находим запись с нужным `message_id` и меняем его значение из переменной `message`. Параметр `status_code` мы заполнять не будем, так как при успешном выполнении `PUT` возвращает код ответа `200`.

Запустим приложение через команду `uvicorn crud:app --port 8000` и проверим работу. Зайдем в [документацию](http://127.0.0.1:8000/docs/), и попробуем отправить `PUT` запрос:
![[Pasted image 20250328151844.png]]
Также в терминале:
![[Pasted image 20250328152034.png]]

Если передать в `message_id` `id` которого в словаре нет, он будет создан.
