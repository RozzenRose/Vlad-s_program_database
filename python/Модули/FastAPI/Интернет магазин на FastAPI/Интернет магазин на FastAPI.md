#FastAPI

Попробуем написать небольшой интернет магазин на **FastAPI**, который будет иметь несколько модулей, таких как функции входа в систему, категории товаров, товары и возможность оставление отзыва для товара. Для дальнейшего обслуживания и расширения проекта эти модули мы разместим в разные файлы проекта.

Создадим новый проект и создадим следующую структуру проекта:
```
├── app
│   ├── __init__.py
│   ├── main.py
│   ├── routers
│   │   ├── __init__.py
│   │   ├── category.py
│   │   └── products.py
```
В корне нашего проекта/виртуальной среды мы создали папку `app`, где будет находиться наше приложение.

В этой папке мы создаем файл `main.py`.  Это главный файл **FastAPI** приложения и в него мы будем импортировать все  маршруты нашего приложения.

Также мы создадим папку `routers`, в которую поместили 2 файла: `category.py` и `products.py`. Эти файлы будут отвечать за маршрутизацию категорий товара и продуктов создавая необходимые конечные точки нашего **API**. Также у нас существует несколько файлов `__init__.py`: по одному в каждом каталоге или подкаталоге. Это то, что позволяет импортировать код из одного файла в другой.

Для того чтобы вынести маршруты, из главного файла приложения, нам необходимо воспользоваться экземпляром класса `APIRouter` из `FastAPI`.
### Маршрутизация с помощью класса APIRouter
Класс `APIRouter` принадлежит пакету **FastAPI** и создает операции пути для нескольких маршрутов. Класс **APIRouter** поддерживает модульность и организацию маршрутизации и логики приложений.
#### [[Создание категорий]]
#### [[Создание продуктов]]
#### [[Создание моделей Pydantic]]
#### [[Создание моделей SQLAlchemy]]
#### [[Настройка миграций]]
#### [[Написание запросов к БД]]
#### [[Аутентификация]]
#### [[Конечный код проекта магазина]]
#### [[Логирование приложения]]
### Заключения
Безопасность любых приложений всегда является главным приоритетом при создании качественного проекта. **FastAPI** - это одна из платформ **API**, которая имеет встроенную поддержку многих популярных процессов аутентификации, от базовой до спецификации **OpenID Connect**. Он полностью поддерживает все эффективные схемы аутентификации **OAuth2** и даже доступен для дальнейшей настройки **API** безопасности.

В нашем случае метод `get_current_user()` должен быть внедрен в каждую реализацию сервиса, чтобы ограничить доступ пользователей. Он не только проверит учетные данные, но и выполнит декодирование полезной нагрузки **JWT**.