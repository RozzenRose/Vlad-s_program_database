#FastAPI #Middleware 

Давайте модернизируем наш интернет магазин, добавив в него и логгирование с помощью **MIddleware**. Для этого откроем файл `main.py` и добавим следующий код:
```python
from loguru import logger


logger.add("info.log", format="Log: [{extra[log_id]}:{time} - {level} - {message}]", level="INFO", enqueue = True)
```
объект `logger` имеет метод `add()`, в котором мы можем регистрировать журналы, то есть места, куда мы будем писать лог.

Первый параметр - это обработчик, который решает, отправлять ли журналы в `sys.stdout` или в файл. В нашем приложении мы будем использовать файл `info.log`, содержащий все сообщения журнала.

Второй параметр - это формат логов, в котором мы можем создать собственный макет сообщений журнала, чтобы заменить его формат по умолчанию. Этот формат аналогичен строке `Pyhton` с буквой `f`, которая содержит заполнители.

В файле `info.log` мы хотим, чтобы наши журналы начались с ключевого слова `Log`, за которым сразу следовал специально созданный параметр `log_id`, а затем время регистрации, уровень и сообщение.

Важнейшей частью является тип уровня, который указывает степень детализации сообщений журнала, которые необходимо регистрировать. Если мы установим для параметра уровня значение `INFO`, это сообщит регистратору учитывать только те сообщения, которые имеют уровень `INFO` и выше, то есть: `SUCCESS`, `WARING`, `ERROR` и `CRITICAL`. Регистратор будет обходить сообщения журнала уровня `DEBUG`.

Параметр `enqueue=True` делает логирование асинхронным (через очередь). Полезно, когда пишешь сразу несколько логов.

Возможности и функциональность **Loguru** могут многое. Например, мы можем создать дополнительные обработчики для генерации журналов, где каждый из этих обработчиков имеет разные типы хранения, ротации и представления. Кроме того, **Loguru** может позволить нас добавлять цвета в наших журналы с помощью некоторых цветовых разметок, таких как `<red>`, `<blue>` или `<cyan>`. Он также имеет декоратор `@catch()`, который можно применять для управления исключениями во время выполнения. [документация](https://loguru.readthedocs.io/en/stable/overview.html#features)

Теперь когда мы подключаем логирование, нам необходимо написать промежуточное ПО, для регистрации сообщений. В файле `main.py`, после строчки инициализации `app = FastAPI()` добавим следующий код:
```python
from uuid import uuid4
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse


@app.middleware("http")
async def log_middleware(request: Request, call_next):
    log_id = str(uuid4())
    with logger.contextualize(log_id=log_id):
        try:
            response = await call_next(request)
            if response.status_code in [401, 402, 403, 404]:
                logger.warning(f"Request to {request.url.path} failed")
            else:
                logger.info('Successfully accessed ' + request.url.path)
        except Exception as ex:
            logger.error(f"Request to {request.url.path} failed: {ex}")
            response = JSONResponse(content={"success": False}, status_code=500)
        return response
```
В данном коде мы запускаем выполнение запроса, в случае если код ответа равен `401`, `402`, `403`, `404` мы используем метод `logger.warning()`, этот метод создает в логе сообщение уровня `WARNING`. 

В случае если код ответа другой, то используем метод `logger.info()`, который занесет в лог сообщение уровня `INFO`. В иных случаях мы используем метод `logger.error()` и вызываем `500` ошибку.

Разберемся с `uuid()`, это функция из модуля `uuid4`, генерирующая уникальный идентификатор (`uuid`). Такой `log_id` можно использовать, чтобы связать лог-сообщения с одним конкретным запросом, особенно полезно при асинхронной или многопоточной работе. А нафига нам это нужно? Для того чтобы отличать один запрос от другого. **middleware** будет вызываться при каждом запросе. И каждый запрос будет получать свой `uuid`. Занесем этот `uuid` в лог и тогда в логе мы сможем отличать записи сгенерированные разными запросами.

`with logger.contextualize(log_id=log_id):` через контекстный менеджер мы подгружаем в объект `logger` параметр `log_id=log_id`. Для того, чтобы `uuid` мог использоваться  для формирования сообщений в логе методами `logger.warning()`, `logger.info` или `logger.error()`, в соответствии с форматом `format`, которые мы указывали при создании объекта `logger`.

Запустим сервер, поотправляем запросы какие-нибудь и проверим файлк с логом:
```log
Log: [90412680-7920-4761-955e-d79c944274f3:2025-04-24T12:04:24.430393+0200 - INFO - Successfully accessed /]  
Log: [18dc6eda-44bd-4104-9792-b53fc4b78f59:2025-04-24T12:04:45.788059+0200 - INFO - Successfully accessed /docs]  
Log: [aa00373c-16d5-4a2a-8931-0e567cc13e3a:2025-04-24T12:04:45.870406+0200 - INFO - Successfully accessed /openapi.json]  
Log: [86fb1407-38fc-442b-b13d-22421bfe02e8:2025-04-24T12:04:50.269150+0200 - INFO - Successfully accessed /]
```
Попробуем перейти по несуществующему адресу  [http://127.0.0.1:8000/test](http://127.0.0.1:8000/test):
```txt
Log: [b3b6b616-85f7-4687-bedf-808189e86de7:2025-04-24T12:07:06.510788+0200 - WARNING - Request to /test failed]
```
Получаем запись уровня `WARNING`

