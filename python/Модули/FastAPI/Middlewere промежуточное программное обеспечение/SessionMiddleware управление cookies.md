#FastAPI #SessionMeddleware #cookies

Сессия сайта - это механизм, который позволяет сайту помнить о пользователях и сохранять сделанные ими действия. Сессии используются для разных целей, например:
- для сохранения введённых пользователем данных; 
- для настройки выдачи под интересы пользователя; 
- для показа персональных предложений в зависимости от действий на сайте.

Сессии делятся на два вида:
1. Временные. Существуют до тех пор, пока пользователь не закроет браузер.
2. Постоянные. Хранятся на компьютере в виде файлов cookie и могут быть использованы даже после выключения устройства.

Чтобы управлять данными сеанса, нам нужно создать отдельный сеанс с помощью **SessionMiddleware** от **Starlette**.

Первоначально добавление **SessionMiddleware** создает еще один сеанс на основе файлов **cookie**, который будет образовывать данные в области сеанса. Это единственный способ, поскольку со стороны **FastAPI** нет прямой поддержки механизмов обработки сеансов, где пользовательский сеанс создается не только для безопасности, но и для обработки объектов сеанса.
```python
from fastapi import FastAPI, Request
from starlette.middleware.sessions import SessionMiddleware

app = FastAPI()
app.add_middleware(SessionMiddleware, secret_key="7UzGQS7woBazLUtVQJG39ywOP7J7lkPkB0UmDhMgBR8=")
```
Мы подключаем `SessionMiddleware`, которое поддерживает следующие аргументы:
- `secret_key`- Это случайная строка.
- `session_cookie`- По умолчанию "session".
- `max_age`- Время истечения срока действия сеанса в секундах. По умолчанию 2 недели. Если установлено `None`, то файл cookie будет длиться до тех пор, пока открыт сеанс браузера.
- `same_site`- Флаг SameSite не позволяет браузеру отправлять сеансовые файлы cookie вместе с запросами. По умолчанию `lax`".
- `https_only`- флаг Secure (может использоваться только с HTTPS). По умолчанию - `False`.
- `domain`- Домен файла cookie, используемый для совместного использования файлов cookie между поддоменами или кросс-доменами. Браузер по умолчанию использует домен для того же хоста, который установил файл cookie, за исключением ссылок на поддомены.

`Starlette` использует библиотеку `itsdangerous`, установим ее:
```python
pip install itsdangerous
```
Чтобы добавить данные сеанса в наш код, нам нужно внедрить **Request** в каждую службу конечной точки и использовать ее словарь сеанса для хранения объектов области сеанса.
```python
@app.get("/create_session")
async def session_set(request: Request):
    request.session["my_session"] = "1234"
    return 'ok'
```
С помощью строки `request.session["my_session"]`, мы записываем нашу сессию в **cookies**. Запустим сервер и проверим работу. Теперь если мы отправим **GET** запрос конечной точке **Session Set**, то у нас будет добавлен **cookies**:
![[Pasted image 20250422153412.png]]
Реализуем конечную точку для чтения данных из сессии:
```python
@app.get("/read_session")
async def session_info(request: Request):
    my_var = request.session.get("my_session")
    return my_var
```
С другой стороны, функция `session_info()` получает данные сеанса `my_session` через `request.session[]` и возвращает их в качестве ответа. Кстати, именно благодаря `SessionMiddleware` существует `session[]`. В противном случае использование этого словаря приведет к исключению.
![[Pasted image 20250422153808.png]]
И в конце соберем эндпоинт для удаления данных:
```python
@app.get("/delete_session")
async def session_delete(request: Request):
    my_var = request.session.pop("my_session")
    return my_var
```
Теперь если мы отправим **GET** запрос в данную конечную точку, то данный файл **Cookies** будет удален. Мы его можем использовать когда пользователь выходит из приложения, чтобы удалить все созданные сеанса.
![[Pasted image 20250422161802.png]]
![[Pasted image 20250422161813.png]]
Данную логику мы можем реализовать в виде обычных функций, и через зависимости (`Depends`) подключать их к нужным конечным точкам **API**.