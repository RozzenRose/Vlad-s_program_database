#модуль #python #изменяемый_объект #копирование #итерируемый_объект 


Модуль `copy` позволяет получать копии изменяемых объектов.
Модуль содержит два метода:
- copy() - копирует объект и возвращает его поверхностную копию
- deepcopy() - копирует объект и возвращает его глубокую копию

### Поверхностное копирование
Поверхностное копирование создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти.
```python
import copy

data1 = [1, 2, 3]
data2 = copy.copy(data1)
data1.append(4)

print(id(data1), data1)
print(id(data2), data2)
```
```
2072210867584 [1, 2, 3, 4]
2072250543808 [1, 2, 3]
```
так как переменная `data2` ссылается на новый объект, который представляют копию списка `[1, 2, 3]`. В данном примере элементами списка являются целые числа (неизменяемый тип `int`), поэтому изменение одного списка не отражается на другом. Если бы элементами списка были бы изменяемые типы, то поверхностное копирование скопировало бы лишь ссылки на их адреса памяти. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта. 

То есть если бы внутри списков были бы другие списки, и мы модифицировали внутренние списки в одном списке, внутренние списки во втором списке тоже были бы модифицированы, но количество этих внутренних списков в скопированном объекте не изменится.
```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1.append([7, 8, 9])

print(id(data1), data1)
print(id(data2), data2)
```
```
2320743120512 [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
2320753594368 [[1, 2, 3], [4, 5, 6]]
```

```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
```
```
2088862020160 [[1, 2, 3, 7], [4, 5, 6, 8]]
2088872808384 [[1, 2, 3, 7], [4, 5, 6, 8]]
```

Изменения задели оба списка, потому что оба они содержат ссылки на один и тот же объект. Так работает поверхностное копирование. 


### Глубокое копирование
Глубокое копирование создает новую и отдельную копию всего объекта со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться  в исходной, и наоборот.
```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.deepcopy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
```
```
1097388608 [[1, 2, 3, 7], [4, 5, 6]]
2001108045760 [[1, 2, 3], [4, 5, 6, 8]]
```
При глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.


### Подводные камни
Встроенные функции, используемые при создании коллекций (`list, set, dict, ...`), также могут быть использованы для создания поверхностной копии.
```python
data1 = [1, 2, 3, 4]
data2 = {'a': 1, 'b': 2}
data3 = {1, 2, 3, 4}

new_data1 = list(data1)
new_data2 = dict(data2)
new_data3 = set(data3)

print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)
print(data3 is new_data3, data3 == new_data3)
```
```
False True
False True
False True
```
Так же можно создавать поверхностные копии слайсами
```python
data = [1, 2, 3, 4]

new_data = data[:]

print(data is new_data, data == new_data)
```
```
False True
```