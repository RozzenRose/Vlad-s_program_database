#модуль #python #SQLAlchemy 

Конечно, взаимодействовать с **СУБД** можно исключительно при помощи сырых запросов. Но это делает твой код не структурированным. Разобраться в нем становится сложнее. Для избегания таких проблем принято пользоваться моделями данных. Это не так эффективно с хардверной точки зрения, зато помогает поддерживать порядок в коде.

Как создавать модели данных описано [[Создание моделей данных в декларативном стиле|тут]] , этой моделью и будем пользоваться в примерах. Также мы используем файлы из статьи [[Подключение СУБД]], подробнее про них можно почитать там же

Итак перечислим все файлы, которые нам нужны для примеров:
##### .env
Этот файл содержит данные для подключения, сам смысл их хранения в отдельном файле заключается в том, что так эти данные просто проще защитить. Например мы можем добавить эти данные в `git ingnor`, если хотим зашейрить наш проект на `git` и они не будут зашейрены
```
DB_HOST=192.168.50.195  
DB_PORT=5555  
DB_USER=postgres  
DB_PASS=2580  
DB_NAME=postgres
```
##### DB_congig.py
Этот файл используется для создания объекта `settings`, методом этого объекта будет сформирован `url`, который будет использован для создания движка, через который будет осуществляться управление **СУБД**
```python
from pydantic_settings import BaseSettings, SettingsConfigDict  
  
class Settings(BaseSettings):  
    DB_HOST: str  
    DB_PORT: int  
    DB_USER: str  
    DB_PASS: str  
    DB_NAME: str  
  
    @property  
    def DATABASE_URL_asyncpg(self):  
        #DSN  
        #postgresql_asyncpg://postgres:postgres@localhost:5555/sa        
    return f'postgresql+asyncpg://{self.DB_USER}:{self.DB_PASS}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}'  
  
    model_config = SettingsConfigDict(env_file='.env')  
  
settings = Settings()
```
#### Синхронная работа
##### engine.py
В этом файле будут создаваться различные техничиские объекты для дальнейшей работы **ORM**
```python 
from sqlalchemy import create_engine  
from sqlalchemy.orm import Session, sessionmaker, DeclarativeBase  
from DB_config import settings  
import asyncio  
  
sync_engine = create_engine(  
    url=settings.DATABASE_URL_psycopg,  
    echo=True  
)

session_factory = sessionmaker(sync_engine)  

class Base(DeclarativeBase):  
    pass
```
В этом файле, мы как обычно создаем движек `sync_engine`.
Так же создаем создатель сессий `session_factory` через метод `sessionmaker()`, которому в качестве аргумента передается синхронный движек, так же мы создаем промежуточного наследника `Base` от класса `DeclarativeBase` для создания моделей данных.
##### models.py
В этом файле будут создаваться сами модели данных
```python
from engine import Base  
from sqlalchemy.orm import Mapped, mapped_column  
  
class WorkersOrm(Base):  
    __tablename__ = 'workers'  
    id: Mapped[int] = mapped_column(primary_key=True)  
    username: Mapped[str]
```
В этом файле мы импортируем класс `Base`, а также объект `Mapped` и метод `mapped_column`.
И собираем их них класс `WorkersOrm`, который и будет являться нашей моделью данных
##### core.py
Этот файл представляет из себя что-то типо хранилища функций, которые потом будут использованы в коде
```python
from engine import sync_engine, session_factory, Base   
from models import WorkersOrm  
  
def create_tables():  
    Base.metadata.create_all(sync_engine)  
  
def insert_data():  
    with session_factory() as session:  
        worker_1 = WorkersOrm(username="WladBelsky")  
        worker_2 = WorkersOrm(username='RozzenRose')  
        session.add_all([worker_bobr, worker_volk])  
        session.commit()  
```
Функция `create_tables()` создает все таблицы, для которых есть модели, созданные через наследников класса `DeclarativeBase()`, то есть модель, созданная классом `WorkersOrm` в том числе. 

Методу `create_all()` нужно в качестве аргумента передать синхронный движек.

Функция `insert_data()` заполняет таблице данными. Внутри функции создается контекстный менеджер, в котором вызывается фабрика сессий `session_factory()`. Затем мы создаем объекты для добавления в таблицу `worker_1` и `worker_2`. При создании таких объектов мы вызываем класс модели данных для таблицы, с которой работаем и передаем ему в качестве именного аргумента значение. именным аргументом является название столбца, а значение этого аргумента является значение, которое мы хотим в этот столбец записать. Мы не будем пытаться записать что-либо в столбец `id`, потому что он объявлен, как первичный ключ, а значит будет заполняться цифрами сами

И так, когда все объекты для добавления созданы, можно записать их в таблицу. Мы вызываем метод `add_all()` объекта `session`, в качестве аргумента этому методу мы передаем список объектов  для добавления. Если бы объект был один, мы могли бы использовать метод `add()`, которому можно передать всего один объект для добавления в качестве аргумента.
##### mine.py
Файл для вызова функций из `core.py`
```python
from core import create_tables, insert_data

create_tables()  
insert_data()
```
Проверяем изменения в базе данных:
![[Pasted image 20250131180113.png]]

#### Асинхронная работа
##### engine.py
В этом файле будут создаваться различные техничиские объекты для дальнейшей работы **ORM**
```python
from sqlalchemy.ext.asyncio import create_async_engine, async_session, async_sessionmaker  
from sqlalchemy.orm import DeclarativeBase  
from DB_config import settings  
import asyncio  
  
engine = create_async_engine(  
    url=settings.DATABASE_URL_asyncpg,  
    echo=False  
)  

async_session_factory = async_sessionmaker(engine)  
  
class Base(DeclarativeBase):  
    pass
```
Как обычно создаем асинхронный движек `engine`.
Так же создаем асинхронную фабрику сессий `async_session_factory` через метод `async_sessionmaker()`, которому в качестве аргумента передаем движек `engine`. Так же создадим промежуточного наследника `Base` от класса `DeclarativeBase` для создания моделей данных.
##### models.py
В этом файле будут создаваться сами модели данных
```python
from sqlalchemy import Table, Column, Integer, String, MetaData  
from engine import Base  
from sqlalchemy.orm import Mapped, mapped_column  
  
class WorkersOrm(Base):  
    __tablename__ = 'workers'  
    id: Mapped[int] = mapped_column(primary_key=True)  
    username: Mapped[str]
```
В этом файле мы импортируем класс `Base`, а также объект `Mapped` и метод `mapped_column`.
И собираем их них класс `WorkersOrm`, который и будет являться нашей моделью данных
##### core.py
Этот файл представляет из себя что-то типо хранилища функций, которые потом будут использованы в коде
```python
from engine import engine, async_session_factory, Base  
import asyncio  
from models import WorkersOrm

async def create_tables():  
    async with engine.begin() as conn:  
        await conn.run_sync(Base.metadata.create_all)  
  
async def insert_data():  
    async with async_session_factory() as session:  
        worker_1 = WorkersOrm(username="WladBelsky")  
        worker_2 = WorkersOrm(username='RozzenRose')  
        session.add_all([worker_1, worker_2])  
        await session.commit()
```
Сперва мы импортируем в этот файл все необходимое: движек `engine`, фабрику сессий `async_session_factory`, промежуточного наследника `Base` и конечно модель данных `WorkersOrm`.

Далее создаем асинхронную функцию `create_tables()`, внутри этой функции создается асинхронный контекстный менеджер, в котором вызывается метод `engine.begin()`, на основе этого метода создается объект `conn`, который что-то типо сессии сам по себе, я точно не знаю. После чего мы вызываем метод `conn.run_sync()`, вообще это специальный метод, который позволяет вызывать синхронные функции внутри асинхронных. Он нужен нам, потому что мы находимся внутри асинхронной функции, а метод создающий таблицы `Base.metadata.create_all` синхронный. Поэтому мы можем вызвать `Base.metadata.create_all` только внутри специальной функции `conn.run_sync()`

Метод `inser_data()` нужен для заполнения таблицы данными. Внутри него вызывается асинхронные контекстный менеджер, который при помощи фабрики сессий `async_session_factory()` тут же создает объект сессии `session`. Затем мы создаем объекты для добавления в таблицу `worker_1` и `worker_2`. При создании таких объектов мы вызываем класс модели данных для таблицы, с которой работаем и передаем ему в качестве именного аргумента значение. именным аргументом является название столбца, а значение этого аргумента является значение, которое мы хотим в этот столбец записать. Мы не будем пытаться записать что-либо в столбец `id`, потому что он объявлен, как первичный ключ, а значит будет заполняться цифрами сами

И так, когда все объекты для добавления созданы, можно записать их в таблицу. Мы вызываем метод `add_all()` объекта `session`, в качестве аргумента этому методу мы передаем список объектов  для добавления. Если бы объект был один, мы могли бы использовать метод `add()`, которому можно передать всего один объект для добавления в качестве аргумента.

Коммит естественно через `await`, метод `session.commit()` содержит `I/O` операцию
##### main.py
Файл для вызова функций из `core.py`
```python
from core import create_tables, insert_data
import asyncio  
  
async def main():  
    await create_tables()  
    await insert_data()  
  
asyncio.run(main())
```
![[Pasted image 20250131180113.png]]