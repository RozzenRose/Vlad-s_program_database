#модуль #python #SQLAlchemy 

![[Pasted image 20250325221154.png]]
Сырые запросы через алхимию, это когда ты буквально отправляешь `SQL` код в базу данных.

Сам по себе этот способ не очень быстрый и легкий с точки зрения написания кода. Так же постороннему человеку в такой код будет вникать тяжелее. Зато это быстро и эффективно с точки зрения процессорного времени и объема занимаемой **ОЗУ**, если ты хорошо владеешь **SQL** , конечно. Сырые запросы требуют гораздо меньше ресурсов и времени, нежели запросы, построенные билдерами с использованием моделей данных
### Асинхронный
Для начала нам понадобятся движки и конфиги, построенные [[Подключение СУБД|тут]].
После этого попробуем написать запрос вот к такой **СУБД**. Этот запрос должен будет достать `truck_guide` из таблицы `Info` по указанию машины и трассы. Сам трекгайд - это просто ссылка на видео YT
![[Pasted image 20250131164320.png]]
```python
import engine from dealer
from sqlalchemy import text  

async def get_from_db():  
    async with engine.connect() as conn:  
        res = await conn.execute(text('select track_guide from "Info" '  
                                      'where car_id = (select id from "Cars" '                                                "                where car_name =                                                                        'Porsche_922_GT3R') and"                                               '      track_id = (select id from "Tracks"'                                             "                 where track_name =                                                                      'Spa_Francorchamps')"))  
        print(f'{res.first()[0]}')  
  
asyncio.run(get_from_db())
```
```
https://www.youtube.com/watch?v=Ve7Qhx0lFzg&t=79s
```
Для этого мы используем контекстный менеджер. Поскольку он сам откроет соединение, перед тем, как сделать запрос и закроет его, когда запрос будет успешно выполнен. Асинхронный контекстный менеджер не может существовать сам по себе и обязательно должен быть обернут в асинхронную функцию. Для этого мы помещаем его в `get_from_db()`

Метод `connect()` объекта `engine` вернет что-то типо клиента **СУБД**, через который потом можно самой **СУБД** командовать

Для инъекции `SQL` кода в **СУБД** используется метод `execute()`, но что бы передать в него строку с `SQL` кодом, ее по какой-то причине сперва нужно обернуть в функцию `text()`. Почему так, без понятия

### Синхронный
Для начала нам понадобятся движки и конфиги, построенные [[Подключение СУБД|тут]].
После этого попробуем написать запрос вот к такой **СУБД**. Этот запрос должен будет достать `truck_guide` из таблицы `Info` по указанию машины и трассы. Сам трейгайд - это просто ссылка на видео YT
![[Pasted image 20250131164320.png]]
```python
import sync_engine from dealer
from sqlalchemy import text  

with engine.connect() as conn:  
	res = conn.execute(text('select track_guide from "Info" '  
							'where car_id = (select id from "Cars" '                                                "                where car_name =                                                                        'Porsche_922_GT3R') and"                                               '      track_id = (select id from "Tracks"'                                             "                 where track_name =                                                                      'Spa_Francorchamps')"))  
	print(f'{res.first()[0]}')  
```
```
https://www.youtube.com/watch?v=Ve7Qhx0lFzg&t=79s
```
Для этого мы используем контекстный менеджер. Поскольку он сам откроет соединение, перед тем, как сделать запрос и закроет его, когда запрос будет успешно выполнен.

Метод `connect()` объекта `engine` вернет что-то типо клиента **СУБД**, через который потом можно самой **СУБД** командовать

Для инъекции `SQL` кода в **СУБД** используется метод `execute()`, но что бы передать в него строку с `SQL` кодом, ее по какой-то причине сперва нужно обернуть в функцию `text()`. Почему так, без понятия

### Объект ответа
Метод `execute()` возвращает ответ от **СУБД**  в довольно странном виде, который придется еще распаковать. Чаще всего это делается методом `res.all()`. В этом случае все данные будут помещены в `list` объект. Допустим у нас есть табличка с тремя машинками, попробуем запросить все записи этой таблички по всем столбцам, после чего применим метод `all()` к ответу и прогоним через итерацию с выводом:
```python
async def get_from_db():  
    async with engine.connect() as conn:  
        res = await conn.execute(text('select * from "Cars"'))  
        for i in res.all():  
            print(i)
```
```
(1, 'Porsche_922_GT3R')
(2, 'Ferrari_296_GT3')
(3, 'Lamborghini_Huracan_GT3_EVO_2')
```
Так же у нас есть возможность вызвать первую запись из объекта ответа при помощи метода `first()`:
```python
async def get_from_db():  
    async with engine.connect() as conn:  
        res = await conn.execute(text('select * from "Cars"'))          
	    print(res.first())
```
```
(1, 'Porsche_922_GT3R')
```
Сколько там еще таких методов смешных разбирайся сам