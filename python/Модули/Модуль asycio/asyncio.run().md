#модуль #python #asyncio #асинхронное_программирование #event_loop #run

Функция `asyncio.run()`- это высокоуровневая обертка для запуска основного цикла событий и выполнения асинхронных задач. Она автоматически создает новый цикл событий, запускает указанную сопрограмму, ждет ее завершения и корректно закрывает цикл.
#### Почему лучше использовать `ascyncio.run()`?
- **Простота**: Функция `asyncio.run()` упрощает выполнение асинхронного кода, устраняя необходимость в ручном управлении циклом событий.
- **Безопасность**: `asyncio.run()` обеспечивает корректное завершение и очистку ресурсов, что помогает избежать утечек ресурсов и других проблем.
- **Чистота кода**: Использование `asyncio.run()` делает код более читаемым и поддерживаемым.
#### Пример использования `asyncio.run()`
Давайте  рассмотрим пример, где мы используем `ascyncio.run()` для выполнения асинхронной задачи:
```python
import

async def greet():
	print('Приветствие!')
	await asyncio.sleep(1)
	print('Добро пожаловать!')

# Запуск основного цикла событий
asyncio.run(green())
```
Пошаговое объяснение:
1. **Создание асинхронной функции `greet()`**: Функция выводит "Приветствие!", ждет 1 секунду и выводит "Добро пожаловать!"
2. **Запуск цикла событий с помощью `asyncio.run()`**: Функция `asyncio.run(greet())` создает новый цикл событий, выполняет задачу `greet` и автоматически закрывает цикл после завершения
#### Особенности и ограничения `asyncio.run()`
1. **Создание нового цикла событий**: `asyncio.run()` всегда создает новый цикл событий, что делает его удобным для простых скриптов и приложений
2. **Запуск только одной сопрограммы**: `asyncio.run()` принимает только одну сопрограмму в качестве аргумента. Если вам нужно запустить несколько задач параллельно, используйте `asyncio.gather()` внутри основной сопрограммы
3. **Запуск из главного потока**: `asyncio.run()` должен быть вызван из главного потока, иначе возникнет ошибка
### Пример с несколькими задачами
Давайте рассмотрим пример, где мы используем `asyncio.run()` для запуска нескольких задач конкурентно с помощью `asyncio.gather()`:
```python
import asyncio

async def task1():
    await asyncio.sleep(1)
    return "Задача 1 выполнена"

async def task2():
    await asyncio.sleep(1)
    return "Задача 2 выполнена"

async def main():
    results = await asyncio.gather(task1(), task2())
    for result in results:
        print(result)

# Запуск основного цикла событий
asyncio.run(main())
```
Пошаговое объяснение
1. **Создание нескольких асинхронных функций**: `task1` и `task2` выполняют задачи и возвращают результаты.
2. **Создание основной функции** `main`: Функция `main` использует `asyncio.gather()` для выполнения задач конкурентно и ожидания их завершения.
3. **Запуск основного цикла событий**: `asyncio.run(main())` создает новый цикл событий и выполняет функцию `main`.