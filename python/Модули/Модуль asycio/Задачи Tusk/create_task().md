#модуль #python #asyncio #асинхронное_программирование #Tusk 

Функция `asyncio.create_task` используется для создания и запуска задач в асинхронном программировании. Она принимает сопрограмму в качестве аргумента и возвращает объект задачи, который можно использовать для управления выполнением этой задачи.
### Почему `asyncio.create_task`?
Создание задач с помощью `asyncio.create_task` позволяет управлять выполнением асинхронных операций, обеспечивая их конкурентное выполнение. Это позволяет вашей программе продолжать выполнение других операций, пока задачи находятся в ожидании завершения асинхронных операций.
### Пример использования `asyncio.create_task`
Рассмотрим пример, как создать и запустить задачу с использованием `asyncio.create_task`:
```python
import asyncio

async def my_coroutine():
    print("Начало выполнения задачи")
    await asyncio.sleep(1)
    print("Задача выполнена")

async def main():
    # Создание задачи
    task = asyncio.create_task(my_coroutine())
    
    # Начало выполнения и ожидание завершения задачи
    await task

# Запуск главной программы
asyncio.run(main())
```
В этом примере:
1. **Создание сопрограммы**: Мы определяем сопрограмму `my_coroutine`, которая приостанавливает выполнение на 1 секунду с помощью `await asyncio.sleep(1)`.
2. **Создание задачи**: Внутри `main` мы создаем задачу с помощью `asyncio.create_task(my_coroutine())`.
3. **Ожидание завершения задачи**: Мы ожидаем завершения задачи с помощью `await task`.
4. **Запуск главной программы**: Мы используем `asyncio.run(main())` для запуска главной программы, которая в свою очередь запускает созданную задачу.
### Важный момент: Запуск задачи
Выполнение задачи начинается при первом же выражении `await` в сопрограмме. Это означает, что задача не будет активна до тех пор, пока не встретится первое `await`. После этого события задачи выполняются и переключаются между собой в рамках цикла событий.
### Управление несколькими задачами
Использование `asyncio.create_task` позволяет запускать и управлять несколькими задачами одновременно. Рассмотрим пример, где мы запускаем несколько задач конкурентно:  
```python

import asyncio

async def task1():
    await asyncio.sleep(1)
    print("Задача 1 завершена")

async def task2():
    await asyncio.sleep(2)
    print("Задача 2 завершена")

async def main():
    # Создание нескольких задач
    task1_obj = asyncio.create_task(task1())
    task2_obj = asyncio.create_task(task2())
    
    # Начало выполнения всех задач и ожидание завершения 1ой задачи
    await task1_obj
    # Ожидание завершения 2ой задачи
    await task2_obj

asyncio.run(main())
```
В этом примере:
1. **Создание задач**: Мы создаем две задачи с использованием `asyncio.create_task`.
2. **Запуск задач**: Обе задачи запускаются одновременно и выполняются конкурентно.
3. **Ожидание завершения задач**: Мы ждем завершения каждой задачи с помощью `await task1_obj` и `await task2_obj`.

У объекта задачи есть три состояния:
- **`done`**: Задача завершилась успешно.
- **`cancelled`**: Задача была отменена.
- **`exception`**: Задача завершилась с исключением.
Задачи, которые уже были выполнены на начнут выполняться позже
