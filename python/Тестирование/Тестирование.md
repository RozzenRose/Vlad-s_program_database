#тестирование 

Тестирование нужно для поиска ошибок в твоем коде, очевидно. Попробуем разобраться на примере.

Например, вам нужно ввести три числа (`a`, `b`, `c`) и найти корни квадратного уравнения. Для решения пишем код:
```python
from math import sqrt

def square_eq_solver(a, b, c):
   result = []
   discriminant = b * b - 4 * a * c

   if discriminant == 0:
       result.append(-b / (2 * a))
   else:
       result.append((-b + sqrt(discriminant)) / (2 * a))
       result.append((-b - sqrt(discriminant)) / (2 * a))

   return result

def show_result(data):
   if len(data) > 0:
       for index, value in enumerate(data):
           print(f'Корень номер {index+1} равен {value:.02f}')
   else:
       print('Уравнение с заданными параметрами не имеет корней')

def main():
   a, b, c = map(int, input('Пожалуйста, введите три числа через пробел: ').split())
   result = square_eq_solver(a, b, c)
   show_result(result)

if __name__ == '__main__':
   main()
```
Да, это простенький код для нахождения корней квадратного уравнения.

Зная алгоритм нахождения корней уравнения, определяем наборы входных данных, которые будут переданы на вход программе.

Зная входные данные, можно вручную посчитать, какой ответ должна дать программа.

Получаем от нее ответ и сравниваем с тем, который должен быть получен. Если они совпадают - хорошо, идем дальше, если нет, сообщаем об ошибке.

Например, для данной задачи можно подобрать следующие тесты:
- `10x**2 = 0` — единственный корень x=0
- `2x**2 + 5x — 3 = 0` — у такого уравнения два корня (x1 = 0.5, x2=-3)
- `10x**2+2 = 0` — у этого уравнения корней нет

Тесты подобрали, что дальше? Запускаем:
```cmd
Тест номер 1
> python.exe example.py
Пожалуйста, введите три числа через пробел: 10 0 0
Корень номер 0 равен 0.00

Тест номер 2:
> python.exe example.py
Пожалуйста, введите три числа через пробел:  2 5 -3
Корень номер 1 равен 0.50
Корень номер 2 равен -3.00

Тест номер 3:
> python.exe example.py
Пожалуйста, введите три числа через пробел: 10 0 2
Traceback (most recent call last):
  File "C:PyProjectstprogerexample.py", line 32, in <module>
    main()
  File "C:PyProjectstprogerexample.py", line 27, in main
    result = square_eq_solver(a, b, c)
  File "C:PyProjectstprogerexample.py", line 11, in square_eq_solver
    result.append((-b + sqrt(discriminant)) / (2 * a))
ValueError: math domain error
```
В третьем тесте произошла ошибка. Не обрабатывался случай с нулевым дискриминантом. В итоге, можно подкорректировать код функции так, чтобы этот вариант обрабатывался правильно:
```python
def square_eq_solver(a, b, c):
   result = []
   discriminant = b * b - 4 * a * c

   if discriminant == 0:
       result.append(-b / (2 * a))
   elif discriminant > 0:  # <--- изменили условие, теперь
                           # при нулевом дискриминанте
                           # не будут вычисляться корни
       result.append((-b + sqrt(discriminant)) / (2 * a))
       result.append((-b - sqrt(discriminant)) / (2 * a))

   return result
```
Запускаем все тесты повторно и они срабатывают нормально.

Но учтите, чтобы повторно проверить программу, потребуется потратить несколько минут и снова проверить все три варианта входных значений. Если таких вариантов будет много, вызывать их вручную будет очень накладно. И здесь на сцену выходит автоматизированное тестирование.

Программа автоматического тестирования запускается на основе заранее заготовленных входных/выходных данных программы, которая будет их вызывать. По сути, это программа, тестирующая другие программы. И в рамках экосистемы языка **Python** есть несколько пакетов, позволяющих автоматизировать процесс тестирования.

Две самые популярные библиотеки - [[Unittest]] и **pytest**.