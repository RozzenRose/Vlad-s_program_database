#встроенная_функция #python #super #метод

Расширение методов в том виде, в котором было показано ранее, хоть и рабочее, однако имеет небольшой недостаток, который заключается в том, что мы напрямую обращаемся к родительскому классу и конкретному классу и конкретному методу:
```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed):
        Animal.__init__(self, name, age)               # явно обращаемся к методу __init__() класса Animal
        self.breed = breed
```
Такой подход может привести к ошибкам, например, если родительский класс изменить свое имя или если у дочернего класса родительским станет другой класс. Во избежание подобных проблем в `Python` используется встроенная функция `super()`, которая позволяет нам неявно обращаться к родительскому классу. Наиболее распространенным вариантом ее применения является именно вызов метода родительского класса из метода дочернего класса
```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed): 
        super().__init__(name, age)                    # неявно обращаемся к методу __init__() родительского класса
        self.breed = breed

cat = Cat('Кемаль', 1, 'манчкин')

print(cat.name, cat.age, cat.breed)
```
демонстрирует использование функции `super()` и выводит:
```
Кемаль 1 манчкин
```
В данном случае выражение `super().__init__(name, age)` равнозначно `Animal.__init__(self, name, age)` и звучит так: вызови метод `__init__()` у моего родительского класса и передай ему в качестве аргументов текущий экземпляр `self`, а также значения `name` и `age`. То есть объект, возвращаемый функцией `super()`, связывает текущий класс `Cat`, экземпляр класса `Cat`, доступный по имени `self`, и родительский класс `Animal`. Также следует обратить внимание, что при вызове родительского метода с помощью функции `super()`, экземпляр класса в качестве первого аргумента передавать не нужно

Объект, возвращаемый функцией `super()` сама определяет текущий класс. его родительский класс и текущий экземпляр текущего класса, и в примере выше мы наблюдали данное поведение. Однако текущий класс и текущий экземпляр этого класса мы можем указывать явно
```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Cat(Animal):
    def __init__(self, name, age, breed): 
        super(Cat, self).__init__(name, age)
        self.breed = breed


cat = Cat('Кемаль', 1, 'манчкин')

print(cat.name, cat.age, cat.breed)
```
```
Кемаль 1 манчкин
```
В примере выше в качестве первого аргумента мы передаем класс `Cat`, тем самым указывая, что к методу `__init__()` нужно обратиться именно у родительского класса `Cat`. В качестве второго аргумента мы передаем текущий экземпляр класса `Cat`-`self`, тем самым указывая, какой именно объект нужно передать в функцию `__init__()` в качестве первого аргумента

Функция `super()` так названа в честь названия родительского класса `superclass`

Отличительной особенностью функции `super()` является то, что она предоставляет доступ, скорее, не к конкретному классу, а ко всей иерархии классов. И если в нашем наследовании участвует три или более классов, то функция `super()` выполняет поиск необходимого метода в каждом их этих классов
```python
class Animal:
    def __init__(self, name):
        print('Вызов метода __init__() класса Animal')
        self.name = name

class Cat(Animal):
    pass

class Kitten(Cat):
    def __init__(self, name, breed):
        print('Вызов метода __init__() класса Kitten')
        super().__init__(name)
        self.breed = breed


cat = Kitten('Кемаль', 'манчкин')

print(cat.name, cat.breed)
```
```
Вызов метода __init__() класса Kitten
Вызов метода __init__() класса Animal
Кемаль манчкин
```
В примере выше функция `super()` сперва проверяет наличие метода `__init__()` в классе `Cat`, а затем в классе `Animal`.

Объект, возвращаемый функцией `super()`, предоставляет доступ к классу-родителю, тем самым мы можем обращаться не только к методам этого класса, но и атрибутам.
```python
class ParentClass:
    attr = 1

class ChildClass(ParentClass):
    attr = 2
    
    def super_attr(self):
        return super().attr


obj = ChildClass()

print(obj.attr)
print(obj.super_attr())
```
```
2
1
```