#OOP #ООП #Python #наследование #множественное_наследование #Method_Resolution_Order #MRO

![[CatDog.png]]
Синтаксис множественного наследования практически ничем не отличается от одиночного. Единственная разница в том, что при определении дочернего класса в скобках мы указываем не один родительский класс, а несколько через запятую
```python
class Parent1:                                       # первый родительский класс
    pass

class Parent2:                                       # второй родительский класс
    pass

class Child(Parent1, Parent2):                       # дочерний класс
    pass
```
Важно не путать множественное наследование с многоуровневым наследованием. При множественном наследовании класс определяется как наследник двух или более классов одновременно, при многоуровневом наследовании каждый класс цепочки определяется как наследник лишь одного класса:
![[Pasted image 20241014132958.png]]
Рассмотрим иерархию из уже знакомых нам классов `Cat` и `Dog`, к которой добавим их наследника в лице класса `CatDog`, описывающего мультипликационного персонажа - котопса:
```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass
```

В классе `Cat` определен метод `meow()`, в классе `Dog` определен метод `break()`, и класс `CatDog`, являясь их наследником, может пользоваться обоими этими методами.
```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass


catdog = CatDog()

print(catdog.meow())
print(catdog.bark())
```
```
мяу
гав
```
Функционально множественное наследование повторяет одиночное наследование. Мы поучаем возможность в дочернем классе пользоваться атрибутами и методами всех указанных родительских классов с последующим их переопределением или расширением. Однако множественно наследование, в отличие от одиночного, является потенциальным источником ошибок, которые могут возникнуть из-за наличия одинаковых имен атрибутов и методов в родительских классах

При множественном наследовании класс может иметь неограниченное количество родительских классов

### Проблема ромбовидного наследования
Проблема ромбовидного наследования - это типичная проблема при множественном наследовании. Она заключается в двусмысленности, возникающей, когда два класса `B` и `C` наследуются от класса `A`, а другой класс `D` наследуется от классов `B` и `C`
![[Pasted image 20241014135600.png]]
```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```
Указанная выше диаграмма иерархии классов `A`, `B`, `C` и `D` представляет собой ромб, именно поэтому неоднозначность, возникающую при подобном наследовании, называют проблемой ромбовидного наследования. Проблемой, потому что, например, если в классе `A` есть метод `method()`, который класс `B` или `C` переопределил (или они оба переопределили), то возникает вопрос, какую версию этого метода должен унаследовать класс `D`?

Рассмотрим одну из упомянутых ситуаций. Определим метод в классах `A`, `B` и `C` и проверим, какой из них будет унаследован классом `D`.
```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


d = D()

d.method()
```
```
Метод класса B
```
В данной ситуации класс `D` унаследован метод класса `B`, и этот выбор не является случайным. В `Python` проблема ромбовидного наследование решается с помощью `MRO`

### Method Resolution Order (MRO)
В `Python` существует строгий порядок, в котором просматриваются классы во время поиска конкретного метода в иерархии классов при наследовании. Этот порядок определяется для каждого класса индивидуально в зависимости от его иерархии и называется `Method Resolution Order`

Для получения `MRO` класса достаточно воспользоваться методом `mro()`. Его результатом является список родителей класса, включая сам класс, расположенный ровно в том порядке, в котором `python` будет производить поиск методов
```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


print(D.mro())
```
```no-highlight
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```
`MRO` класса также можно получить при помощи атрибута класса `__mro__`

Определив `MRO` класса, мы всегда можем точно сказать, какой из методов будет унаследован этим классом в том или ином случае, так как знаем, в каком порядке будут проверяться его родительский классы при поиске метода. Так, в нашей ромбовидной иерархии классов `A`, `B`, `C` и `D` мы видим, что `MRO` класса `D` класс `B` находится перед классами `A`и `C`, следовательно, определенный во всех трех родительских классах метод `method()` будет унаследован именно из класса `B`

Например, если метод `method()` будет определен только в классах `A` и `C`, то унаследованный метод будет принадлежать классу `C`, потому что в `MRO` класса `D` класс `C` находится перед классом `A`
```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    pass
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


d = D()

d.method()
```
```
Метод класса C
```

Аналогично, если метод `method()` будет определен только в классе `A`, то унаследованный метод будет принадлежать именно этому классу 
```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    pass
        
class C(A):
    pass

class D(B, C):
    pass


d = D()

d.method()
```
```
Метод класса A
```

Наконец, если метод `method()` будет определен во всех родительских классах, включая сам класс `D`, то использоваться будет метод, реализованный именно в классе `D`.
```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    def method(self):
        print('Метод класса D')


d = D()

d.method()
```
```
Метод класса D
```

`MRO` решает основную проблему множественного наследования - неоднозначность, возникающую при ромбовидном наследовании. Зная `MRO` класса, мы всегда можем определить, какой метод будет унаследован этим классом, независимо от сложности его иерархии

В MRO любого класса на первом месте всегда указывается исходный класс, а на последнем — класс `object`.

### Простейшее построение `MRO`
В случае простейшего множественного наследования алгоритм построения `MRO` не вызывает трудностей, так как представляет сбой поиск в глубину, слева направо, то есть сперва проверяется иерархия первого родительского класса, затем затем иерархия второго родительского класса, и так далее, с последующим исключением из полученной последовательности повторяющихся классов, кроме их последних включений

Если мы попытаемся самостоятельно определить `MRO` класса `D` из нашей ромбовидной иерархии
```python
class A:
    pass
        
class B(A):
    pass
        
class C(A):
    pass

class D(B, C):
    pass
```
то сперва укажем класс `D`, затем иерархию первого родительского класса `B`, а после иерархию второго родительского класса `C`:
```
D, B, A, object, C, A, object
```
Затем исключим из полученной последовательности повторяющиеся классы, кроме их последних включений, и получим MRO класса `D`:
```
D, B, C, A, object
```

Данный способ не является решением в общем виде, он может служить лишь подсказкой при простейшем множественном наследовании, когда иерархии родительских классов представлены в виде линейных структур. В общем же случае алгоритм построения `MRO` имеет более сложный вид

Алгоритм построения MRO называется C3-линеаризация. Ознакомиться с принципом его работы можно в официальной документации по [ссылке](https://www.python.org/download/releases/2.3/mro/).

### Невозможность построения `MRO`
Алгоритм, с помощью которого `Python` строит `MRO` класса, имеет ряд правил, в число которых входят следующие:
- Правило наследования. Если некоторый класс `D` является наследником классов `A, B, C`, то при построении MRO эти классы должны располагаться в том порядке, в котором они были указаны в определении класса `D`, причем между ними могут располагаться другие классы, однако их исходный порядок должен остаться неизменным
- **Правило старшинства.** При построении MRO все классы иерархии должны располагаться в порядке старшинства, то есть ни один родительский класс не должен следовать перед своим дочерним классом.

Возможны ситуации, когда иерархия классов при множественном наследовании таков, что алгоритм при построении `MRO` не может соблюсти эти правила, в таких случаях построение `MRO` считается невозможным. Рассмотрим две ситуации множественного наследования, в которых не соблюдается хотя бы одно из приведенных выше правил и `MRO` построить нельзя

**Ситуация 1.** Построение MRO класса `C` при следующей иерархии классов:
```python
class A:
    pass

class B(A):
    pass

class C(A, B):
    pass
```
является невозможным по той причине, что каково бы ни было MRO, не соблюдается либо правило наследования, либо правило старшинства:
- Правило наследования нарушается при следующем построении `MRO`:
	`C, B, A, object`
	Так как классы `A` и `B` должны располагаться в том порядке, в котором были указаны в определении класса `C`
- Правило старшинства нарушается при следующем построении `MRO`:
	`C, A, B, object`
	Так как ни один родительский класс не должен следовать перед своим дочерним классов, в данном случае родительским классом является класс `A`, дочерним - класс `B`

**Ситуация 2.** Построение `MRO` класса `E`  при следующей иерархии классов:
```python
class A:
    pass

class B:
    pass

class C(A, B):
    pass

class D(B, A):
    pass

class E(C, D):
    pass
```
является невозможным по той причине, что по правилу наследования родители класса `C` должны быть расположены в порядке `A, B`, в то время как по тому же правилу родители класса `D` должны быть расположены в порядке `B, A`. В MRO класса `E` должны быть соблюдены оба порядка, но этого сделать нельзя, так как они противоречат друг другу.

### Примечание:
##### Примечание 1
Дополнительно о множественном наследовании можно почитать в официальной документации по [ссылке](https://docs.python.org/3/tutorial/classes.html#multiple-inheritance).

##### Примечание 2
 При множественном наследовании атрибуты класса ведут себя так же, как и методы, то есть наследуются дочерним классом со всеми вытекающими особенностями.
```python
class Animal:
    en_name = 'animal'
    ru_name = 'животное'

class Cat(Animal):
    en_name = 'cat'
    ru_name = 'кот'

class Dog(Animal):
    en_name = 'dog'
    ru_name = 'собака'
    
class CatDog(Cat, Dog):
    pass


print(CatDog.en_name)
print(CatDog.ru_name)
```
```
cat
кот
```

##### Примечание 3
Попытка создать класс, MRO которого невозможно определить, приводит к возбуждению исключения.
```python
class A:
    pass

class B(A):
    pass

class C(A, B):
    pass
```
приводит к возбуждению исключения:
```
TypeError: Cannot create a consistent method resolution
order (MRO) for bases A, B
```