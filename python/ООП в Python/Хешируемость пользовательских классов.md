#OOP #ООП #python 


По умолчанию в пользовательских классах сравнение на равенство является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью оператора `is`

Идентичность объекта определяется с помощью функции `id()`. Другими словами, объекты идентичны, если они имеют одинаковый идентификатор во время выполнения программы

Для последующих примеров рассмотрим класс `Point`, описывающий точку на плоскости
```python
class Point:
    def __init__(self, x, y):
        self._x = x                          # координата точки по оси x
        self._y = y                          # координата точки по оси y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 is p1)
print(p1 == p1)

print(p1 is p2)
print(p1 == p2)
```
```
True
True
False
False
```
По умолчанию все пользовательские класса __являются хешируемыми__ и имеют реализованный магический метод `__hash__()`, который и вызывает встроенная функция `hash()`
```python
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1))
print(hash(p2))
```
```
117433932722
117433932728
```
Поскольку у равных объектов должны быть равны и хеш-значения, то магический метод `__hash__()` по умолчанию использует идентификатор объекта. А именно, базовая реализация метода `__hash__()` возвращает значение `is(obj) // 16`
```python
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1), id(p1) // 16)
print(hash(p2), id(p2) // 16)
```
```
150672559026 150672559026
150672559032 150672559032
```
По умолчанию в пользовательских классах методы `__eq__()` и `__hash__()` реализованы таким образом, что экземпляры этих классов равны только сами себе и не равны никаким другим объектам, а сравнения на равенство (`x == y`), идентичность (`x is y`) и сравнение хеш-значений (`hash(x) == hash(y)`) являются эквивалентными операциями