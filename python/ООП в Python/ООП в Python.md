#OOP #ООП #Python #класс


Язык программирования Python появился в 1991 году. К этому времени ООП уже становилось популярным и появлялись первые объектно-ориентированные языки программирования. Поэтому, ориентируясь на чужие успехи и неудачи, Гвидо ван Россум и его коллеги смогли спроектировать достаточно простую и мощную реализацию ООП в Python. Python поддерживает ООП на сто процентов: все данные в нем являются объектами. Числа, строки, списки, словари, функции, модули и даже сами типы данных - все это объекты. Поэтому их можно присваивать переменным, помещать в списки, хранить в словарях, передавать в функции в качестве аргументов и т.д.

```python
import math

def cube(num):
    return num ** 3

print(type(math))
print(type(cube))
print(type(print))
print(type(math.factorial))
print(type(str.upper))
print(type(int))
```
```
<class 'module'>
<class 'function'>
<class 'builtin_function_or_method'>
<class 'builtin_function_or_method'>
<class 'method_descriptor'>
<class 'type'>
```
Как мы видим, в Python всё является объектом, принадлежащим соответствующему классу.

### Создание пользовательских классов и объектов
В Python классы создаются с помощью инструкции `class`, за которой следует имя класса, после которого ставится двоеточие
```python
class <название класса>: 
	<тело класса>
```

Пример объявления класса с минимально возможным функционалом:
```python
class Cat: 
	pass
```

Здесь для задания класса используется инструкция `class`, далее следует имя класса `Cat` и двоеточие. После идет тело класса, которое в нашем случае представлено оператором `pass`, который сам по себе ничего не делает и является просто заглушкой

Как правило, имя класса начинается с заглавной буквы и обычно является существительным или словосочетанием. Имена классов соответствуют соглашению `Upper Camel Case`

`Upper Camel Case` - стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы

Чтобы создать объект класса, нужно воспользоваться следующим синтаксисом:
```Python
<имя переменной> = <имя класса>()
```
В качестве примера создадим экземпляр класса `Cat`
```python
cat = Cat()
```
Теперь переменная `cat` содержит ссылку на объект - `экземпляр класса` `Cat`. Стоит отметить, что объект класса и экземпляр класса - это одно и то же, однако на практике для однозначности используют именно сочетание экземпляра класса, так как сам класс, по сути, тоже является объектом

### Атрибуты объектов
Вернемся к созданию ранее классу `Cat` и создадим два его экземпляра
```python
class Cat:
    pass


cat1 = Cat()
cat2 = Cat()
```
Переменные `cat1` и `cat2` содержат ссылки на два разных объекта - экземпляр класса `Cat`, которые можно наделить различными атрибутами:
```python
cat1.breed = 'Devon Rex'          # порода кошки
cat1.name = 'Nefret'               # имя кошки
cat1.age = 10                       # возраст кошки

cat2.name = 'Ben'
cat2.age = 6
```
Теперь `cat1` - это кот пароды `Devon Rex` с именем `Nefret`, которому `10` лет, а `cat2` - это кот с именем `Ben`, которому `6` лет
```python
cat = Cat()

cat.breed = 'Devon Rex'
cat.name = 'Nefret'
cat.age = 10

print(cat.breed, cat.name)        # обращение к атрибутам

cat.age += 2                      # изменение значения атрибута
print(cat.age)
```
```
Devon Rex Nefret
12
```
При обращении к несуществующему атрибуту будет возбуждено исключение `AttribureError`

### Атрибуты класса
Мы также можем устанавливать атрибуты на уровне всего класса, такие атрибуты называются ***атрибутами класса***. Их значения одинаковы для всех экземпляров этого класса:
```python
class Cat:
    night_vision = True
    paws_count = 4
```
Теперь класс `Cat` имеет два атрибута, доступных по умолчанию всем его экземплярам
```python
class Cat:
    night_vision = True
    paws_count = 4


cat1 = Cat()
cat2 = Cat()

print(cat1.night_vision)
print(cat2.paws_count)
```
```
True
4
```
Так как атрибуты `night_vision` и `paws_count` являются атрибутами всего класса, то мы можем получить к ним доступ, используя точечную запись с именем класса
```python
class Cat:
    night_vision = True
    paws_count = 4


print(Cat.night_vision)
print(Cat.paws_count)
```
```
True
4
```
Как правило, названия атрибутов объектов и классов пишутся с маленькой буквы и соответствуют соглашению `snake case`

`snake case` - стиль написания составных слов, при котором несколько слов разделяются символами нижнего подчеркивания (`_`) и не имеют пробелов в записи, причем каждое слово пишется с маленькой буквы

### Атрибут `__dict__`
Все атрибуты, которыми мы наделяем созданные объекты, хранятся в специальном словаре, который доступен в качестве атрибута `__dict__`
```python
class Cat:
    pass


cat = Cat()

cat.breed = 'Британский'
cat.name = 'Кемаль'
cat.age = 1

print(cat.__dict__)
```
```
{'breed': 'Британский', 'name': 'Кемаль', 'age': 1}
```
Аналогичным образом мы можем получить доступ к атрибутам класса
```python
class Cat:
    night_vision = True
    paws_count = 4


print(Cat.__dict__)
```
```
{'__module__': '__main__', 'night_vision': True, 'paws_count': 4, '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>, '__doc__': None}
```
Обратите внимание, что помимо созданных нами атрибутов класса `night_vision` и `paws_count`, словарь `__dict__` также содержит и другие служебные атрибуты, в том числе описание самого словаря `__dict__`

Атрибуты объектов и классов, которые определил программист, называются __пользовательскими атрибутами__.

```python
class Cat:
    """Класс, описывающий кошку"""
    night_vision = True
    paws_count = 4


print(Cat.__doc__)
```
```
Класс, описывающий кошку
```
Тип любого объекта можно получить через атрибут `__class__`.
```python
class Cat:
    pass


cat = Cat()

print(type(cat))
print(cat.__class__)
print(type(cat) == cat.__class__)
```
```
<class '__main__.Cat'>
<class '__main__.Cat'>
True
```
 Атрибут класса можно изменить только через сам класс
 ```python
class Cat:
    night_vision = True


cat1 = Cat()
cat2 = Cat()

Cat.night_vision = False

print(cat1.night_vision)
print(cat2.night_vision)
```
```
False
False
```
При попытке изменения атрибута класса через его экземпляр мы лишь добавляем этому экземпляру атрибут с аналогичным именем
```python
class Cat:
    night_vision = True


cat1 = Cat()
cat2 = Cat()

cat1.night_vision = False

print(cat1.night_vision, cat1.__dict__)
print(cat2.night_vision, cat2.__dict__)
```
```
False {'night_vision': False}
True {}
```
Также в примере выше можно заметить, что поиск атрибута происходит сначала в словаре атрибутов экземпляра (`cat1.__dict__`, `cat2.__dict__`), а затем в словаре атрибутов класса (`Cat.__dict__`)

### Оглавление:
#### [[Python]]
#### [[Функции, работающие с атрибутами]]
#### [[Методы]]
#### [[Примеры проектирования классов]]
#### [[Модификаторы доступа]]
#### [[Свойства, функция property()]]
