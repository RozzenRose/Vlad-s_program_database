#OOP #ООП #Python #магический_метод #hash 


Если пользовательский класс переопределяет магический метод `__eq__()`, то он дополнительно должен переопределить магический метод `__hash__()` таким образом, чтобы равные объекты имели равные хеш-значения
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __hash__(self):
        return hash((self.x, self.y))


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p2)
print(hash(p1) == hash(p2))
```
```
True
True
```
В нашем случае две точки равны в том случае, если равны их соответствующие координаты `x` и `y`.  Хеш-значение точки вычисляется на основе кортежа, содержащего обе его координаты, поэтому равные точки будут иметь одинаковые хеш-значения.

Вычисления хеш-значения объекта на основе значений всех его атрибутов является распространенной практикой

Приведем ряд правил, которым нужно следовать, создавая хешируемый пользовательский класс:
1. Если пользовательский класс не переопределяет метод `__eq__()`, то он не должен переопределять метод `__hash__()`
2. Если изменяемый пользовательский класс переопределяет метод `__eq__()`, то он не должен переопределять метод `__hash__()`
3. Если неизменяемый пользовательский класс переопределяет метод `__eq__()`, то переопределение метода `__hash__()` остается на выбор. Однако если он переопределяет метод `__hash__()`, то он должен быть реализован таким образом, чтобы равные экземпляры имели одинаковые хеш-значения

Отдельного рассмотрения требуется ситуация, когда класс переопределяет метод `__eq__()`, но не переопределяет метод `__hash__()`. В таком случае метод `__hash__()` будет иметь значение `None`
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p = Point(1, 2)

print(Point.__hash__)
```
```
None
```
Если метод `__hash__()` в классе имеет значение `None`, то при попытке вычислить хеш-значение экземпляра такого класса будет возбуждено исключение `TypeError`
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p = Point(1, 2)

print(hash(p))
```
```
TypeError: unhashable type: 'Point'
```
Если пользовательский класс не имеет согласованных рабочих методов `__hash__()` и `__eq__()`, то его экземпляры не могут быть ключами в словарях и элементами в множествах

Мы также можем явно заменить метод `__hash__()` значением `None`, что бы сделать класс нехешируемым
```python
class Point:
    __hash__ = None
    
    def __init__(self, x, y):
        self.x = x
        self.y = y


p = Point(1, 2)

print(hash(p))
```
```
TypeError: unhashable type: 'Point'
```

### Hash-Equal контакт
Методы `__eq__()` и `__hash__()` тесно связаны друг с другом, и при реализации одного метода, нужно думать над реализацией другого. Так, если два объекта являются равными, то должны быть равны и их хеш-значения. Если два объекта имеют различные хеш-значения, то и сами объекты должны быть различны

### Примечание
#### Примечание 1
Функция `hash()` обрезает значение, возвращаемое методом `__hash__()`, до определенного размера. На 64-х разрядном компьютере встроенная функция `hash()` возвращает целочисленной значение из диапазона `[-2305843009213693950; 2305843009213693950]`
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __hash__(self):
        return 123456789012345678901234567890


p = Point(1, 2)

print(hash(p))
```
```
248789772095949448
```
Очевидно, что напечатанное значение равняется `123456789012345678901234567890 % 2305843009213693951`

#### Примечание 2
В ситуациях, когда сравнение экземпляров класса и вычисление их хеш-значений происходит на основе атрибутов, удобно определить свойство, возвращающее кортеж с этими атрибутами.
```python
class Point:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __eq__(self, other):
        if isinstance(other, Point):
            return self._fields == other._fields
        return NotImplemented

    def __hash__(self):
        return hash(self._fields)
    
    @property
    def _fields(self):
        return self.x, self.y, self.z


p1 = Point(1, 2, 3)
p2 = Point(1, 2, 3)
p3 = Point(4, 5, 6)

print(p1 == p2)
print(p1 == p3)
print(hash(p1) == hash(p2))
print(hash(p1) == hash(p3))
```
```
True
False
True
False
```