#OOP #ООП #Python #магический_метод 


![[Pasted image 20240819151419.png]]Магические методы (dunder methods | double under) - это общий термин, относящийся к специальным методам в классах `Python`. Для них нет единого определения, поскольку их применение разнообразно. Магические методы, как правило, добавляют в класс специальный функционал. Они всегда обрамлены двумя нижними подчеркиваниями, например, `__init__()`

Магические методы не предназначены для прямого вызова, однако их вызов происходит автоматически при определенных действиях. Например, мы явно не вызываем метод `__init__()` при создании нового экземпляра класса, но вместо этого данный метод вызывается внутренне. Все, что нам нужно сделать, это реализовать метод внутри класса должным образом.

Поскольку магические методы характеризуются двойным подчеркиванием, их часто называют `dundrs`, что означает `Double Underscore`

### Магические методы:
- [[__new__() __init__()]] - создание экземпляра класса и инициализация класса
- [[__del__()]] - финализатор, удаление ссылок на экземпляр
- [[__str__() __repr__()]] - формальное и неформальное представление в строке
#### Сравнение:
- [[__eq__() __ne__()]]  - сравнение экземпляров на равенство
- [[__lt__() __gt__()]] - сравнение экземпляров на больше/меньше
- [[__le__() __ge__()]] - сравнение экземпляров на большеравно/меньшеравно
- Существует специальный декоратор [[python/ООП в Python/Методы/Встроенные декораторы/@total_ordering|@total_ordering]]
### Сравнение объектов
Рассмотрим класс `Point`, описывающий точку на плоскости и создадим два экземпляра этого класса
```python
class Point:
    def __init__(self, x, y):
        self.x = x                       # координата точки по оси x
        self.y = y                       # координата точки по оси y


p1 = Point(1, 2)
p2 = Point(1, 2)
```
Точки `p1` и `p2` являются разными объектами, и мы можем в этом убедиться, сравнив их с помощью оператора `is`
```python
print(p1 is p2)
```
```
False
```
Если мы попытаемся сравнить два данных объекта с помощью оператора `==`, мы также получим в качестве результата `Fasle`, несмотря на то что оба объекта имеют равные значения атрибутов
```python
print(p1 == p2)
```
```
False
```
Дело в там, что сравнение на равенство по умолчанию является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью `is`
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p1)
print(p2 == p2)
```
```
True
True
```
Чтобы определить, как будет происходить сравнение на равенство, нам потребуется определить в классе метод `__eq__()`. Когда мы сравним два объекта с помощью оператора `==`, `Python` автоматически вызывает данный метод у левого операнда, передавая методу в качестве аргумента правый операнд. То есть выражение `p1 == p2` равносильно вызову `p1.__eq__(p2)`

Для возможности сравнивать экземпляры класса `Point` определим в нем метод `__eq__()`. Будем считать точки равными, если они имеют равные координаты по обеим осям
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)
print(p1 == p3)
print(p2 == p3)
```
```
True
False
False
```
Как мы видим, теперь равенство объектов определяется иначе, а именно на основании их координат. Точка `p1` равна точке `p2`, так как их координаты совпадают, в то время как точки `p1` и `p2` не равны точке `p3`, так как их координаты не совпадают

 Магические методы `__eq__(), __ne__(), __gt__(), __lt__(), __ge__()` и `__le__()` буквально соответствуют английским equal (равно), not equal (не равно), greater than (больше, чем), less than (меньше, чем), greater than or equal (больше или равно) и less than or equal (меньше или равно) соответственно.