#OOP #ООП #Python #магический_метод #итератор


`__iter__()` - метод, возвращающий сам итератор, помещается в класс, со строкой возврата самого объекта
```python
def __iter__(self):
	return self
```
По сути это обозначает, что экземпляр класса является итератором, а сам этот дандер определяется для того, что бы этот экземпляр можно было закидывать в функцию `iter()`, которая в общем то вызовет именно дандер `__iter__()`

`__next__()` - метод, код которого выполняется в случае, когда экземпляр, класса будет передан в функцию `next()`.

Для того чтобы экземпляр класса вел себя как итератор, он должен возвращать последовательные значения при передаче экземпляра в функцию `next()`. Функция `next()` запросит у экземпляра дандер `__next__()`, а значит, дандер `__next__()` должен быть определен, как метод экземпляра

Напишем для наглядности несколько примеров:
### Примеры создания итераторов:
##### Пример 1
Реализуем класс `Counter`, экземплярами которого являются итераторы, генерирующие последовательность целых чисел от значения `low` до значения `high` включительно с шагом один
```python
class Counter:                             
    def __init__(self, low, high):
        self.low = low
        self.high = high
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.low > self.high:
            raise StopIteration
        self.low += 1
        return self.low - 1

counter1 = Counter(3, 10) # создаем итератор Counter, передавая значения low=3, high=10

for i in counter1:        # неявно вызываем функцию next()
    print(i)

counter2 = Counter(100, 103)            # создаем итератор Counter, передавая значения low=100, high=103
print(next(counter2))                   # явно вызываем функцию next()
print(next(counter2))                   # явно вызываем функцию next()
```
```
3
4
5
6
7
8
9
10
100
101
```
Цикл `for` за кулисами вызывает один раз метод `__iter__()` у итерируемого объекта для получения итератора, а затем метод `__next__()` до тех пор, пока не будет возбуждено исключение `StopIteration`
##### Пример 2
Реализуйте класс итератор `EvenNumbers`, экземплярами которого являются бесконечные итераторы, генерирующие последовательность всех целых четных чисел от значения `being`
```python
class EvenNumbers:                             
    def __init__(self, begin):                 
        self.begin = begin + begin % 2
    
    def __iter__(self):
        return self
    
    def __next__(self):
        value = self.begin
        self.begin += 2
        return value

evens1 = EvenNumbers(10)                # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = EvenNumbers(101)               # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```
```
10
12
14
16
18
20
102
104
106
108
```
Обратите внимание, что наш итератор является бесконечным, так как метод `__next__()` не возбуждает исключение `StopIteration`. При работе с бесконечными итераторами нужно быть осторожными, чтобы не попасть в бесконечный цикл
```python
evens = EvenNumbers(2)                  # все четные числа от 2 до бесконечности

for num in evens:
    print(num)
```
```
2
4
6
8
10
12
14
16
...
```
##### Пример 3
Реализуем класс итератор `Factorials`, экземплярами которого являются бесконечные итераторы, генерирующие последовательность факториалов всех натуральных чисел (от `1` до бесконечности)
```python
class Factorials:
    def __init__(self):
        self.value = 1
        self.index = 1
        
    def __iter__(self):
        return self
        
    def __next__(self):
        self.value *= self.index
        self.index += 1
        return self.value

infinite_factorials = Factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
    else:
        break
```
```
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```
### Пример создания итерируемого объекта
Для создания итератора нам требуется определить методы `__next__()` и `__iter__()` в то время как для создания итерируемого объекта достаточно определить только метод `__iter__()`, возвращаемым значением которого является итератор. При реализации метода `__iter__()` у итерируемых объектов удобно пользоваться всеми возможностями генераторов, в именно: генераторными выражениями и генераторными функциями (ключевые слова `yield` и `yield from`

Реализуем класс `Order`, описывающий список покупок, экземпляры которого поддерживают итерацию

Определяем класс `Order` с методом, реализующим протокол итерируемого объекта:
`__iter__()` - метод, возвращающий итератор
```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)          # список покупок
        self.customer = customer        # имя покупателя

    def __iter__(self):
        yield from self.cart            # или с помощью выражения return (elem for elem in self.cart)

order = Order(['банан', 'яблоко', 'лимон'], 'Элой')

for item in order:
    print(item)
```
```
банан
яблоко
лимон
```