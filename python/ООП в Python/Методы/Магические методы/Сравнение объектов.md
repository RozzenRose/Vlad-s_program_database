#OOP #ООП #Python #магический_метод 


Рассмотрим класс `Point`, описывающий точку на плоскости и создадим два экземпляра этого класса
```python
class Point:
    def __init__(self, x, y):
        self.x = x                       # координата точки по оси x
        self.y = y                       # координата точки по оси y


p1 = Point(1, 2)
p2 = Point(1, 2)
```
Точки `p1` и `p2` являются разными объектами, и мы можем в этом убедиться, сравнив их с помощью оператора `is`
```python
print(p1 is p2)
```
```
False
```
Если мы попытаемся сравнить два данных объекта с помощью оператора `==`, мы также получим в качестве результата `Fasle`, несмотря на то что оба объекта имеют равные значения атрибутов
```python
print(p1 == p2)
```
```
False
```
Дело в там, что сравнение на равенство по умолчанию является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью `is`
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p1)
print(p2 == p2)
```
```
True
True
```
Чтобы определить, как будет происходить сравнение на равенство, нам потребуется определить в классе метод `__eq__()`. Когда мы сравним два объекта с помощью оператора `==`, `Python` автоматически вызывает данный метод у левого операнда, передавая методу в качестве аргумента правый операнд. То есть выражение `p1 == p2` равносильно вызову `p1.__eq__(p2)`

Для возможности сравнивать экземпляры класса `Point` определим в нем метод `__eq__()`. Будем считать точки равными, если они имеют равные координаты по обеим осям
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2)
print(p1 == p3)
print(p2 == p3)
```
```
True
False
False
```
Как мы видим, теперь равенство объектов определяется иначе, а именно на основании их координат. Точка `p1` равна точке `p2`, так как их координаты совпадают, в то время как точки `p1` и `p2` не равны точке `p3`, так как их координаты не совпадают

 Магические методы `__eq__(), __ne__(), __gt__(), __lt__(), __ge__()` и `__le__()` буквально соответствуют английским equal (равно), not equal (не равно), greater than (больше, чем), less than (меньше, чем), greater than or equal (больше или равно) и less than or equal (меньше или равно) соответственно.


### Операции с атрибутами
Вызов функций `getattr(), setattr()` и `delattr()`, аналогично точечной нотации, приводит к вызовам соответствующих магических методов `__getattribute__(), __getattr__(), __setattr__()` и `__delattr__()`.

```python
class Cat:
    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return object.__getattribute__(self, attr)
    
    def __getattr__(self, attr):
        print(f'Возвращаю значение по умолчанию')
        return None
    
    def __setattr__(self, attr, value):
        print(f'Устанавливаю атрибуту {attr} значение {value}')
        self.__dict__[attr] = value
    
    def __delattr__(self, attr):
        print(f'Удаляю атрибут {attr}')
        del self.__dict__[attr]


cat = Cat()

setattr(cat, 'name', 'Кемаль')
print()
getattr(cat, 'name')
print()
getattr(cat, 'breed')
print()
delattr(cat, 'name')
```
```no-highlight
Устанавливаю атрибуту name значение Кемаль
Возвращаю значение атрибута __dict__

Возвращаю значение атрибута name

Возвращаю значение атрибута breed
Возвращаю значение по умолчанию

Удаляю атрибут name
Возвращаю значение атрибута __dict__
```