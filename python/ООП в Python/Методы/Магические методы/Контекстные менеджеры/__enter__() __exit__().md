#OOP #ООП #Python #магический_метод 


Контекстный менеджер — это объект, определяющий контекст выполнения в операторе `with`.

Протокол контекстных менеджеров состоит всего из двух методов:
- `__enter__()` – вводит контекст и при необходимости возвращает некоторый объект. Значение, возвращаемое этим методом, привязывается к переменной в предложении `as` оператора `with`
- `__exit__()` – предоставляет выход из контекста и возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавлять возбужденное исключение. При возбуждении исключения во время выполнения тела блока `with`, аргументы содержат тип исключения `exc_type`, объект исключения `exc_value` и информацию о трассировке `traceback`. В противном случае все три аргумента равны `None`

Создадим простой контекстный менеджер `CustomContextManager`, который просто выводит текст в методах: `__enter__()` и `__exit__()`
```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        print(exc_type, exc_value, traceback, sep='\n')

with CustomContextManager() as manager:
    print(manager)
```
```
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
None
None
None
```
При выполнении оператора `with` сначала создается экземпляр класса `CustomContextManager`, а затем вызывается его метод `__enter__()`, который печатает текст `вход в контекстный менеджер...` и возвращает строку `Python generation!`, которая присваивается переменной `manager`. Далее исполняется тело оператора `with`, после чего вызывается метод `__exit__()`. Поскольку во время выполнения тела оператора `with`  не было возбуждено никакое исключение, то все три аргумента `exc_type, exc_value` и `traceback` метода `__exit__()` равны `None`

Рассмотрим ситуацию, в которой в теле оператора `with` возбуждается исключение
```python
with CustomContextManager() as manager:
    print(manager)
    print(manager[100])                                 # обращаемся по несуществующему индексу
```
выводит (адрес может отличаться):
```
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
<class 'IndexError'>
string index out of range
<traceback object at 0x000001E5CBB57500>
```
после него возбуждается исключение:
```
IndexError: string index out of range
```
Как мы видим, аргументы метода `__exit__()` содержат информацию о возбужденном исключении:
- `exc_type` – тип исключения, в данном случае `IndexError`
- `exc_value` – объект самого исключения
- `traceback` – информация о трассировке (подробнее о трассировке можно почитать по [ссылке](https://docs.python.org/3/library/traceback.html))

В атрибуте `exc_value.args` можно найти параметры, переданные конструктору исключения, например, сообщение об ошибке

### Обработка исключений внутри блока `with`
Для обработки исключений внутри блока `with` нужно добавить дополнительный код в метод `__exit__()`. Как уже было сказано выше, метод `__exit__()` возвращает логический флаг (тип `bool`), указывающий на то, следует ли подавлять возбужденное исключение или нет.

Модифицируем наш контекстный менеджер `CustomContextManager` следующим образом:
```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        if isinstance(exc_value, IndexError):
            print(f'Тип возникшего исключения: {exc_type}')
            print(f'Текст исключения: {exc_value}')
            return True            # подавляем возбужденное исключение IndexError


with CustomContextManager() as manager:
    print(manager)
    print(manager[100])            # обращаемся по несуществующему индексу
```
```
Вход в контекстный менеджер...
Python generation!
Выход из контекстного менеджера...
Тип возникшего исключения: <class 'IndexError'>
Текст исключения: string index out of range
```
и больше не приводит к возбуждению исключение `IndexError`, поскольку мы обработали этот тип исключения в методе `__exit__()`. Возврат значения `True` позволяет поглотить возбужденное в теле оператора `with` исключение и продолжить выполнение с оператора, __непосредственно следующего__ за оператором `with`

Если при выполнении тела оператора `with` не возбуждается исключение `IndexError`, то метод возвращает значение `None`, которое приводит к логическому `False`. Для придания наглядности рекомендуется явно возвращать значение `False` из метода `__exit__()`:
```python
class CustomContextManager:
    def __enter__(self):
        print('Вход в контекстный менеджер...')
        return 'Python generation!'

    def __exit__(self, exc_type, exc_value, traceback):
        print('Выход из контекстного менеджера...')
        if isinstance(exc_value, IndexError):
            print(f'Тип возникшего исключения: {exc_type}')
            print(f'Текст исключения: {exc_value}')
            return True             # подавляем возбужденное исключение IndexError
        return False                # все остальные типы исключений не подавляются
```
Передаваемое исключение `exc_value` не следует никогда повторно возбуждать в методе `__exit__()`, вместо этого метод `__exit__()` должен возвращать значение `False`, чтобы указать, что метод завершился успешно и не хочет подавлять возбужденное исключение. Это позволяет коду управления контекстом легко определять, действительно ли метод `__exit__()` потерпел неудачу

Исключения, возникающие во время выполнения метода `__exit__()`, замещают все исключения, возникшие в теле оператора `with`

Если мы забыли названия и количество аргументов, которые передаются в метод  `__exit__()` и при этом мы их не используем, то следует использовать следующую сигнатуру метода `__exit__()`:
```python
def __exit__(self, *args, **kwargs):
    ...
```
### Примеры использования встроенных контекстных менеджеров
#### Пример 1
Самым простым вариантом использования встроенного контекстного менеджера является файловый объект, который возвращается функция `open()`. Этот объект реализует протокол контекстного менеджера, в чем несложно убедиться
```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    print('__enter__' in dir(file))                      # наличие метода __enter__()
    print('__exit__' in dir(file))                       # наличие метода __exit__()
    file.write('Python generation!')
```
```
True
True
```
#### Пример 2
Мы можем использовать контекстный менеджер для настройки объектов типа `Decimal`, который обеспечивает точные вычисления с вещественными числами (в отличии от типа `float`). Функция `localcontent()` контекста мы можем устанавливать точность, правила округления и т.д.
```python
from decimal import Decimal, localcontext

num1 = Decimal('1')
num2 = Decimal('9')

print(num1 / num2)                   # по умолчанию 28 знаков после запятой

with localcontext() as ctx:
    ctx.prec = 5                     # устанавливаем 5 знаков после запятой
    print(num1 / num2)

with localcontext() as ctx:
    ctx.prec = 10                    # устанавливаем 10 знаков после запятой
    print(num1 / num2)
```
```
0.1111111111111111111111111111
0.11111
0.1111111111
```
#### Пример 3
Встроенный модуль `os` содержит функцию `scandir()`, которая итератор типа `ScandirIterator`, поддерживающий протокол контекстного менеджера. Эта функция специально разработана для обеспечения оптимальной производительности при перемещении по структуре папок
```python
import os

with os.scandir('.') as entries:
    for entry in entries:
        print(entry.name, '--->', entry.stat().st_size, 'bytes')
```
выводит информацию о файлах, которые находятся в папке с исполняющимся файлом (вывод может отличаться):
```
18+.png ---> 60 bytes
ducks.zip ---> 641592 bytes
logo.bmp ---> 32160 bytes
with.py ---> 138 bytes
Любимая уточка Бэтмен.txt ---> 97 bytes
Математика для программиста.doc ---> 759780 bytes
Мемуары Поколения.txt ---> 5909400 bytes
План для курса алгоритмы и структуры данных.txt ---> 590940 bytes
```

#### Пример 4
Встроенный модуль `tempfile` содержит контекстный менеджер `TemporaryFile`, который позволяет создавать и удалять временный файлы автоматически
```python
from tempfile import TemporaryFile

with TemporaryFile(mode='r+') as file:
    file.write('Python generation!')
    file.seek(0)
    content = file.read()
    print(content)
```
```
Python generation!
```
В этом примере временный файл создается при входе в тело блока контекста и удаляется при выходе. Такой подход позволяет избежать утечек памяти и ошибок, связанных с неправильным удалением временных файлов
Для того чтобы иметь возможность писать в файл и читать из файла, мы используем режим доступа `r+`

#### Пример 5
Встроенный модуль `threading` содержит контекстный менеджер `Lock`, который обеспечивает примитивную блокировку для предотвращения одновременного изменения общего ресурса несколькими потоками в многопоточном приложении
```python
from threading import Lock


with Lock() as lock:
     защищенная область
     смело выполняем любые действия, не думая о гонке потоков
```
создает защищенную область (критическая секция), которая предотвращает одновременный доступ из разных потоков к общим ресурсам.

### [[Примеры создания контекстных менеджеров]]
### [[Одноразовые и многоразовые контекстные менеджеры]]