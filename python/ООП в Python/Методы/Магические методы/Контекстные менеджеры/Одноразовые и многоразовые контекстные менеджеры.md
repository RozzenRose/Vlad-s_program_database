#OOP #ООП #Python #магический_метод 


Контекстные менеджеры обычно делят на три категории:
- одноразовые
- многоразовые
- реентерабельные
#### Одноразовые контекстные менеджеры
Большинство контекстных менеджеров написаны таким образом, что они могут эффективно использоваться в операторе `with` только один раз. Такие менеджеры называют __одноразовыми__, и они должны создаваться заново каждый раз перед использованием. Когда они уже используются или использовались в операторе `with` - попытка использовать их во второй  раз может привести к возбуждению исключения или приведет к неправильной их работе.

Классическим примером одноразового контекстного менеджера является объект, возвращаемые встроенной функцией `open()`
```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    file.write('Python generation!')
    
with file:
    file.write('Python generation!')
```
```
ValueError: I/O operation on closed file.
```
поскольку первый оператор `with` закрывает файл, предотвращая любые дальнейшие операции ввода-вывода с использованием этого файлового объекта.

#### Многоразовые контекстные менеджеры
__Многоразовый__ контекстный менеджер - это менеджер, который можно повторно использовать в рамках __невложенных__ операторов `with`. Примером многоразового контекстного менеджера может служить `Timer`, позволяющий измерять время выполнения блока кода:
```python
from time import perf_counter

class Timer:
    def __enter__(self):
        self.start = perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.elapsed = perf_counter() - self.start

from time import sleep

timer = Timer()

with timer:
    sleep(1.5)
print('Затраченное время:', timer.elapsed)

with timer:
    sleep(0.7)
print('Затраченное время:', timer.elapsed)

with timer:
    sleep(1)
print('Затраченное время:', timer.elapsed)
```
```
Затраченное время: 1.504402399994433
Затраченное время: 0.71097999997437
Затраченное время: 1.0067103998735547
```

#### Реентерабельные контекстные менеджеры
Реентерабельный контекстный менеджер - это менеджер, который можно повторно использовать в рамках __вложенных__ операторов `with`. Примером реентерабельного контекстного менеджера может служить `Indenter`, который позволяет печатать текст на разных уровнях отступа:
```python
class Indenter:
    def __init__(self):
        self.level = -1

    def __enter__(self):
        self.level += 1
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.level -= 1

    def print(self, text):
        print('    ' * self.level + text)
```
Как мы видим, метод `__enter__()` увеличивает значение атрибута `level` на `1` каждый раз, когда поток выполнения входит в контекст. Метод `__exit__()` уменьшает значение атрибута `level` на `1`, чтобы печатаемый текст возвращался на один уровень отступа каждый раз, когда мы выходим из контекста. Ключевым моментом в этом примере является то, что метод `__enter__()` возвращает значение текущего экземпляра `self`, что позволяет нам повторно использовать один и тот же контекстный менеджер в нескольких вложенных операторах `with`
```python
with Indenter() as indent:
    indent.print('python')
    with indent:
        indent.print('beegeek')
        with indent:
            indent.print('stepik')
        indent.print('pygen')
    indent.print('bye-bye')
```
```
python
    beegeek
        stepik
    pygen
bye-bye
```