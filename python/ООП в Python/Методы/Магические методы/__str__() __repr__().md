#OOP #ООП #Python #магический_метод #str #repr


За строковое представление объектов отвечают методы `__str__()` и `__repr__()`. именно эти методы вызываются, когда объект передается в функцию `str()` или `repr()`
```python
from datetime import date

dt = date(2022, 10, 23)

print(str(dt) == dt.__str__())
print(repr(dt) == dt.__repr__())
```
```
True
True
```
Если методы `__str__()` и `__repr__()` не определены в классе. то используются их базовые реализации
```python
class MyClass:
    pass


obj = MyClass()

print(str(obj))
print(repr(obj))
```
```
<__main__.MyClass object at 0x0000022392277A90>
<__main__.MyClass object at 0x0000022392277A90>
```
Если методы `__str__()` и `__repr__()` явно не определены в классе, то их базовые реализации возвращают одно и то же значение

Строковое представление объектов по умолчанию не очень информативно, поэтому при реализации собственных классов бывает полезно определить методы `__str__()` и `__repr__()`, чтобы получить удобное строковое представление объектов как в формальном, так и в неформальном виде

Рассмотрим класс `Cat` м реализованными методами `__str__()` и `__repr__()`
```python
class Cat:
    def __init__(self, name):
        self.name = name                        # имя кошки

    def __str__(self):
        return f'Кот по имени {self.name}'

    def __repr__(self):
        return f"Cat('{self.name}')"

cat = Cat('Никся')

print(str(cat))
print(repr(cat))
```
```
Кот по имени Никся
Cat('Никся')
```
Здесь метод `__str__()` возвращает строку, которая представляет собой неформальное описание объекта. Метод `__repr__()` возвращает формальное представление объекта, которое можно преобразовать обратно в объект с помощью функции `eval()`

Принято, что метод `__repr__()` должен возвращать строку, которую можно преобразовать обратно в объект с помощью функции `eval()`

Оба метода всегда должны возвращать объекты типа `str` иначе произойдет возбуждение исключения `TypeError`

Если метод `__repr__()` реализован, а метод `__str__()` не реализован, то при вызове метода `__str__()` будет вызван метод `__repr__()` и получен его ответ. Наоборот это почему то работает