#OOP #ООП #Python #магический_метод 


__У всех итерируемых объектов__ есть магический метод `__iter__()`, который преобразует итерируемый объект в итератор. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод.
```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)

print(type(words))
print(type(iterator))
```
```
<class 'list'>
<class 'list_iterator'>
```
__У всех итераторов__ есть магический метод `__next__()`, который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот дандер.
```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(next(iterator))                     # равнозначно iterator.__next__()
print(next(iterator))                     # равнозначно iterator.__next__()
```
```
hello
beegeek
```
Если объект итератором не является, то есть у него нет дандера `__next___()`, то вызов функции `next()` приведет к ошибке
```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```
```
TypeError: 'list' object is not an iterator
```
__У всех итераторов__ есть метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором
```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)                   # равнозначно words.__iter__()
iterator2 = iter(iterator1)               # равнозначно iterator1.__iter__()

print(iterator1 is iterator2)
```
```
True
```
Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект - итератор на основе этого итерируемого объекта

Возникает вопрос, для чего итераторы содержат дандер `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` – превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект.

Если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на основе 
того итерируемого объекта.

Получается, в итераторах метод `__iter__()` нужен лишь для совместимости. Ведь если `for` работает как с итераторами, так и с итерируемыми объектами, но последние требуют преобразования к итератору, и `for` вызывает `__iter__()` без оценки того, что ему передали, то требуется, чтобы оба - итератор `iterator` и итерируемый объект `iterable` - поддерживали этого метод. С точки зрения наличия в классе дандера `__iter__()` итераторы можно считать подвидом итерируемых объектов.

Подробнее о дандерах [[__iter__() __next__()]]
**Примечание.** Особенности итерируемых объектов и итераторов:
1. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `iter()`, — итерируемый объект
2. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `next()`, — итератор
3. любой объект, возвращающий сам себя при передаче в функцию `iter()`, — итератор