#OOP #ООП #Python #магический_метод #атрибуты #getattribute


В `Python` операция обращения к атрибуту определяется не одним, а двумя дандерами: `__getattribute__()` и `__getattr__()`. Разница между ними в том, что метод `__getattribute__()` вызывается первым и вызывается всегда, а метод `__getattr__()` вызывается только в том случае, если атрибута, к которому происходит обращение, не существует. Если атрибут существует, метод `__getattribute__()` возвращает его значение, в противном случае вызывается метод `__getattr__()`

Метод `__getattribute__()` может либо сам вызвать метод `__getattr__()`, либо возбудить исключение `AttributeError`, и тогда метод `__getattr__()` будет вызван автоматически

Рассмотрим класс `Cat` и определим в нем метод `__getattribute__()`, внутри которого дополнительно будем выводить информирующий текст
```python
class Cat:
    def __init__(self, name):
        self.name = name                                # имя кошки
        
    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return object.__getattribute__(self, attr)      # получение значения атрибута attr объекта self


cat = Cat('Никся')

print(cat.name)
```
```
Возвращаю значение атрибута name
Никся
```
Для понимания принципа получения значения атрибута в теле метода `__getattribute__()` нужно вспомнить про существование базового класса `object`. Здесь мы обращаемся к методу `__getattribute__()` класса `object` и передаем ему в качестве аргумента объект и имя атрибута, значение по которому хотим получить. Метод `__getattribute__()` класса `object` возвращает значение атрибута по указанному имени или возбуждает исключение `AtributeError`, если атрибут с указанными именем не был найден

Может возникнуть вопрос, почему мы пользуемся базовой реализацией метода `__getattribute__()`, вместо того чтобы обратиться к атрибуту через словарь атрибутов `__dict__`. Дело в том, что обращение к словарю `__dict__` приведет к бесконечным рекурсивным вызовам метода `__getattribute__()`, так как словарь `__dict__` сам является атрибутом
```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return self.__dict__[attr]


cat = Cat('Никся')

print(cat.name)
```
```
Возвращаю значение атрибута name
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
Возвращаю значение атрибута __dict__
...
```
До тех пор, пока не будет достигнуто максимальное значение глубины рекурсии, а затем возбужденно исключение:
```
RecursionError: maximum recursion depth exceeded while calling a Python object
```
Метод `__getattribute__()` может вести себя так, будто атрибут заведомо существует, и не выполнять каких-либо дополнительных проверок. Если атрибута не существует, базовая реализация все равно возбудит исключение `AttributeError`, и управление будет передано методу `__getattr__()`

