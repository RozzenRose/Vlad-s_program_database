#OOP #ООП #Python #магический_метод #init #new


В `Python` для создания экземпляра класса достаточно вызвать данный класс как функцию и передать ему соответствующий набор аргументов, если это необходимо
```python
class MyClass:
    pass


obj = MyClass()

print(obj)
print(type(obj))
```
создает экземпляр класса `MyClass`, присваивает его переменной `obj` и выводит (адрес может отличаться):
```
<__main__.MyClass object at 0x000001FCABBE6560>
<class '__main__.MyClass'>
```

Когда мы вызываем класс, мы запускаем внутренний процесс __конструирования экземпляра класса__, который состоит их двух шагов:
1. создание нового пустого экземпляра
2. инициализация созданного экземпляра класса

Для выполнения первого шага все классы имеют магический метод `__new__()`, который отвечает за создание и возврат нового пустого экземпляра класса. Затем созданный экземпляр передается в метод `__init__()` для инициализации, то есть для установки его атрибутами необходимых значений

Мы уже хорошо знакомы с процессом инициализации и методом `__init__()`, который в качестве первого аргумента `self` принимает уже созданный экземпляр класса, однако его создание всегда происходило без нашего ведома.

Непосредственное создание объекта происходит с помощью метода `__new__()`. Данный метод вызывается самым первым при конструировании объекта. Метод `__new__()` принимает в качестве первого обязательного аргумента класс, а затем, как правило, произвольное количество позиционных и именованных аргументов
```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        return instance


obj = MyClass()

print(obj)
print(type(obj))
```
выводит (адрес может отличаться):
```
<__main__.MyClass object at 0x000002A321CF6C20>
<class '__main__.MyClass'>
```
В примере выше метод `__new__()` создает экземпляр класса `MyClass`, присваивает его переменной `instance` и возвращает данный экземпляр

Для понимания процесса создания экземпляра стоит упомянуть важную деталь: в `Python` существует класс под названием `object`, который является родительским абсолютно для всех классов

Класс `object` имеет множество базовых методов, одним из которых является метод `__new__()`, отвечающий за создание всех объектов в `Python`. Данный метод принимает в качестве аргумента класс и возвращает экземпляр этого класса

Таким образом, конструкция `object.__new__(cls)` позволяет нам обратиться к методу `__new__()` класса `object` и создать экземпляр класса `cls`, в нашем случае класса `MyClass`


#### Особенности метода `__new__()`
Первым обязательным аргументом метода `__new__()` пользовательского класса является сам класс, после которого, как правило, следуют произвольное количество позиционных и именованных аргументов. Дело в том, что аргументы, указываемые при вызове класса, передаются как в метод `__init__()`, так и в метод `__new__()`
```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print(args, kwargs)
        instance = object.__new__(cls)
        return instance


obj = MyClass(1, 2, c=3, d=4)
```
```
(1, 2) {'c': 3, 'd': 4}
```
Для большей гибкости метод `__new__()` всегда рекомендуется определить именно с произвольным количеством позиционных и именованных параметров

#### Ручное конструирование экземпляра класса
Конструирование экземпляра класса происходит при помощи последовательного вызова методов `__new__()` и `__init__()`, первый из которых отвечает за его создание, а второй - за инициализацию
```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat('Кемаль')

print(type(cat))
print(cat.name)
```
```
1. Создание экземпляра класса Cat
2. Инициализация созданного экземпляра класса Cat
<class '__main__.Cat'>
Кемаль
```
Мы можем воссоздать весь этот процесс вручную, вызывая методы `__new__()` и `__init__()` напрямую
```python
class Cat:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Cat')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Cat')
        self.name = name


cat = Cat.__new__(Cat)
Cat.__init__(cat, 'Кемаль')

print(type(cat))
print(cat.name)
```
```
1. Создание экземпляра класса Cat
2. Инициализация созданного экземпляра класса Cat
<class '__main__.Cat'>
Кемаль
```
Метод `__new__()` является статическим методом. Однако при его определении в классе не нужно использовать декоратор `@staticmethod`, так как `Python` делает это автоматически

#### Реализация синглтона
При создании пользовательских классов, как правило, не требуется предоставлять собственную реализацию метода `__new__()`. Однако есть несколько интересных вариантов использования этого метода. Например, мы можем использовать метод `__new__()` для создания __синглтонов__, то есть объектов существующих в единственном экземпляре.

Реализация синглтонов возможна с атрибутом класса, содержащим единственный экземпляр класса, который будет возвращаться при каждом вызове метода `__new__()`
```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance                      


first = Singleton()
second = Singleton()

print(first)
print(second)
print(first is second)
```
```
<__main__.Singleton object at 0x00000275CF7DB8B0>
<__main__.Singleton object at 0x00000275CF7DB8B0>
True
```