#OOP #ООП #Python


### Методы в Python
В Python есть несколько типов методов:
1. [[Методы экземпляра класса]]
2. [[Методы класса]]
3. Статические методы
### Встроенные декораторы
[[@property]] - создает параметры атрибутов из методов экземпляра класса
[[@classmethod]] - создание методов класса
[[@staticmethod]] - создание статических методов
[[python/ООП в Python/Методы/Встроенные декораторы/@singledispatchmethod|@singledispatchmethod]] - перегрузка методов
### Перегрузка методов
Многие языки программирования (`C++`, `С#`, `Java`и другие) поддерживают перегрузку методов. Перегрузка методов позволяет определять множество одноименных методов с разной сигнатурой, то есть с разным количеством и типами принимаемых аргументов. Таким образом, методы могут выполнять различный код в зависимости от контекста их вызов

***Перегрузка методов*** - это прием программирования, который позволяет в зависимости от переданных в метод аргументов использовать определенную версию метода

Python, к сожалению, не поддерживает перегрузку методов напрямую. Мы знаем, что в Python классы хранят имена методов во внутреннем словаре `__dict__`. Как и любой словарь, `__dict__` не может иметь повторяющихся ключей, поэтому в одном классе не может быть нескольких методов с одинаковыми именами

Рассмотрим пустой класс `Cat`, в котором определим два метода с одинаковыми именами:
```python
class Cat:
    def say(self):
        print('meow')

    def say(self):
        print('мяу')


cat = Cat()

cat.say()
```
```
мяу
```
Python запоминает только последнюю реализацию метода. Ничто подобное происходит и при написании отдельных функций вне классов:
```python
def say_hello():
    print('Hello, World!')

def say_hello():
    print('Привет, мир!')

say_hello()
```
```
Привет, мир!
```
Последняя реализация нескольких одноименных функций преобладает над остальными реализациями

### Перегрузка инициализатора
Поскольку метод инициализации `__init__()` является, по сути обычным методом, мы не можем его перегружать. Мы можем обойти это ограничение несколькими способами, имитируя несколько инициализаторов. Рассмотрим каждый их них:
#### Использование необязательных аргументов
Наиболее простой способ имитации нескольких инициализаторов в классе - это необязательные аргументы с использованием значений по умолчанию. Таким образом, мы можем вызывать метод инициализации `__init__()` по-разному и каждый раз получать разное поведение
```python
class Cat:
    def __init__(self, breed='Британский', name='Кемаль'):
        self.breed = breed                                    # порода кошки, по умолчанию Британский
        self.name = name                                      # имя кошки, по умолчанию Кемаль


cat1 = Cat()                                                  # не передаем ничего
cat2 = Cat(name='Роджер')                                     # передаем только имя
cat3 = Cat(breed='Шотландский', name='Роджер')                # передаем всё

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
print(cat3.breed, cat3.name)
```
```
Британский Кемаль
Британский Роджер
Шотландский Роджер
```
Использование необязательных аргументов в методе `__init__()` - это чистый и основанный на `Python` метод создания классов, имитирующих несколько инициализаторов

#### Использование проверки типов аргументов
Другой способ имитации нескольких инициализаторов заключается в проверке типов аргументов, чтобы обеспечить различное поведение в зависимости от конкретного типа. Чтобы проверить тип в `Pyhon` метод создания классов, имитирующих несколько инициализаторов


#### Использование проверки типов аргументов
Другой способ имитации нескольких инициализаторов заключается в проверке типов аргументов, чтобы обеспечить различное поведение в зависимости от конкретного типа. Чтобы проверить тип в `Python`, мы обычно используем встроенную функцию `isinstance()`
```python
from datetime import date

class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date                      # дата рождения кошки
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)  # дата рождения кошки на основе строки


cat1 = Cat('Британский', 'Кемаль', date(2021, 3, 31))         # передаем объект date
cat2 = Cat('Шотландский', 'Роджер', '2020-09-10')             # передаем строку

print(cat1.breed, cat1.name, cat1.birth_date)
print(cat2.breed, cat2.name, cat2.birth_date)
```
```
Британский Кемаль 2021-03-31
Шотландский Роджер 2020-09-10
```
Здесь внутри метода `__init__()` мы используем условный оператор, чтобы проверить, какой тип имеет переданный аргумент `birth_day`. Если аргумент имеет тип `date`, то мы просто сохраняем его в атрибут `birth_date`, если же тип строковый, то мы предварительно преобразуем его в тип `date` с помощью метода `fromisoformat()`. Обратите внимание, что аргумент должен представлять из себя строку, содержащую корректную дату в ISO формате

Таким образом, мы имитируем два инициализатора. Один инициализатор принимает аргумент типа `date`, другой - `str`

техника в приведенном выше примере имеет серьезный недостаток, поскольку она плохо масштабируется. Если у нас есть аргументы, которые могут принимать значения разных типов, то наша реализация вскоре может стать нерабочей
```python
from datetime import date

class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)


cat = Cat('Британский', 'Кемаль', 1617173745)                 # передаем дату в формате Unix

print(cat.birth_date)
```
```
AttributeError: 'Cat' object has no attribute 'birth_date'
```
так получается, поскольку у условного оператора в инициализаторе не было ветки, которая обрабатывает числовое значение для аргумента `birth_date`

Чтобы устранить эту проблему, мы можем продолжить добавлять `elif`-ы, чтобы охватить все возможные форматы дат. Мы также можем добавить ветку `else`, чтобы перехватить все неподдерживаемые форматы дат.
```python
from datetime import date


class Cat:
    def __init__(self, breed, name, birth_date):
        self.breed = breed
        self.name = name
        if isinstance(birth_date, date):
            self.birth_date = birth_date
        elif isinstance(birth_date, str):
            self.birth_date = date.fromisoformat(birth_date)
        else:
            raise ValueError(f'неверный формат даты: {birth_date}')


cat = Cat('Британский', 'Кемаль', 1617173745)
```
```
ValueError: неверный формат даты: 1617173745
```
Использование проверки типов аргументов для имитации нескольких инициализаторов относится, скорее, к анти-паттернам в `Python`


#### Использование методов класса
Эффективным методом имитации нескольких инициализаторов является использование методов класса, которые создаются декоратором `@classmethod`. В отличие от обычных методов, методы класса не принимают текущий экземпляр `self` в качестве аргумента. Вместо этого они принимают сам класс, который обычно передается в качестве аргумента `cls`
```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    @classmethod
    def create_british_cat(cls, name):
        return cls('Британский', name)

    @classmethod
    def create_kemal_cat(cls, breed):
        return cls(breed, 'Кемаль')


cat1 = Cat('Британский', 'Кемаль')
cat2 = Cat.create_british_cat('Роджер')
cat3 = Cat.create_kemal_cat('Шотландский')

print(cat1.breed, cat1.name)
print(cat2.breed, cat2.name)
print(cat3.breed, cat3.name)
```
```
Британский Кемаль
Британский Роджер
Шотландский Кемаль
```
Использование методов класса - это чистый и основанный на `Python` метод создания классов, имитирующих несколько методов инициализации

#### Использование декоратора [[python/ООП в Python/Методы/Встроенные декораторы/@singledispatchmethod|@singledispatchmethod]]
Последний способ имитации нескольких инициализаторов заключается в создании универсальной функции одиночной диспетчеризации. Данный способ позволяет определить несколько инициализаторов и выборочно их использовать в зависимости от типа первого переданного в них аргумента

**Универсальная функция** (generic function) представляет собой функцию, составленную из нескольких функций, реализующих одну и ту же операцию для различных типов. **Одиночная диспетчеризация** (single dispatch) — это алгоритм, который выбирает нужную реализацию на основе типа **одного аргумента**. Именно поэтому диспетчеризация называется одиночной.

#### [[python/ООП в Python/Методы/Магические методы/Магические методы|Магические методы]]