#OOP #ООП #python #property


```python
class Cat:
    def __init__(self, name):
        self._name = name                               # имя кошки

    @property
    def name(self):                                     # геттер свойства name
        return self._name

    @name.setter
    def name(self, name):                               # сеттер свойства name
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):                                     # делитер свойства name 
        del self._name
```
Определяет в классе `Cat` свойство `name`, используя функцию `property()` в качестве декоратора

В отличии от прямого использования функции `property()`, нам не нужно определять методы аксессоры с разными именами, вместо этого мы сразу определяем три метода с общим именем `name`, которое и является именем создаваемого свойства

Сперва мы определяем метод `name()`, реализующий логику геттера и декорируем его функцией `property()`. Другими словами, мы создаем свойство `name`, которое пока что доступно только для чтения. Далее мы снова определяем метод `name()`, реализующий логику сеттера, однако на этот раз декорируем его не функцией `property()`, а функцией `name.setter()`

Дело в том, что все объекты `property` имеют три метода `getter()`, `setter()` и `deliter()`. Все они работают похожим образом. Например, метод `setter()` принимает в качестве аргумента некоторый метод `method` и возвращает новый объект `property`, который в качестве геттера и делитера имеет методы текущего объекта `property`, а в качестве сеттера - переданный метод `method`

Когда мы декорируем второй метод `name()` функцией `name.setter()`, мы создаем новый объект `property` и переприсваиваем его имени `name`. Этот новый объект в качестве геттера имеет геттер предыдущего объекта `property`, а в качестве сеттера - метод, указанный при его создании

Аналогично для свойства определяется и делитер. Мы создаем метод с тем же именем `name`, реализующий логику делитера, и декорируем его функцией `name.deleter()`, которая возвращает новый объект `property`, содержащий все методы предыдущего объекта `property`, а также делитер, указанный при его создании. Этот новый объект присваивается имени `name` и становится окончательным свойством с полным набором методов

Таким образом, применение функции `property()` в качестве декоратора - это последовательное создание новых свойств и переприсваивание их одной и той же переменной. Для наглядности мы можем записать данный процесс без использования синтаксиса декораторов

В целом, этот код эквивалентен коду из начала статьи:
```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    name = property(get_name)        # свойство, имеющее только геттер

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = name.setter(set_name)     # свойство, имеющее геттер предыдущего свойства, а также сеттер

    def del_name(self):
        del self._name

    name = name.deleter(del_name)    # свойство, имеющее геттер и сеттер предыдущего свойства, а также делитер
```

 Использование функции `property()` в качестве декоратора позволяет достаточно просто создавать свойства, доступные только для чтения.
```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name
```
создаем свойство `name`, доступное только для чтения.