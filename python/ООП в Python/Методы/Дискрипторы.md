#OOP #ООП #Python #магический_метод #дискрипторы


В Python существует три варианта доступа к атрибуту:
- получение значения атрибута
- изменение значения атрибута
- удаление атрибута

```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)                            # получаем значение атрибута name

cat.name = 'Роджер'                        # изменяем значение атрибута name
print(cat.name)

del cat.name                               # удаляем атрибут name
print(hasattr(cat, 'name'))
```
```
Кемаль
Роджер
False
```
`Python` позволяет перехватывать вышеупомянутые попытки доступа к атрибуту и переопределять связанное с этим доступом поведение. Мы уже сталкивались с подобным, когда говорили о свойствах - объектах типа `property` - при доступе к которым происходит вызов соответствующего метода. Свойства были полезны тем, что внутри методов, вызываемых при доступе к ним, мы могли добавлять дополнительную логику, например, проверку на корректность устанавливаемого значения
```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения свойства name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения свойства name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление свойства name')
        del self._name 


cat = Cat('Кемаль')

cat.name                                   # получаем значение свойства name
cat.name = 'Роджер'                        # изменяем значение свойства name
del cat.name                               # удаляем свойство name
```
```
Получение значения свойства name
Изменение значения свойства name
Удаление свойства name
```
Стандартное поведение при доступе к атрибуту - это получение, установка и удаление атрибута из словаря объекта `__dict__()`. Однако при аналогичном доступе к свойству происходит вызов одного из методов. Это реализуется через протокол дескрипторов. __дескриптором__ же называют объект со связанным поведением, то есть такой объект, чье поведение при доступе к нему как к атрибуту переопределяется методами протокола дескрипторов: `__get__()`, `__set__()` и `__delete__()`. Если хотя бы один из этих методов определен для объекта, то он считается дескриптором.

Благодаря тому, что для свойств определены методы протокола дескрипторов, их поведение гораздо более функционально, нежели поведение обычных атрибутов. Сами же свойства, по сути, являются обычными дескрипторами
```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения атрибута name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения атрибута name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление атрибута name')
        del self._name 


name_property = Cat.name

print(hasattr(name_property, '__get__'))
print(hasattr(name_property, '__set__'))
print(hasattr(name_property, '__delete__'))   
```
```
True
True
True
```
Методы `__get__()`, `__set__()` и `__delete__()` можно вызывать и напрямую через сами дескрипторы, в нашем случае через свойство
```python
class Cat:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        print('Получение значения атрибута name')
        return self._name

    @name.setter
    def name(self, value):
        print('Изменение значения атрибута name')
        if isinstance(value, str) and len(value) > 0:
            self._name = value
        else:
            raise ValueError('Некорректное имя')

    @name.deleter
    def name(self):
        print('Удаление атрибута name')
        del self._name 


cat = Cat('Кемаль')
name_property = Cat.name                   # свойство name, он же объект типа property, он же дескриптор

name_property.__get__(cat, Cat)            # равнозначно cat.name
name_property.__set__(cat, 'Роджер')       # равнозначно cat.name = 'Роджер'
name_property.__delete__(cat)              # равнозначно del cat.name
```
```
Получение значения атрибута name
Изменение значения атрибута name
Удаление атрибута name
```
Обратите внимание на аргументы, принимаемые методами протокола дескрипторов:
- метод `__get__()` принимает экземпляр класса и его класс
- метод `__set__()` принимает экземпляр класса и устанавливаемое значение
- метод `__delete__()` принимает лишь экземпляр класса

### Протокол дескрипторов
Дескриптор - это объект, для которого определены методы протокола дескриптора `__get__()`, `__set__()` и `__delete__()`, реализующие поведение при доступе к объекту как к атрибуту. При получении значения дескриптора вызывается метод `__get__()`, при изменении значения вызывается метод `__set__()`, а при удалении вызывается метод `__delete__()`. Определяя в классе данные методы, мы можем создавать собственные дескрипторы.

Вернемся к классу `Cat`, описывающему кошку, экземпляры которого имеют атрибут `name`, содержащий имя:
```python
class Cat:
    def __init__(self, name):
        self.name = name
```
Под корректным именем мы понимаем любую непустую строку поэтому хотим, чтобы при его установке или изменении присутствовала проверка на корректность. Мы можем решить данную проблему с помощью функции `property()`, однако теперь попробуем сделать это с помощью собственного дескриптора `NonEmptyString`:
```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибут не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]
```
Рассмотрим методы дескриптора. Метод `__init__()` имеет параметр `attr`, целью которого является получение имени, за которым будет закреплен дескриптор. Метод `__get__()` возвращает из словаря `__dict__` объекта `obj` значение атрибута `attr`, если он там есть. То есть при обращении к дескриптору как к атрибуту мы будем получать значение необходимого атрибута объекта. Метод `__set__()` изменяет значение атрибута `attr` в словаре `__dict__` объекта `obj`, предварительно проверяя устанавливаемое значение на корректность. То есть при изменении значения дескриптора с помощью оператора присваивания `=` мы будем изменять значение атрибута объекта. Метод `__delete__()` удаляет из словаря объекта атрибут `attr`

В методах протокола дескрипторов необходимо напрямую обращаться к словарю объекта `__dict__`, чтобы избежать исключения `RecursionError`, так как иные обращения к атрибуту будут перехватываться протоколом дескрипторов
```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)

del cat.name
print(hasattr(cat, 'name'))
```
```
Кемаль
Роджер
False
```
Для большей наглядности мы можем добавить в методы протокола дескриптора вывод некоторого сообщения, чтобы проследить за тем, когда эти методы вызываются
```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        print('Вызов метода __set__()')
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        print('Вызов метода __delete__()')
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

cat.name
cat.name = 'Роджер'
del cat.name
```
```
Вызов метода __set__()
Вызов метода __get__()
Вызов метода __set__()
Вызов метода __delete__()
```
Стоит обратить внимание на первый вызов метода `__set__()`, он происходит внутри метода `__init__()` при инициализации экземпляра класса. В строке `self.name = name` выполняется обращение к дескриптору `name` со значением `Кемаль`. Важно понимать, что в строке `self.name = name` мы обращаемся именно к дескриптору и вызываем его методы, а не просто устанавливаем объекту новый атрибут.

Также следует отметить, что дескрипторы являются атрибутами класса и создаются единожды при определении класса. Это значит, что все экземпляры класса используют один и тот же дескриптор. Поэтому дескрипторы внутренне не хранят значения атрибутов, но они хранят имена атрибутов, с помощью которых могут получить доступ к значениям этих атрибутов.

Обращение к дескриптору через класс приводит к вызову метода `__get__()` с автоматической передачей в качестве экземпляра класса значения `None`
```python
class Descriptor:
    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        print(obj, cls)

class Cat:
    name = Descriptor()


Cat.name
```
```
Вызов метода __get__()
None <class '__main__.Cat'>
```
Для корректной работы дескриптора рекомендуется всегда проверять, какое обращение происходит к дескриптору - через класс или через экземпляр класса. Если обращение происходит через экземпляр класса, нужно вернуть значение необходимого атрибута, если же обращение происходит через класс, нужно вернуть сам дескриптор
```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self.attr = attr

    def __get__(self, obj, cls):
        if obj is None:               # проверка на то, как осуществляется обращение
            return self
        if self.attr in obj.__dict__:
            return obj.__dict__[self.attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self.attr] = value
        else:
            raise ValueError('Некорректное значение')

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)
print(Cat.name)
```
```
Кемаль
<__main__.NonEmptyString object at 0x000001B0F5A134C0>
```

#### Магический метод [[__set_name__()]]

#### Цепочка поиска атрибутов
Дескрипторы можно дополнительно разделить на __дескрипторы данных__(data descriptor) и __дескрипторы не-данных__(non-data descriptor). Если для дескриптора определен лишь метод `__get__()`, то это дескриптор не-данных. Такой дескриптор доступен только для чтения. Если для дескриптора дополнительно определен хотя бы один из методов `__set__()` и `__delete__()`, то это дескриптор данных. Различие между дескрипторами данных и не-данных не только в количестве определенных методов, но и в приоритете их поиска при доступе

По умолчанию при обращении к атрибуту экземпляра класса происходит его поиск сначала в словаре `__dict__` самого экземпляра, а затем в словаре его класса. Однако мы могли заметить, что используя одно и то же имя для атрибута экземпляра класса и для дескриптора, являющегося атрибутом класса, обращение по этому имени происходит именно к дескриптору.
```python
class NonEmptyString:
    def __set_name__(self, cls, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')

class Cat:
    name = NonEmptyString()

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

print(cat.name)
print(cat.__dict__)
print(Cat.__dict__)
```
```
Вызов метода __get__()
Кемаль
{'name': 'Кемаль'}
{'__module__': '__main__', 'name': <__main__.NonEmptyString object at 0x000001CF9B207BB0>, '__init__': <function Cat.__init__ at 0x000001CF9B22EF80>, '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>, '__doc__': None}
```
Дело в том, что при доступе к атрибуту цепочка его поиска несколько сложнее. Рассмотрим пошагово, как `Python` ищет необходимый атрибут, когда происходит попытка обратиться к нему:
-  сперва Python пробует вернуть возвращаемое значение метода `__get__()` дескриптора данных, имеющего то же имя, что и искомый атрибут
- если это не удается, Python пробует вернуть значение по ключу, имеющему то же имя, что и искомый атрибут, из словаря `__dict__` экземпляра класса
- если это не удается, Python пробует вернуть возвращаемое значение метода `__get__()` дескриптора не-данных, имеющего то же имя, что и искомый атрибут
- если это не удается, Python пробует вернуть значение по ключу, имеющему то же имя, что и искомый атрибут, из словаря `__dict__` класса
- если это не удается, то предыдущие шаги повторяются для всех родительских классов
- если это не удается, Python возбуждает исключение `AttributeError`

При создании дескриптора, доступного только для чтения, рекомендуется явно определять метод `__set__()`, при вызове которого возбуждается исключение с сообщением о том, что значение дескриптора изменить нельзя. Это необходимо для того, чтобы дескриптор имел необходимый приоритет при доступе к нему.


