#OOP #ООП #Python #декоратор 


Декораторы можно применять не только к функциям и методам, но и к классам. Декорирование класса позволяет модифицировать поведение и содержание класса без изменения его исходного кода

Синтаксически декорирование класса ничем не отличается от декорирования функции. Например, если у нас есть класс `MyClass` и декоратор `@decorator` то применить второй к первому мы можем одним из следующих способов:
1. 
```python
    @decorator
    class MyClass:
        pass
```
2. 
```python
    MyClass = decorator(MyClass)
```

### Примеры декорирования классов
Подход декорирования функции несколько отличается от декорирования класса. Если в первом случае мы заменяем функцию другой функцией или вызываемым объектом, то во втором случае мы модифицируем исходный класс и возвращаем его же. Конечно, мы можем аналогичным образом определить новый класс, который внутренне будет использовать декорируемый класс, и вернуть его, однако данный способ нецелесообразен ввиду свой сложности

Рассмотрим несколько примеров декорирования классов в порядке увеличения их сложности
##### Пример 1
Реализуем декоратор класса `@add_attr` , который добавляет декорируемому классу атрибут `attr` со значением `None`
```python
def add_attr(cls):
    cls.attr = None                        # добавляем декорируемому классу атрибут attr
    return cls                             # возвращаем декорируемый класс

@add_attr
class MyClass:
    pass


print(MyClass.attr)
```
```
None
```
Здесь декоратор `@add_attr` представляет собой функцию, которая принимает в качестве аргумента декорируемый класс, добавляет ему атрибут `attr` и возвращает его же. Стоит заметить, что в таком случае нам не нужно сохранять информацию о декорируемом классе, так как мы не определяем новый класс и все операции выполняем с исходным классом
##### Пример 2
Реализуем декоратор класса `@add_attr_to_instances`, который добавляет экземплярам декорируемого класса атрибут `attr` со значением `None`

Для реализации данного декоратора нам нужно вмешаться в процесс инициализации экземпляров декорируемого класса, то есть модифицировать метод `__init__()`. Сделать это мы можем путем определения нового инициализатора и подмены их исходного. Также важно предварительно сохранить исходный инициализатор, чтобы воспользоваться им в новом инициализаторе
```python
import functools

def add_attr_to_instances(cls):
    old_init = cls.__init__                  # сохраняем исходный инициализатор
    
    @functools.wraps(old_init)
    def new_init(self, *args, **kwargs):
        old_init(self, *args, **kwargs)      # вызываем исходный инициализатор
        self.attr = None                     # добавляем экземпляру класса атрибут attr
    
    cls.__init__ = new_init                  # заменяем исходный инициализатор новым
    return cls

@add_attr_to_instances
class MyClass:
    pass

obj = MyClass()
print(obj.attr)
```
```
None
```
Здесь, как и в прошлом примере, декоратор `@add_attr_to_instances` принимает в качестве аргумента класс, модифицирует его и возвращает. Сперва происходит сохранение исходного магического метода `__init__()` декорируемого класса в переменной `old_init`. Сделать это необходимо по той причине, что далее этот метод у класса будет заменен, и если мы не сохраним его, то потеряем к нему доступ

После идет определение функции `new_init()`, которая представляет собой новый инициализатор, то есть функцию, заменяющую магический метод `__init__()` декорируемого класса. Сигнатура данной функции на первом месте содержит параметр `self`. Сделано это исключительно ради удобства, чтобы внутри функции обращаться к экземпляру декорируемого класса через имя `self`. Сигнатура функции может иметь вид `(*args, **kwargs)`, однако в данном случае экземпляр декорируемого класса будет доступен через `args[0]`

Так как функция `new_init()` является новым инициализатором, в качестве первой операции она выполняет вызов исходного инициализатора, чтобы сохранить его функционал. Далее она выполняет свою задачу - добавляет экземпляру декорируемого класса атрибут `attr`со значением `None`

Завершающим этапом является замена исходного инициализатора новым, после которой декорируемый класс по имени `__init__` будет содержать функцию `new_init()`, определенную выше, а не функцию `__init__()`, определенную в теле этого класса
##### Пример 3
Реализуем декоратор класса `@add_attr_to_instances`, который принимает произвольное количество именованных аргументов и добавляет их экземплярам декорируемого класса в качестве атрибутов
```python
import functools

def add_attr_to_instances(**attrs):
    def decorator(cls):
        old_init = cls.__init__
    
        @functools.wraps(old_init)
        def new_init(self, *args, **kwargs):
            old_init(self, *args, **kwargs)
            self.__dict__.update(attrs)   # добавляем атрибуты экземпляру декорируемого класса
    
        cls.__init__ = new_init
        return cls
    
    return decorator

@add_attr_to_instances(first_attr=1, second_attr=2)
class MyClass:
    pass


obj = MyClass()

print(obj.first_attr)
print(obj.second_attr)
```
```
1
2
```
Решение в данном примере практически полностью повторяет решение из предыдущего примера. Отличие лишь в том, что здесь мы получаем дополнительный уровень вложенности, так как декоратор `@add_attr_to_instances` принимает в качестве аргументов имена и значения устанавливаемых атрибутов, а не класс. Фактически декоратором является вложенная функция `decorator()`, возвращаемая декоратором `@add_attr_to_instances`. Именно она принимает в качестве аргумента класс, модифицирует его и возвращает
##### Пример 4
Реализуем декоратор класса `@count_instances`, который считает количество созданных экземпляров декорируемого класса. Счетчик доступен по атрибуту `count`
```python
import functools

def count_instances(cls):
    old_init = cls.__init__
    cls.count = 0                                   # счетчик созданных экземпляров декорируемого класса
    
    @functools.wraps(old_init)
    def new_init(self, *args, **kwargs):
        old_init(self, *args, **kwargs)
        cls.count += 1                              # увеличение счетчика на единицу   
    
    cls.__init__ = new_init
    return cls

@count_instances
class MyClass:
    pass


print(MyClass.count)

for _ in range(10):
    obj = MyClass()

print(MyClass.count)
```
```
0
10
```
Так как функция `new_init()` является новым инициализатором, мы применяем е ней декоратор `@functools.wraps`, чтобы она содержала всю информацию исходного инициализатора: имя, строку, документации и т.д.
