#python #память #механика


Python - это язык с автоматическим управлением памятью. Причем для управления ею он использует несколько механизмов. При запуске `Python` программы создается новый #процесс`есть в словаре`, в рамках которого операционная система выделяет пул ресурсов, включая #виртуальное_адресное_пространство. В эту память загружается интерпретатор `Python`
вместе со всеми необходимыми ему для работы данными, включая код нашей программы.

Оставшееся свободная виртуальная память используется для хранения Python объектов. Для управления этой памятью в Python используется специальный механизм, который называется **аллокатор.** Он используется каждый раз, когда нам нужно создать новый объект.

Чаще всего программы не оперируют большими объектами, Большая часть данных - это числа, строки, и т.д., они занимают не такой уж большой объем в расчете не одно значение. о зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти - сравнительно очень долгий процесс, связанный с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python - оптимизация количества системных вызовов.

Для больших объектов Python выделяет память напрямую у ОСи. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в оперативную память не так высоки.

Аллокатор для малых объектов использует три уровня абстракции:
- блок - кусок памяти, используемый для хранения одного объекта
- пул - кусок памяти, содержащий блок (обычно это одна страница виртуальной памяти 4килобайта)
- арена - большой непрерывный кусок памяти, содержащий пулы (обычно содержит несколько страниц виртуальной памяти и имеет размер 256 килобайт)

![[Pasted image 20240521165002.png]]

#### Блок
это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 8 до 512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока. Градация в приведенной ниже таблице ниже:
  
|Запрос памяти в байтах|Размер блока в байтах|Индекс класса размера|
|---|---|---|
|1-8|8|0|
|9-16|16|1|
|17-24|24|2|
|25-32|32|3|
|33-40|40|4|
|41-48|48|5|
|...|...|...|
|505-512|512|63|
взята прямо из комментариев в исходном коде
https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c#L603
Таким образом:
- если необходимы 6 байт, то данные будут помещены в блок размером 8 байт.
- если 42 байта, то в блок размером 48 байт
- и т.д.
#### Пул
Пулы состоят из блоков одного размера. Каждый пул работает по принципу двухсвязного списка с другими пулами того же размера. Поэтому алгоритм может с легкостью найти необходимое место для требуемого размера блока даже среди множества пулов. Размер пула равен 4 килобайта.

Ограничение пула фиксированным размером блоков помогает с #фрагментация. Если объект уничтожается, аллокатор может заполнить это пространство новым объектом того же размера.

Для эффективного управления пулами Python использует дополнительный список, который называется `usedpools`. Он хранит указатели на пулы, сгруппированные по классам. Как мы уже знаем, все пулы с одинаковым размером блока связанны между собой с помощью двухсвязного списка. Чтобы перебрать их, нам просто нужно знать начало списка. Если пулов такого размера нет, то при первом запросе памяти будет создан новый пул.

![[Pasted image 20240521234703.png]]

Пулы находятся в трех состояниях:
- используемый (used) — частично заполненный, какие-то блоки заняты, какие-то свободны
- полный (full) — полностью заполненный, все блоки заняты 
- пустой (empty) — все блоки свободны и доступны для записи (хранятся в списке пустых пулов `freepools`)

![[Pasted image 20240521234805.png]]

Используемый пул содержит блоки, в которые можно записать какую-то информацию. Блоки полного пула все распределены и уже содержат данные. Пустые пулы не содержат данных и могут быть разбиты на какие угодно классы размера при необходимости.

Допустим, нашему коду необходимо 8 байт. Если в списке используемых пулов нет пулов с классом размера в 8 байт, то новый пустой пул инициализируется, как хранящий блоки по 8 байт. Затем пустой пул добавляется в список используемых пулов и может быть использован при следующих запросах.

Заполненный пул освобождает некоторые блоки, кода эта информация в них уже не нужна. Этот пул добавится в список используемых в соответствии со своим классом размера.

Обратите внимание , что пулы и блоки не выделяют память напрямую, вместо этого они используют уже выделенное пространство в аренах.

#### Арена
Арена - это кусок памяти размером в 256 килобайт, который обеспечивает память для 64 пулов.

![[Pasted image 20240521235855.png]]

Арены, в отличии от пулов, не имеют явных разделений на состояния. Они сами по себе организованны в двух связанный список `usable_arenas`. Этот список отсортирован по количеству свободных пулов. Чем меньше свободных пулов, тем ближе арена к началу списка.

![[Pasted image 20240522000058.png]]

Это означает, что наиболее полная арена будет выбрана для записи еще большего количества данных. Такое расположение арен позволяет снизить объем потребляемой программой памяти. Дело в том, что в некоторых случаях, когда память освобождается, она все еще остается недоступной ОС. Процесс Python держит ее распределенной и использует ее позже для новых данных. Полное освобождение памяти возвращает память в пользование ОС.

Арены - единственные области, которые могут быть полностью освобождены. Таким образом мы понимаем, что те арены, которые находятся в списке ближе к пустому состоянию, должны быть освобождены. В таком случае, область памяти может быть действительно полностью освобождена, и соответственно общий объем памяти Python программы будет уменьшен. 

Языки с ручным распределением памяти кратно быстрее языков с автоматическим распределением памяти.

Исходный код аллокатора: https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c

Статейка на Хабре: https://habr.com/ru/company/domclick/blog/530804/

Визуализировать все объекты в памяти можно при помощи модуля [objgraph](https://mg.pov.lt/objgraph/)![[Pasted image 20240524170227.png]]