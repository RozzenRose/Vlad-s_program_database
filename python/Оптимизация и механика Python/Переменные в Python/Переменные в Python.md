#OC #Python #пременные #механика


Переменные в Python в корне отличаются от переменных в языках C и C++. По сути, их просто нет в Python. Вместо переменных здесь имена. Чаще всего можно воспринимать имена в Python  в качестве переменных, но необходимо понимать разницу.

[[Идентификаторы переменных. Встроенная функция id()]]
[[Идентичности переменных. Оператор is]]
[[Интернирование объектов в Python]]

## Переменные в C  и C++

Представим код, которые определяет переменную `num`:
```C++
int num = 101;
```
Исполнение этой строки кода проходит через несколько этапов:
1. Выделение достаточного количества памяти для числа
2. Присвоение этому месту в памяти значения 101
3. Отображение, что `num` указывает на это значение

Упрощенно память может выглядеть так:
![[Pasted image 20240523111059.png]]

Здесь переменная `num` имеет виртуальный адрес `0x7f1` и значение `101`. Если позднее нам захочется изменить значение `num`, это можно сделать так:
```C++
num = 102;
```
Этот код присваивает переменной `num` новое значение `102`, тем самым перезаписывая предыдущее значение. 
то означает, что переменная `num` изменяема. Обновленная схема памяти для нового значения:
![[Pasted image 20240523111717.png]]

Расположение `num` в памяти не поменялось, только само значение. Это говорит о том, что `num` - это место в памяти, а не просто имя. Можно сказать, что переменная `num` владеет местом в памяти. По сути, `num` - это пустая коробка, которая может содержать лишь одно целое число (тип `int`)

Когда мы присваиваем `num` какое-то значение, мы тем самым помещаем значение в коробку, принадлежащую `num`. При этом создать новую переменную `num1` можно следующим образом:
```C++
int num1 = num;
```
Этот код создает новую коробку под названием `num1` и копирует в нее значение из `num`. Теперь схема памяти выглядит так:
![[Pasted image 20240523112456.png]]

Стоит обратить внимание на местоположение `num1` - `0x7f5`. Хотя в `num1` и было скопировано значение `num`, однако переменная `num1`владеет новым адресом в памяти. Следовательно, мы можем перезаписать значение `num1`, не влияя на `num`:
```C++
num1 = 13;
```
Теперь схема памяти выглядит так:
![[Pasted image 20240523112748.png]]

Таким образом мы изменили значение переменной `num1`, но не ее местоположение. Кроме того, мы никак не повлияли на исходную переменную `num`.

С переменными в `Python` совершенно иная ситуация.


## Переменные в Python
В Python нет переменных, как таковых, вместо них имена. Мы можем использовать термин переменные, однако важно понимать разнице между переменными и именами. 

Давайте возьмем эквивалентный код из вышеприведенного примера на `C(C++)` и напишем его на Python:
```Python
num = 101
```
Как и в `C(C++)`, исполнение этой строки кода проходит через несколько этапов:
1. создается специальный объект `PyObject`
2. заполняется его поле `Type`, которое указывает на тип
3. заполняется его поле `Value`, которое указывает на значение 
4. создается имя `num`
5. имя `num`  начинает указывать на созданный `PyObject`
6. счетчик ссылок объекта `PyObject` увеличивается на `1`

Это все выглядит примерно следующим образом:
![[Pasted image 20240523113815.png]]

Как мы видим, схема памяти в Python отличается от схемы в `C(C++)`, показанной выше. Вместо того чтобы `num` владел блоком памяти, в котором хранится значение `101`, этой памятью владеет `PiObject` объект.

Таким образом, в Python имя `num` не владеет напрямую каким-либо адресом в памяти.

Для присвоения нового значения имени `num` мы используем следующий код:
```python
num = 101
num = 102
```
Исполнение этой строки кода проходит через несколько этапов:
- создаётся новый `PyObject`
- заполняется его поле `Type`, которое указывает на тип
- заполняется его поле `Value`, которое указывает на значение
- имя `num` указывает на новый `PyObject`
- счётчик ссылок (поле `Reference Count`) нового `PyObject` увеличивается на `1`
- счётчик ссылок (поле `Reference Count`) старого `PyObject` уменьшается на `1`

Теперь схема памяти выглядит так:
![[Pasted image 20240523114431.png]]

Картинка выше демонстрирует , что `num` указывает на объект и не владеет областью памяти напрямую. Также мы видим, что строка кода `num = 101` является не присваиванием, а, скорее, привязкой (bindung) имени `num` к объекту.

Кроме того, предыдущий объект (содержащий значение `101`) теперь находится в памяти со счетчиком ссылок, равным `0`, и подлежит удалению с помощью сборщика мусора, о котором будет сказано позже.

Мы можем ввести новое имя `num1`:
```python
num = 101
num = 102
num1 = num
```

В памяти появится новое имя `num1`, но не новый объект:
![[Pasted image 20240523114925.png]]

Мы видим, что новый Python объект не создан, создано только новое имя, которое указывает но тот же объект. Кроме того, счетчик ссылок объекта увеличился на `1`.

В Python мы не создаем переменные, а привязываем имена к объектам.

Линк на сурс:
RU:https://habr.com/ru/company/otus/blog/666858/
EN:https://www.pythonmorsels.com/pointers/