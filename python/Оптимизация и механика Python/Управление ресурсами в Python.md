#OC #Python #механика #оптимизация


`Python` является языком с управляемой памятью, то есть программисту, пишущему код на `Python`, не нужно беспокоится о работе с памятью и заниматься ее освобождением. Как только данные программы становятся не нужны, сборщик мусора автоматически удаляет их и освобождает  память, которую они занимали.

Однако  при работе с `внешней памятью`, такими как файлы, очень важно своевременно их освобождать (закрывать). В некоторых случаях `Python` может самостоятельно закрыть файл, но лучше на это не рассчитывать и закрывать файл явно.
```python
file = open('output.txt', mode='w', encoding='utf-8')
file.write('Excalibur!')
file.close()
```
создает текстовый файл с именем `output.txt` и записывает в него строку текста `Excalibur!`

Ручное закрытие файлов, в так же отдача закрытия на откуп `Python`, обладают одним существенным недостатком: если между открытием файла и его закрытием будет возбуждено исключение, то файл может остаться открытым и недоступным для других процессов, что может привести к проблемам. В лучшем случае файл окажется открыт слишком долго, а в худшем случае не сохранится часть данных

Вывод данных в файл при помощи методов `write()` и `writelines()` буферизируется, поэтому записываемые данные могут попасть на диск не сразу. Для форсирования сброса использовать файловый метод `flush()`

Для того чтобы гарантировать закрытие файла даже при наличии исключений, мы можем использовать конструкцию `try-finally`
```python
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
finally:
    file.close()
```
гарантированно закрывает файл, даже если между его открытием и закрытием будет возбуждено исключение. Мы также можем обработать возникшее исключение с помощью блока  `except`, после чего закрыть файл:
```python
file = open('output.txt', mode='w', encodiung='utf-8')

try:
	file.write('Python generation!')
except Exception as error:
	print(f'При записи в файл вознкла ошибка: {error}')
finally:
	file.close()
```

### Оператор with
Подход, основанный на использовании конструкции `try-finally`, для освобождения внешних ресурсов рабочий, однако достаточно громоздкий. При его использовании мы пишем один и тот же код каждый раз, когда нам нужно освободить ресурс.

В `Python` для удобного и своевременного освобождения ресурсов есть специальный оператор `with`
```python
file = open('output.txt', mode='w', encoding='utf-8') as file:
	file.write('Python generation!')
```
Как мы видим, явные вызовы метода `close()` пропали, однако при этом файл закрывается надежно и вовремя. Помимо надежного и своевременного закрытия файла, код с использованием `with` выглядит понятнее и короче, а также не содержит ненужный шаблон код

Оператор `with` является своего рода `синтаксических сахаром`, и за кулисами разворачивается практически тот же самый блок `try-finally`

Объект, которым управляет оператор `with`, не обязательно должен создаваться в нем. Приведенный выше код можно переписать в виде:
```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    file.write('Python generation!')
```
Оператор `with` также может управлять сразу несколькими объектами
```python
with open('file.txt', encoding='utf-8') as file, open('output.txt', mode='w', encoding='utf-8') as output:
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```
нумерует строки файла `file.txt` и записывает их в файл `output.txt`

При наличии нескольких объектов в операторе `with` они обрабатываются так, как если бы несколько операторов `with` были вложенными

Приведенный ниже код эквивалентен коду выше:
```python
with open('file.txt', encoding='utf-8') as file:
    with open('output.txt', mode='w', encoding='utf-8') as output:
        for index, line in enumerate(file, 1):
            output.write(f'{index}. {line}')
```

Несмотря на то, что оператор `with` короче использования конструкции `try-finally`, он все же менее универсален. Мы можем использовать оператор `with` только с объектами, поддерживающими протокол контекстного менеджера, в то время как конструкция `try-finally` позволяет выполнять действия по очистке произвольных объектов без необходимости поддержки какого-либо протокола.