#Python #переменные #изменяемый_объект #неизменяемый_объект #механика #copy



Типы данных в Python делятся на две категории:
- изменяемые (`list, set, dict, ...`)
- неизменяемые (`int, float, bool, tuple, str, ...`)

Попробуем изменить первый символ строки:
```python
data = 'beegeek'
data[0] = 'B'

print(data)
```
```
TypeError: 'str' object does not support item assignment
```
В тоге мы получаем ошибку, поскольку тип `str` является неизменяемым.
А все строковые методы возвращают новые объекты, а не модифицированные старые, и так работают любые методы неизменяемых объектов.

```python
data = ['b', 'e', 'e', 'g', 'e', 'e', 'k']
data[0] = 'B'

print(data)
```
```
['B', 'e', 'e', 'g', 'e', 'e', 'k']
```
поскольку списки (тип `list`) являются изменяемыми.


### Изменение объектов VS оператор присваивания

В Python существует два типа изменения:
- присвоение переменной нового значения
- непосредственное изменение объекта

```python
nums = [1, 2, 3]
print(nums)
print(id(nums))

nums = [1, 2, 3] + [4]
print(nums)
print(id(nums))
```
```no-highlight
[1, 2, 3]
2130653012352
[1, 2, 3, 4]
2130653007680
```
Этот код всегда выводит различные идентификаторы числа.
Так как мы не изменяем исходный список, а создаем новый и присваиваем его в прежнюю переменную.

И каждый раз, когда мы будем пересоздавать список заново, его `id()` скорее всего будет меняться. Может и нет, но это совпадение. На самом деле изменяемый объект каждый раз переопределяет свой `id` при создании вне зависимости от того, существуют другие объекты с таким значением или нет.
```python
>>>id([1, 2, 3, 4])
2390101887296
>>>id([1, 2, 3, 4])
2390101899264
>>>id([1, 2, 3, 4])
2390101899264
>>>id([1, 2, 3, 4])
2390101952704
>>>id([1, 2, 3, 4])
2390101899264
>>>id([1, 2, 3, 4])
2390101952704
>>>id([1, 2, 3, 4])
2390101950976
>>>id([1, 2, 3, 4])
2390101899264
```

Но в место пересоздания объекта, мы можем модифицировать старый:
```python
nums = [1, 2, 3]

print(id(nums))
print(nums)

nums.append(4)

print(id(nums))
print(nums)
```
```
2675065348480
[1, 2, 3]
2675065348480
[1, 2, 3, 4]
```
И в этом случае `id` объекта не изменится.

То есть в первом случае мы создавали объект и присваивали его переменной, после чего мы как бы присваивали переменной новый объект, идентичный по логическому значению, но как бы новый все равно, а значит имеет новый `id`. А во втором случае, мы модифицируем объект, на которые ссылается переменная, и эта самая переменная продолжает ссылаться на этот же объект, объект присвоенный к переменной все тот же, а значит его id() не был изменен.

Так же стоит помнить о том, что если мы присваиваем переменную, к которая ссылается на изменяемый объект к другой переменной, то после такой операции обе переменные будут ссылаться на на один и тот же изменяемые объект. Из-за этого можно запутаться.
```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1.append(4)

print(nums1)
print(nums2)
```
```
[1, 2, 3, 4]
[1, 2, 3, 4]
```
Мы вроде проводим операцию добавления значения над объектом переменной `num1`, но при выводе объекта переменной `num2` выводиться объект, к которому была применена операция, которая вообще то применялась к объекту переменной `num1`. 
Все потому что обе переменные ссылаются на один и тот же объект. Таких приколов не возникает при работе с неизменяемыми объектами, например типов `int`, `str` и так далее.

Оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии. Для этого существует модуль `copy`

#### Подводные камни
##### tuple
Прикольная деталь: объекты типа `tuple` не изменяются, но если они содержат изменяемые объекты, то их можно изменить прямо внутри кортежа.
```python
data = (1, 'bee', [1, 2, 3], {'a': 1})

print(data)

data[2][2] = 30
data[3]['b'] = 2

print(data)
```
```
(1, 'bee', [1, 2, 3], {'a': 1})
(1, 'bee', [1, 2, 30], {'a': 1, 'b': 2})
```
Кортежи просто содержат ссылки на объекты.

##### list
Еще есть важная деталь при работе со списками. Интерпретатор Python по разному обрабатывает `+`  и `+=`
```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1 = nums1 + [4, 5]

print(nums1)
print(nums2)
```
```
[1, 2, 3, 4, 5]
[1, 2, 3]
```
В этом случае оператор `+` создал новый список `[1, 2, 3, 4, 5]`, который был присвоен переменной `nums1`, при этом `nums2` по-прежнему указывает на старый список `[1, 2, 3]`

```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1 += [4, 5]

print(nums1)
print(nums2)
```
```
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```
В этом примере оператор `+=` изменил текущий список, и эти изменения также видны в `nums2`
По сути, оператор `+=` для списков работает как списочный метод `extend()`

##### Дефолтные значения
Считается плохой практикой использование изменяемых типов данных в качестве значений параметров по умолчанию, так как значение по умолчанию для параметра создается единожды при определении функции(обычно при загрузке модуля) и становится атрибутом (свойством) функции. Поэтому если значением по умолчанию является изменяемы объект, то его изменение повлияет на каждый следующий вызов функции.
```python
def append(element, seq=[]):
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
print(append(3))
```
```
[10]
[10, 5]
[10, 5, 1]
[10, 5, 1, 3]
```

Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:
```python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
```
```
[10]
[5]
[1]
```